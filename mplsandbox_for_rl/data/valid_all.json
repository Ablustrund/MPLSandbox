[
    {
        "prompt": "\ndef FsxrN():\n    \"\"\"\"Duel!\"\n\nBetting on the lovely princess Claris, the duel between Tokitsukaze and Quailty has started.\n\nThere are $n$ cards in a row. Each card has two sides, one of which has color. At first, some of these cards are with color sides facing up and others are with color sides facing down. Then they take turns flipping cards, in which Tokitsukaze moves first. In each move, one should choose exactly $k$ consecutive cards and flip them to the same side, which means to make their color sides all face up or all face down. If all the color sides of these $n$ cards face the same direction after one's move, the one who takes this move will win.\n\nPrincess Claris wants to know who will win the game if Tokitsukaze and Quailty are so clever that they won't make mistakes.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^5$).\n\nThe second line contains a single string of length $n$ that only consists of $0$ and $1$, representing the situation of these $n$ cards, where the color side of the $i$-th card faces up if the $i$-th character is $1$, or otherwise, it faces down and the $i$-th character is $0$.\n\n\n-----Output-----\n\nPrint \"once again\" (without quotes) if the total number of their moves can exceed $10^9$, which is considered a draw.\n\nIn other cases, print \"tokitsukaze\" (without quotes) if Tokitsukaze will win, or \"quailty\" (without quotes) if Quailty will win.\n\nNote that the output characters are case-sensitive, and any wrong spelling would be rejected.\n\n\n-----Examples-----\nInput\n4 2\n0101\n\nOutput\nquailty\n\nInput\n6 1\n010101\n\nOutput\nonce again\n\nInput\n6 5\n010101\n\nOutput\ntokitsukaze\n\nInput\n4 1\n0011\n\nOutput\nonce again\n\n\n\n-----Note-----\n\nIn the first example, no matter how Tokitsukaze moves, there would be three cards with color sides facing the same direction after her move, and Quailty can flip the last card to this direction and win.\n\nIn the second example, no matter how Tokitsukaze moves, Quailty can choose the same card and flip back to the initial situation, which can allow the game to end in a draw.\n\nIn the third example, Tokitsukaze can win by flipping the leftmost five cards up or flipping the rightmost five cards down.\n\nThe fourth example can be explained in the same way as the second example does.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport copy\ndef FsxrN():\n    input = sys.stdin.readline\n    n,k=list(map(int,input().split()))\n    C=list(input().strip())\n    def JUDGE(C):\n        ANS_one=0\n        ANS_zero=0\n        for c in C:\n            if c==\"0\":\n                ANS_zero+=1\n            else:\n                break\n        for c in C[::-1]:\n            if c==\"0\":\n                ANS_zero+=1\n            else:\n                break\n        for c in C:\n            if c==\"1\":\n                ANS_one+=1\n            else:\n                break\n        for c in C[::-1]:\n            if c==\"1\":\n                ANS_one+=1\n            else:\n                break\n        if ANS_zero>=n-k or ANS_one>=n-k:\n            return 1\n        else:\n            return 0\n    if JUDGE(C)==1:\n        print(\"tokitsukaze\")\n        return\n    if k>=n-1:\n        print(\"quailty\")\n        return\n    if k<n/2:\n        print(\"once again\")\n        return\n        \n    CAN1=copy.copy(C)\n    CAN2=copy.copy(C)\n    if C[0]==\"0\":\n        for i in range(1,k+1):\n            CAN1[i]=\"1\"\n    else:\n        for i in range(1,k+1):\n            CAN1[i]=\"0\"\n    if C[-1]==\"0\":\n        for i in range(n-1,n-k-1,-1):\n            CAN2[i]=\"1\"\n    else:\n        for i in range(n-2,n-k-2,-1):\n            CAN2[i]=\"0\"\n    if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:\n        print(\"quailty\")\n        return\n    else:\n        print(\"once again\")\n        return\n        \n        \n        ",
        "inputs": [
            "4 2\n0101\n",
            "6 1\n010101\n",
            "6 5\n010101\n"
        ],
        "outputs": [
            "quailty\n",
            "once again\n",
            "tokitsukaze\n"
        ],
        "starter_code": "\ndef FsxrN():\n",
        "scope": [
            [
                "Function Body",
                3,
                63
            ],
            [
                "Function Body",
                7,
                33
            ],
            [
                "For Loop Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ],
            [
                "For Loop Body",
                15,
                19
            ],
            [
                "If Statement Body",
                16,
                19
            ],
            [
                "For Loop Body",
                20,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ],
            [
                "For Loop Body",
                25,
                29
            ],
            [
                "If Statement Body",
                26,
                29
            ],
            [
                "If Statement Body",
                30,
                33
            ],
            [
                "If Statement Body",
                34,
                36
            ],
            [
                "If Statement Body",
                37,
                39
            ],
            [
                "If Statement Body",
                40,
                42
            ],
            [
                "If Statement Body",
                46,
                51
            ],
            [
                "For Loop Body",
                47,
                48
            ],
            [
                "For Loop Body",
                50,
                51
            ],
            [
                "If Statement Body",
                52,
                57
            ],
            [
                "For Loop Body",
                53,
                54
            ],
            [
                "For Loop Body",
                56,
                57
            ],
            [
                "If Statement Body",
                58,
                63
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef STBHE():\n    \"\"\"We have a graph with N vertices and M edges, and there are two people on the graph: Takahashi and Aoki.\nThe i-th edge connects Vertex U_i and Vertex V_i.\nThe time it takes to traverse this edge is D_i minutes, regardless of direction and who traverses the edge (Takahashi or Aoki).\nTakahashi departs Vertex S and Aoki departs Vertex T at the same time. Takahashi travels to Vertex T and Aoki travels to Vertex S, both in the shortest time possible.\nFind the number of the pairs of ways for Takahashi and Aoki to choose their shortest paths such that they never meet (at a vertex or on an edge) during the travel, modulo 10^9 + 7.\n\n-----Constraints-----\n - 1 \\leq N \\leq 100 000\n - 1 \\leq M \\leq 200 000\n - 1 \\leq S, T \\leq N\n - S \\neq T\n - 1 \\leq U_i, V_i \\leq N (1 \\leq i \\leq M)\n - 1 \\leq D_i \\leq 10^9 (1 \\leq i \\leq M)\n - If i \\neq j, then (U_i, V_i) \\neq (U_j, V_j) and (U_i, V_i) \\neq (V_j, U_j).\n - U_i \\neq V_i (1 \\leq i \\leq M)\n - D_i are integers.\n - The given graph is connected.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nS T\nU_1 V_1 D_1\nU_2 V_2 D_2\n:\nU_M V_M D_M\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n4 4\n1 3\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n\n-----Sample Output-----\n2\n\nThere are two ways to choose shortest paths that satisfies the condition:\n - Takahashi chooses the path 1 \\rightarrow 2 \\rightarrow 3, and Aoki chooses the path 3 \\rightarrow 4 \\rightarrow 1.\n - Takahashi chooses the path 1 \\rightarrow 4 \\rightarrow 3, and Aoki chooses the path 3 \\rightarrow 2 \\rightarrow 1.\n    \"\"\"\n",
        "canonical_solution": "\ndef STBHE():\n    # ARC090E\n    \n    def hoge():\n        M = 10**9 + 7\n        import sys\n        input = lambda : sys.stdin.readline().rstrip()\n    \n        n, m = map(int, input().split())\n        s, t = map(int, input().split())\n        s -= 1\n        t -= 1\n        from collections import defaultdict\n        ns = defaultdict(set)\n        for i in range(m):\n            u, v, d = map(int, input().split())\n            ns[u-1].add((v-1, d))\n            ns[v-1].add((u-1, d))\n        \n        def _dijkstra(N, s, Edge):\n            import heapq\n            geta = 10**15\n            inf = geta\n            dist = [inf] * N\n            dist[s] = 0\n            Q = [(0, s)]\n            dp = [0]*N\n            dp[s] = 1\n            while Q:\n                dn, vn = heapq.heappop(Q)\n                if dn > dist[vn]:\n                    continue\n                for vf, df in Edge[vn]:\n                    if dist[vn] + df < dist[vf]:\n                        dist[vf] = dist[vn] + df\n                        dp[vf] = dp[vn]\n                        heapq.heappush(Q, (dn + df,vf))\n                    elif dist[vn] + df == dist[vf]:\n                        dp[vf] = (dp[vf] + dp[vn]) % M\n            return dist, dp\n    \n        def dijkstra(start):\n            import heapq\n            vals = [None] * n\n            nums = [None] * n\n            nums[start] = 1\n            h = [(0, start)] # (距離, ノード番号)\n            vals[start] = 0\n            while h:\n                val, u = heapq.heappop(h)\n                for v, d in ns[u]:\n                    if vals[v] is None or vals[v]>val+d:\n                        vals[v] = val+d\n                        nums[v] = nums[u]\n                        heapq.heappush(h, (vals[v], v))\n                    elif vals[v] is not None and vals[v]==val+d:\n                        nums[v] = (nums[v] + nums[u]) % M\n            return vals, nums\n        \n        vals1, nums1 = dijkstra(s)\n        vals2, nums2 = dijkstra(t)\n        \n        T = vals1[t]\n    \n        c1 = 0 # 頂点で衝突するペアの数\n        c2 = 0 # エッジ(端点除く)で衝突するペアの数\n        \n        for u in range(n):\n            if 2*vals1[u]==T and 2*vals2[u]==T:\n                c1 = (c1 + pow((nums1[u] * nums2[u]), 2, M)) % M\n            for v,d in ns[u]:\n                if (vals1[u]+d+vals2[v]==T) and (2*vals1[u] < T < 2*(vals1[u] + d)):\n                    c2 = (c2 + (nums1[u] * nums2[v])**2) % M\n        print((nums1[t]*nums2[s] - (c1+c2)) % M)\n    hoge()",
        "inputs": [
            "4 4\n1 3\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n",
            "3 3\n1 3\n1 2 1\n2 3 1\n3 1 2\n",
            "3 3\n1 3\n1 2 1\n2 3 1\n3 1 2\n"
        ],
        "outputs": [
            "2\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef STBHE():\n",
        "scope": [
            [
                "Function Body",
                2,
                76
            ],
            [
                "Function Body",
                5,
                75
            ],
            [
                "Lambda Expression",
                8,
                8
            ],
            [
                "For Loop Body",
                16,
                19
            ],
            [
                "Function Body",
                21,
                41
            ],
            [
                "While Loop Body",
                30,
                40
            ],
            [
                "If Statement Body",
                32,
                33
            ],
            [
                "For Loop Body",
                34,
                40
            ],
            [
                "If Statement Body",
                35,
                40
            ],
            [
                "If Statement Body",
                39,
                40
            ],
            [
                "Function Body",
                43,
                59
            ],
            [
                "While Loop Body",
                50,
                58
            ],
            [
                "For Loop Body",
                52,
                58
            ],
            [
                "If Statement Body",
                53,
                58
            ],
            [
                "If Statement Body",
                57,
                58
            ],
            [
                "For Loop Body",
                69,
                74
            ],
            [
                "If Statement Body",
                70,
                71
            ],
            [
                "For Loop Body",
                72,
                74
            ],
            [
                "If Statement Body",
                73,
                74
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef OwDJQ():\n    \"\"\"Alyona's mother wants to present an array of n non-negative integers to Alyona. The array should be special. \n\nAlyona is a capricious girl so after she gets the array, she inspects m of its subarrays. Subarray is a set of some subsequent elements of the array. The i-th subarray is described with two integers l_{i} and r_{i}, and its elements are a[l_{i}], a[l_{i} + 1], ..., a[r_{i}].\n\nAlyona is going to find mex for each of the chosen subarrays. Among these m mexes the girl is going to find the smallest. She wants this minimum mex to be as large as possible. \n\nYou are to find an array a of n elements so that the minimum mex among those chosen by Alyona subarrays is as large as possible.\n\nThe mex of a set S is a minimum possible non-negative integer that is not in S.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 10^5).\n\nThe next m lines contain information about the subarrays chosen by Alyona. The i-th of these lines contains two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n), that describe the subarray a[l_{i}], a[l_{i} + 1], ..., a[r_{i}].\n\n\n-----Output-----\n\nIn the first line print single integer — the maximum possible minimum mex.\n\nIn the second line print n integers — the array a. All the elements in a should be between 0 and 10^9.\n\nIt is guaranteed that there is an optimal answer in which all the elements in a are between 0 and 10^9.\n\nIf there are multiple solutions, print any of them.\n\n\n-----Examples-----\nInput\n5 3\n1 3\n2 5\n4 5\n\nOutput\n2\n1 0 2 1 0\n\nInput\n4 2\n1 4\n2 4\n\nOutput\n3\n5 2 0 1\n\n\n-----Note-----\n\nThe first example: the mex of the subarray (1, 3) is equal to 3, the mex of the subarray (2, 5) is equal to 3, the mex of the subarray (4, 5) is equal to 2 as well, thus the minumal mex among the subarrays chosen by Alyona is equal to 2.\n    \"\"\"\n",
        "canonical_solution": "\ndef OwDJQ():\n    f=lambda : list(map(int,input().split()))\n    n,m=f()\n    lr=lambda x: x[1]-x[0]+1\n    sq=min(lr(f()) for _ in range(m))\n    print(sq)\n    x=' '.join([str(i%sq) for i in range(n)])\n    print(x)\n    ",
        "inputs": [
            "5 3\n1 3\n2 5\n4 5\n",
            "4 2\n1 4\n2 4\n",
            "1 1\n1 1\n"
        ],
        "outputs": [
            "2\n0 1 0 1 0\n",
            "3\n0 1 2 0\n",
            "1\n0\n"
        ],
        "starter_code": "\ndef OwDJQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "Lambda Expression",
                3,
                3
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "Generator Expression",
                6,
                6
            ],
            [
                "List Comprehension",
                8,
                8
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef yMwiQ():\n    \"\"\"Snuke's town has a subway system, consisting of N stations and M railway lines. The stations are numbered 1 through N. Each line is operated by a company. Each company has an identification number.\nThe i-th ( 1 \\leq i \\leq M ) line connects station p_i and q_i bidirectionally. There is no intermediate station. This line is operated by company c_i.\nYou can change trains at a station where multiple lines are available.\nThe fare system used in this subway system is a bit strange. When a passenger only uses lines that are operated by the same company, the fare is 1 yen (the currency of Japan). Whenever a passenger changes to a line that is operated by a different company from the current line, the passenger is charged an additional fare of 1 yen. In a case where a passenger who changed from some company A's line to another company's line changes to company A's line again, the additional fare is incurred again.\nSnuke is now at station 1 and wants to travel to station N by subway. Find the minimum required fare.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 0 \\leq M \\leq 2×10^5\n - 1 \\leq p_i \\leq N (1 \\leq i \\leq M)\n - 1 \\leq q_i \\leq N (1 \\leq i \\leq M)\n - 1 \\leq c_i \\leq 10^6 (1 \\leq i \\leq M)\n - p_i \\neq q_i (1 \\leq i \\leq M)\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN M\np_1 q_1 c_1\n:\np_M q_M c_M\n\n-----Output-----\nPrint the minimum required fare. If it is impossible to get to station N by subway, print -1 instead.\n\n-----Sample Input-----\n3 3\n1 2 1\n2 3 1\n3 1 2\n\n-----Sample Output-----\n1\n\nUse company 1's lines: 1 → 2 → 3. The fare is 1 yen.\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom collections import deque\ndef yMwiQ():\n    #!/usr/bin/env python3\n    input = sys.stdin.readline\n    INF = 10**9\n    n, m = map(int, input().split())\n    pqc = []\n    seen = set()\n    for i in range(n):\n        seen.add((i, 0))\n    for _ in range(m):\n        p, q, c = map(int, input().split())\n        p -= 1; q -= 1\n        pqc.append((p, q, c))\n        seen.add((p, c))\n        seen.add((q, c))\n    comp = dict()\n    for i, node in enumerate(seen):\n        comp[node] = i\n    edge = [[] for _ in range(len(comp))]\n    for key in comp.keys():\n        v, c = key\n        if c != 0:\n            frm = comp[(v, c)]\n            too = comp[(v, 0)]\n            edge[frm].append((too, 0))\n            edge[too].append((frm, 1))\n    for p, q, c in pqc:\n        frm = comp[(p, c)]\n        too = comp[(q, c)]\n        edge[frm].append((too, 0))\n        edge[too].append((frm, 0))\n    class BFS:\n        def __init__(self, adj):\n            self.adj = adj\n            self.dist = [INF] * len(adj)\n            self.q = deque()\n        def calc(self, start):\n            self.dist[start] = 0\n            self.q.append((0, start))\n            while len(self.q) != 0:\n                prov_cost, src = self.q.popleft()\n                if self.dist[src] < prov_cost:\n                    continue\n                for dest, cost in self.adj[src]:\n                    if self.dist[dest] > self.dist[src] + cost:\n                        self.dist[dest] = self.dist[src] + cost\n                        if cost == 1:\n                            self.q.append((self.dist[dest], dest))\n                        else:\n                            self.q.appendleft((self.dist[dest], dest))\n            return self.dist\n    bfs = BFS(edge)\n    bfs.calc(comp[(0, 0)])\n    ans = bfs.dist[comp[(n-1, 0)]]\n    if ans == INF:\n        print(-1)\n    else:\n        print(ans)",
        "inputs": [
            "3 3\n1 2 1\n2 3 1\n3 1 2\n",
            "8 11\n1 3 1\n1 4 2\n2 3 1\n2 5 1\n3 4 3\n3 6 3\n3 7 3\n4 8 4\n5 6 1\n6 7 5\n7 8 5\n",
            "2 0\n"
        ],
        "outputs": [
            "1\n",
            "2\n",
            "-1\n"
        ],
        "starter_code": "\ndef yMwiQ():\n",
        "scope": [
            [
                "Function Body",
                3,
                60
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                12,
                17
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "List Comprehension",
                21,
                21
            ],
            [
                "For Loop Body",
                22,
                28
            ],
            [
                "If Statement Body",
                24,
                28
            ],
            [
                "For Loop Body",
                29,
                33
            ],
            [
                "Class Body",
                34,
                53
            ],
            [
                "Function Body",
                35,
                38
            ],
            [
                "Function Body",
                39,
                53
            ],
            [
                "While Loop Body",
                42,
                52
            ],
            [
                "If Statement Body",
                44,
                45
            ],
            [
                "For Loop Body",
                46,
                52
            ],
            [
                "If Statement Body",
                47,
                52
            ],
            [
                "If Statement Body",
                49,
                52
            ],
            [
                "If Statement Body",
                57,
                60
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef MotpB():\n    \"\"\"On the xy-plane, Snuke is going to travel from the point (x_s, y_s) to the point (x_t, y_t).\nHe can move in arbitrary directions with speed 1.\nHere, we will consider him as a point without size.\nThere are N circular barriers deployed on the plane.\nThe center and the radius of the i-th barrier are (x_i, y_i) and r_i, respectively.\nThe barriers may overlap or contain each other.\nA point on the plane is exposed to cosmic rays if the point is not within any of the barriers.\nSnuke wants to avoid exposure to cosmic rays as much as possible during the travel.\nFind the minimum possible duration of time he is exposed to cosmic rays during the travel.\n\n-----Constraints-----\n - All input values are integers.\n - -10^9 ≤ x_s, y_s, x_t, y_t ≤ 10^9\n - (x_s, y_s) ≠ (x_t, y_t)\n - 1≤N≤1,000\n - -10^9 ≤ x_i, y_i ≤ 10^9\n - 1 ≤ r_i ≤ 10^9\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nx_s y_s x_t y_t\nN\nx_1 y_1 r_1\nx_2 y_2 r_2\n:\nx_N y_N r_N\n\n-----Output-----\nPrint the minimum possible duration of time Snuke is exposed to cosmic rays during the travel.\nThe output is considered correct if the absolute or relative error is at most 10^{-9}.\n\n-----Sample Input-----\n-2 -2 2 2\n1\n0 0 1\n\n-----Sample Output-----\n3.6568542495\n\nAn optimal route is as follows:\n    \"\"\"\n",
        "canonical_solution": "\ndef MotpB():\n    def main():\n        import sys\n        input = sys.stdin.readline\n    \n        import heapq\n        def dijkstra_heap(s,g,edge):\n            #始点sから各頂点への最短距離\n            d = [10**20] * (n+2)\n            used = [True] * (n+2) #True:未確定\n            d[s] = 0\n            used[s] = False\n            edgelist = []\n            sx,sy,sr=edge[s][0],edge[s][1],edge[s][2]\n            for i in range(n+2):\n                x,y,r=edge[i][0],edge[i][1],edge[i][2]\n                dist=((x-sx)**2+(y-sy)**2)**(1/2)\n                heapq.heappush(edgelist,(max(dist-r-sr,0),i))\n            while len(edgelist):\n                minedge = heapq.heappop(edgelist)\n                #まだ使われてない頂点の中から最小の距離のものを探す\n                v = minedge[1]\n                if not used[v]:\n                    continue\n                d[v] = minedge[0]\n                used[v] = False\n                bx,by,br=edge[v][0],edge[v][1],edge[v][2]\n                for i in range(n+2):\n                    x,y,r=edge[i][0],edge[i][1],edge[i][2]\n                    dist=((x-bx)**2+(y-by)**2)**(1/2)\n                    if used[i]:\n                        heapq.heappush(edgelist,(max(dist-r-br,0)+d[v],i))\n                if not used[g]:\n                    break\n            return d[g]\n    \n        sx,sy,gx,gy = map(int,input().split()) #n:頂点数　w:辺の数\n        n=int(input())\n        edge=[(sx,sy,0),(gx,gy,0)]\n        for i in range(2,n+2):\n            x,y,r=map(int,input().split())\n            edge.append((x,y,r))\n        print(dijkstra_heap(0,1,edge))\n    \n    def __starting_point():\n        main()\n    __starting_point()",
        "inputs": [
            "-2 -2 2 2\n1\n0 0 1\n",
            "-2 0 2 0\n2\n-1 0 2\n1 0 2\n",
            "4 -2 -2 4\n3\n0 0 2\n4 0 1\n0 4 1\n"
        ],
        "outputs": [
            "3.6568542494923806\n",
            "0\n",
            "4.0\n"
        ],
        "starter_code": "\ndef MotpB():\n",
        "scope": [
            [
                "Function Body",
                2,
                48
            ],
            [
                "Function Body",
                3,
                44
            ],
            [
                "Function Body",
                8,
                36
            ],
            [
                "For Loop Body",
                16,
                19
            ],
            [
                "While Loop Body",
                20,
                35
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "For Loop Body",
                29,
                33
            ],
            [
                "If Statement Body",
                32,
                33
            ],
            [
                "If Statement Body",
                34,
                35
            ],
            [
                "For Loop Body",
                41,
                43
            ],
            [
                "Function Body",
                46,
                47
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef nFNyU():\n    \"\"\"Polycarp is making a quest for his friends. He has already made n tasks, for each task the boy evaluated how interesting it is as an integer q_{i}, and the time t_{i} in minutes needed to complete the task. \n\nAn interesting feature of his quest is: each participant should get the task that is best suited for him, depending on his preferences. The task is chosen based on an interactive quiz that consists of some questions. The player should answer these questions with \"yes\" or \"no\". Depending on the answer to the question, the participant either moves to another question or goes to one of the tasks that are in the quest. In other words, the quest is a binary tree, its nodes contain questions and its leaves contain tasks. \n\nWe know that answering any of the questions that are asked before getting a task takes exactly one minute from the quest player. Polycarp knows that his friends are busy people and they can't participate in the quest for more than T minutes. Polycarp wants to choose some of the n tasks he made, invent the corresponding set of questions for them and use them to form an interactive quiz as a binary tree so that no matter how the player answers quiz questions, he spends at most T minutes on completing the whole quest (that is, answering all the questions and completing the task). Specifically, the quest can contain zero questions and go straight to the task. Each task can only be used once (i.e., the people who give different answers to questions should get different tasks).\n\nPolycarp wants the total \"interest\" value of the tasks involved in the quest to be as large as possible. Help him determine the maximum possible total interest value of the task considering that the quest should be completed in T minutes at any variant of answering questions.\n\n\n-----Input-----\n\nThe first line contains two integers n and T (1 ≤ n ≤ 1000, 1 ≤ T ≤ 100) — the number of tasks made by Polycarp and the maximum time a quest player should fit into.\n\nNext n lines contain two integers t_{i}, q_{i} (1 ≤ t_{i} ≤ T, 1 ≤ q_{i} ≤ 1000) each — the time in minutes needed to complete the i-th task and its interest value.\n\n\n-----Output-----\n\nPrint a single integer — the maximum possible total interest value of all the tasks in the quest.\n\n\n-----Examples-----\nInput\n5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n\nOutput\n11\n\nInput\n5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n\nOutput\n9\n\nInput\n2 2\n1 1\n2 10\n\nOutput\n10\n\n\n\n-----Note-----\n\nIn the first sample test all the five tasks can be complemented with four questions and joined into one quest.\n\nIn the second sample test it is impossible to use all the five tasks, but you can take two of them, the most interesting ones.\n\nIn the third sample test the optimal strategy is to include only the second task into the quest.\n\nHere is the picture that illustrates the answers to the sample tests. The blue circles represent the questions, the two arrows that go from every circle represent where a person goes depending on his answer to that question. The tasks are the red ovals. [Image]\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\ndef nFNyU():\n    def __starting_point():\n        n, T = [int(_) for _ in input().split()]\n        data = defaultdict(list)\n        for i in range(n):\n            t, q = [int(_) for _ in input().split()]\n            data[T - t].append(q)\n        prev_level = []\n        for level_id in range(1, T + 1):\n            level = sorted(data[T - level_id] + prev_level, reverse=True) \n            if T - level_id <= 10:\n                max_size = 2 ** (T - level_id)\n                level = level[:max_size]\n            if len(level) % 2 == 1:\n                level.append(0)\n            prev_level = [\n                level[i] + level[i + 1]\n                for i in range(0, len(level), 2)\n            ]\n        print(prev_level[0])\n    __starting_point()",
        "inputs": [
            "5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n",
            "5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n",
            "2 2\n1 1\n2 10\n"
        ],
        "outputs": [
            "11\n",
            "9\n",
            "10\n"
        ],
        "starter_code": "\ndef nFNyU():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "Function Body",
                3,
                21
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                10,
                20
            ],
            [
                "If Statement Body",
                12,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "List Comprehension",
                17,
                20
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef zltHT():\n    \"\"\"Let $a_1, \\ldots, a_n$ be an array of $n$ positive integers. In one operation, you can choose an index $i$ such that $a_i = i$, and remove $a_i$ from the array (after the removal, the remaining parts are concatenated).\n\nThe weight of $a$ is defined as the maximum number of elements you can remove.\n\nYou must answer $q$ independent queries $(x, y)$: after replacing the $x$ first elements of $a$ and the $y$ last elements of $a$ by $n+1$ (making them impossible to remove), what would be the weight of $a$?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 3 \\cdot 10^5$)  — the length of the array and the number of queries.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\leq a_i \\leq n$) — elements of the array.\n\nThe $i$-th of the next $q$ lines contains two integers $x$ and $y$ ($x, y \\ge 0$ and $x+y < n$).\n\n\n-----Output-----\n\nPrint $q$ lines, $i$-th line should contain a single integer  — the answer to the $i$-th query.\n\n\n-----Examples-----\nInput\n13 5\n2 2 3 9 5 4 6 5 7 8 3 11 13\n3 1\n0 0\n2 4\n5 0\n0 12\n\nOutput\n5\n11\n6\n1\n0\n\nInput\n5 2\n1 4 1 2 4\n0 0\n1 0\n\nOutput\n2\n0\n\n\n\n-----Note-----\n\nExplanation of the first query:\n\nAfter making first $x = 3$ and last $y = 1$ elements impossible to remove, $a$ becomes $[\\times, \\times, \\times, 9, 5, 4, 6, 5, 7, 8, 3, 11, \\times]$ (we represent $14$ as $\\times$ for clarity).\n\nHere is a strategy that removes $5$ elements (the element removed is colored in red):  $[\\times, \\times, \\times, 9, \\color{red}{5}, 4, 6, 5, 7, 8, 3, 11, \\times]$  $[\\times, \\times, \\times, 9, 4, 6, 5, 7, 8, 3, \\color{red}{11}, \\times]$  $[\\times, \\times, \\times, 9, 4, \\color{red}{6}, 5, 7, 8, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 7, \\color{red}{8}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, \\color{red}{7}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 3, \\times]$ (final state) \n\nIt is impossible to remove more than $5$ elements, hence the weight is $5$.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin\ndef zltHT():\n    def bitadd(a,w,bit):\n     \n        x = a\n        while x <= (len(bit)-1):\n            bit[x] += w\n            x += x & (-1 * x)\n     \n    def bitsum(a,bit):\n     \n        ret = 0\n        x = a\n        while x > 0:\n            ret += bit[x]\n            x -= x & (-1 * x)\n        return ret\n    class RangeBIT:\n        def __init__(self,N,indexed):\n            self.bit1 = [0] * (N+2)\n            self.bit2 = [0] * (N+2)\n            self.mode = indexed\n        def bitadd(self,a,w,bit):\n     \n            x = a\n            while x <= (len(bit)-1):\n                bit[x] += w\n                x += x & (-1 * x)\n     \n        def bitsum(self,a,bit):\n     \n            ret = 0\n            x = a\n            while x > 0:\n                ret += bit[x]\n                x -= x & (-1 * x)\n            return ret\n        \n        def add(self,l,r,w):\n            l = l + (1-self.mode)\n            r = r + (1-self.mode)\n            self.bitadd(l,-1*w*l,self.bit1)\n            self.bitadd(r,w*r,self.bit1)\n            self.bitadd(l,w,self.bit2)\n            self.bitadd(r,-1*w,self.bit2)\n        def sum(self,l,r):\n            l = l + (1-self.mode)\n            r = r + (1-self.mode)\n            ret =  self.bitsum(r,self.bit1) + r * self.bitsum(r,self.bit2)\n            ret -= self.bitsum(l,self.bit1) + l * self.bitsum(l,self.bit2)\n            return ret\n    n,q = list(map(int,stdin.readline().split()))\n    a = list(map(int,stdin.readline().split()))\n    qs = [ [] for i in range(n+1) ]\n    ans = [None] * q\n    for loop in range(q):\n        x,y = list(map(int,stdin.readline().split()))\n        l = x+1\n        r = n-y\n        qs[r].append((l,loop))\n    BIT = [0] * (n+1)\n    for r in range(1,n+1):\n        b = r-a[r-1]\n        if b >= 0:\n            L = 1\n            R = r+1\n            while R-L != 1:\n                M = (L+R)//2\n                if bitsum(M,BIT) >= b:\n                    L = M\n                else:\n                    R = M\n            if bitsum(L,BIT) >= b:\n                bitadd(1,1,BIT)\n                bitadd(L+1,-1,BIT)\n        for ql,qind in qs[r]:\n            ans[qind] = bitsum(ql,BIT)\n    for i in ans:\n        print (i)",
        "inputs": [
            "13 5\n2 2 3 9 5 4 6 5 7 8 3 11 13\n3 1\n0 0\n2 4\n5 0\n0 12\n",
            "5 2\n1 4 1 2 4\n0 0\n1 0\n",
            "1 1\n1\n0 0\n"
        ],
        "outputs": [
            "5\n11\n6\n1\n0\n",
            "2\n0\n",
            "1\n"
        ],
        "starter_code": "\ndef zltHT():\n",
        "scope": [
            [
                "Function Body",
                2,
                79
            ],
            [
                "Function Body",
                3,
                8
            ],
            [
                "While Loop Body",
                6,
                8
            ],
            [
                "Function Body",
                10,
                17
            ],
            [
                "While Loop Body",
                14,
                16
            ],
            [
                "Class Body",
                18,
                51
            ],
            [
                "Function Body",
                19,
                22
            ],
            [
                "Function Body",
                23,
                28
            ],
            [
                "While Loop Body",
                26,
                28
            ],
            [
                "Function Body",
                30,
                37
            ],
            [
                "While Loop Body",
                34,
                36
            ],
            [
                "Function Body",
                39,
                45
            ],
            [
                "Function Body",
                46,
                51
            ],
            [
                "List Comprehension",
                54,
                54
            ],
            [
                "For Loop Body",
                56,
                60
            ],
            [
                "For Loop Body",
                62,
                77
            ],
            [
                "If Statement Body",
                64,
                75
            ],
            [
                "While Loop Body",
                67,
                72
            ],
            [
                "If Statement Body",
                69,
                72
            ],
            [
                "If Statement Body",
                73,
                75
            ],
            [
                "For Loop Body",
                76,
                77
            ],
            [
                "For Loop Body",
                78,
                79
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef gxozS():\n    \"\"\"There are $n$ cities in Berland and some pairs of them are connected by two-way roads. It is guaranteed that you can pass from any city to any other, moving along the roads. Cities are numerated from $1$ to $n$.\n\nTwo fairs are currently taking place in Berland — they are held in two different cities $a$ and $b$ ($1 \\le a, b \\le n$; $a \\ne b$).\n\nFind the number of pairs of cities $x$ and $y$ ($x \\ne a, x \\ne b, y \\ne a, y \\ne b$) such that if you go from $x$ to $y$ you will have to go through both fairs (the order of visits doesn't matter). Formally, you need to find the number of pairs of cities $x,y$ such that any path from $x$ to $y$ goes through $a$ and $b$ (in any order).\n\nPrint the required number of pairs. The order of two cities in a pair does not matter, that is, the pairs $(x,y)$ and $(y,x)$ must be taken into account only once.\n\n\n-----Input-----\n\nThe first line of the input contains an integer $t$ ($1 \\le t \\le 4\\cdot10^4$) — the number of test cases in the input. Next, $t$ test cases are specified.\n\nThe first line of each test case contains four integers $n$, $m$, $a$ and $b$ ($4 \\le n \\le 2\\cdot10^5$, $n - 1 \\le m \\le 5\\cdot10^5$, $1 \\le a,b \\le n$, $a \\ne b$) — numbers of cities and roads in Berland and numbers of two cities where fairs are held, respectively.\n\nThe following $m$ lines contain descriptions of roads between cities. Each of road description contains a pair of integers $u_i, v_i$ ($1 \\le u_i, v_i \\le n$, $u_i \\ne v_i$) — numbers of cities connected by the road.\n\nEach road is bi-directional and connects two different cities. It is guaranteed that from any city you can pass to any other by roads. There can be more than one road between a pair of cities.\n\nThe sum of the values of $n$ for all sets of input data in the test does not exceed $2\\cdot10^5$. The sum of the values of $m$ for all sets of input data in the test does not exceed $5\\cdot10^5$.\n\n\n-----Output-----\n\nPrint $t$ integers — the answers to the given test cases in the order they are written in the input.\n\n\n-----Example-----\nInput\n3\n7 7 3 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 5\n4 5 2 3\n1 2\n2 3\n3 4\n4 1\n4 2\n4 3 2 1\n1 2\n2 3\n4 1\n\nOutput\n4\n0\n1\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom collections import deque\ndef gxozS():\n    input = sys.stdin.readline\n    t=int(input())\n    for testcaess in range(t):\n        n,m,a,b=list(map(int,input().split()))\n        E=[[] for i in range(n+1)]\n        for i in range(m):\n            x,y=list(map(int,input().split()))\n            E[x].append(y)\n            E[y].append(x)\n        USE1=[0]*(n+1)\n        Q=deque()\n        Q.append(a)\n        USE1[a]=1\n        while Q:\n            x=Q.pop()\n            for to in E[x]:\n                if to==b:\n                    continue\n                if USE1[to]==0:\n                    USE1[to]=1\n                    Q.append(to)\n        USE2=[0]*(n+1)\n        Q=deque()\n        Q.append(b)\n        USE2[b]=1\n        while Q:\n            x=Q.pop()\n            for to in E[x]:\n                if to==a:\n                    continue\n                if USE2[to]==0:\n                    USE2[to]=1\n                    Q.append(to)\n        #print(USE1,USE2)\n        ANS1=0\n        ANS2=0\n        for i in range(n+1):\n            if i==a or i==b:\n                continue\n            if USE1[i]==1 and USE2[i]==0:\n                ANS1+=1\n            elif USE1[i]==0 and USE2[i]==1:\n                ANS2+=1\n        print(ANS1*ANS2)\n            \n        \n        ",
        "inputs": [
            "3\n7 7 3 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 5\n4 5 2 3\n1 2\n2 3\n3 4\n4 1\n4 2\n4 3 2 1\n1 2\n2 3\n4 1\n"
        ],
        "outputs": [
            "4\n0\n1\n"
        ],
        "starter_code": "\ndef gxozS():\n",
        "scope": [
            [
                "Function Body",
                3,
                47
            ],
            [
                "For Loop Body",
                6,
                47
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "While Loop Body",
                17,
                24
            ],
            [
                "For Loop Body",
                19,
                24
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "If Statement Body",
                22,
                24
            ],
            [
                "While Loop Body",
                29,
                36
            ],
            [
                "For Loop Body",
                31,
                36
            ],
            [
                "If Statement Body",
                32,
                33
            ],
            [
                "If Statement Body",
                34,
                36
            ],
            [
                "For Loop Body",
                40,
                46
            ],
            [
                "If Statement Body",
                41,
                42
            ],
            [
                "If Statement Body",
                43,
                46
            ],
            [
                "If Statement Body",
                45,
                46
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef ZMfXq():\n    \"\"\"Genos recently installed the game Zuma on his phone. In Zuma there exists a line of n gemstones, the i-th of which has color c_{i}. The goal of the game is to destroy all the gemstones in the line as quickly as possible.\n\nIn one second, Genos is able to choose exactly one continuous substring of colored gemstones that is a palindrome and remove it from the line. After the substring is removed, the remaining gemstones shift to form a solid line again. What is the minimum number of seconds needed to destroy the entire line?\n\nLet us remind, that the string (or substring) is called palindrome, if it reads same backwards or forward. In our case this means the color of the first gemstone is equal to the color of the last one, the color of the second gemstone is equal to the color of the next to last and so on.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 ≤ n ≤ 500) — the number of gemstones.\n\nThe second line contains n space-separated integers, the i-th of which is c_{i} (1 ≤ c_{i} ≤ n) — the color of the i-th gemstone in a line.\n\n\n-----Output-----\n\nPrint a single integer — the minimum number of seconds needed to destroy the entire line.\n\n\n-----Examples-----\nInput\n3\n1 2 1\n\nOutput\n1\n\nInput\n3\n1 2 3\n\nOutput\n3\n\nInput\n7\n1 4 4 2 3 2 1\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Genos can destroy the entire line in one second.\n\nIn the second sample, Genos can only destroy one gemstone at a time, so destroying three gemstones takes three seconds.\n\nIn the third sample, to achieve the optimal time of two seconds, destroy palindrome 4 4 first and then destroy palindrome 1 2 3 2 1.\n    \"\"\"\n",
        "canonical_solution": "\ndef ZMfXq():\n    n = int(input())\n    C = list(map(int, input().split()))\n    \n    dp = [[0]*n for _ in range(n)]\n    for i in range(n) :\n        dp[i][i] = 1\n    \n    for i in range(n-2, -1, -1) :\n        for j in range(i+1, n) :\n            dp[i][j] = 1 + dp[i+1][j]\n            if C[i] == C[i+1] : dp[i][j] = min( dp[i][j], 1 + (dp[i+2][j] if i+2 < n else 0) )\n            for k in range(i+2, j) :\n                if C[i] == C[k] : dp[i][j] = min( dp[i][j], dp[i+1][k-1] + dp[k+1][j] )\n            if C[i] == C[j] and j-i > 1:\n                dp[i][j] = min( dp[i][j], dp[i+1][j-1] )\n    \n    print( dp[0][n-1] )\n    \n                \n            \n    ",
        "inputs": [
            "3\n1 2 1\n",
            "3\n1 2 3\n",
            "7\n1 4 4 2 3 2 1\n"
        ],
        "outputs": [
            "1\n",
            "3\n",
            "2\n"
        ],
        "starter_code": "\ndef ZMfXq():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                10,
                17
            ],
            [
                "For Loop Body",
                11,
                17
            ],
            [
                "If Statement Body",
                13,
                13
            ],
            [
                "For Loop Body",
                14,
                15
            ],
            [
                "If Statement Body",
                15,
                15
            ],
            [
                "If Statement Body",
                16,
                17
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef BtomI():\n    \"\"\"Snark and Philip are preparing the problemset for the upcoming pre-qualification round for semi-quarter-finals. They have a bank of n problems, and they want to select any non-empty subset of it as a problemset.\n\nk experienced teams are participating in the contest. Some of these teams already know some of the problems. To make the contest interesting for them, each of the teams should know at most half of the selected problems.\n\nDetermine if Snark and Philip can make an interesting problemset!\n\n\n-----Input-----\n\nThe first line contains two integers n, k (1 ≤ n ≤ 10^5, 1 ≤ k ≤ 4) — the number of problems and the number of experienced teams.\n\nEach of the next n lines contains k integers, each equal to 0 or 1. The j-th number in the i-th line is 1 if j-th team knows i-th problem and 0 otherwise.\n\n\n-----Output-----\n\nPrint \"YES\" (quotes for clarity), if it is possible to make an interesting problemset, and \"NO\" otherwise.\n\nYou can print each character either upper- or lowercase (\"YeS\" and \"yes\" are valid when the answer is \"YES\").\n\n\n-----Examples-----\nInput\n5 3\n1 0 1\n1 1 0\n1 0 0\n1 0 0\n1 0 0\n\nOutput\nNO\n\nInput\n3 2\n1 0\n1 1\n0 1\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example you can't make any interesting problemset, because the first team knows all problems.\n\nIn the second example you can choose the first and the third problems.\n    \"\"\"\n",
        "canonical_solution": "\ndef BtomI():\n    def bel(mask, bit):\n        return (mask & (1 << bit)) != 0\n    read = lambda: map(int, input().split())\n    n, k = read()\n    f = [0] * 100\n    for i in range(n):\n        cur = int(''.join(input().split()), 2)\n        cur ^= (1 << k) - 1\n        f[cur] = 1\n    ans = 'NO'\n    if k == 1:\n        if f[1]:\n            ans = 'YES'\n    if k == 2:\n        f1 = f2 = 0\n        for i in range(4):\n            if f[i]:\n                if bel(i, 0): f1 = 1\n                if bel(i, 1): f2 = 1\n        if f1 and f2:\n            ans = 'YES'\n    if k == 3:\n        p = [0] * 3\n        for i in range(8):\n            if f[i]:\n                for j in range(3):\n                    if bel(i, j): p[j] = 1\n        for i in range(8):\n            if f[i]:\n                if bel(i, 0) and bel(i, 1) and p[2]: ans = 'YES'\n                if bel(i, 0) and p[1] and bel(i, 2): ans = 'YES'\n                if p[0] and bel(i, 1) and bel(i, 2): ans = 'YES'\n    if k == 4:\n        for i in range(16):\n            if f[i]:\n                for j in range(16):\n                    if f[j]:\n                        if (i | j) == 15:\n                            ans = 'YES'\n    print(ans)",
        "inputs": [
            "5 3\n1 0 1\n1 1 0\n1 0 0\n1 0 0\n1 0 0\n",
            "3 2\n1 0\n1 1\n0 1\n",
            "10 2\n1 0\n1 0\n0 0\n1 1\n0 0\n1 1\n0 0\n1 1\n0 1\n0 1\n"
        ],
        "outputs": [
            "NO\n",
            "YES\n",
            "YES\n"
        ],
        "starter_code": "\ndef BtomI():\n",
        "scope": [
            [
                "Function Body",
                2,
                42
            ],
            [
                "Function Body",
                3,
                4
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "For Loop Body",
                8,
                11
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "If Statement Body",
                16,
                23
            ],
            [
                "For Loop Body",
                18,
                21
            ],
            [
                "If Statement Body",
                19,
                21
            ],
            [
                "If Statement Body",
                20,
                20
            ],
            [
                "If Statement Body",
                21,
                21
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "If Statement Body",
                24,
                34
            ],
            [
                "For Loop Body",
                26,
                29
            ],
            [
                "If Statement Body",
                27,
                29
            ],
            [
                "For Loop Body",
                28,
                29
            ],
            [
                "If Statement Body",
                29,
                29
            ],
            [
                "For Loop Body",
                30,
                34
            ],
            [
                "If Statement Body",
                31,
                34
            ],
            [
                "If Statement Body",
                32,
                32
            ],
            [
                "If Statement Body",
                33,
                33
            ],
            [
                "If Statement Body",
                34,
                34
            ],
            [
                "If Statement Body",
                35,
                41
            ],
            [
                "For Loop Body",
                36,
                41
            ],
            [
                "If Statement Body",
                37,
                41
            ],
            [
                "For Loop Body",
                38,
                41
            ],
            [
                "If Statement Body",
                39,
                41
            ],
            [
                "If Statement Body",
                40,
                41
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef Sopfi():\n    \"\"\"Recently, a start up by two students of a state university of city F gained incredible popularity. Now it's time to start a new company. But what do we call it?\n\nThe market analysts came up with a very smart plan: the name of the company should be identical to its reflection in a mirror! In other words, if we write out the name of the company on a piece of paper in a line (horizontally, from left to right) with large English letters, then put this piece of paper in front of the mirror, then the reflection of the name in the mirror should perfectly match the line written on the piece of paper.\n\nThere are many suggestions for the company name, so coming up to the mirror with a piece of paper for each name wouldn't be sensible. The founders of the company decided to automatize this process. They asked you to write a program that can, given a word, determine whether the word is a 'mirror' word or not.\n\n\n-----Input-----\n\nThe first line contains a non-empty name that needs to be checked. The name contains at most 10^5 large English letters. The name will be written with the next sans serif font: $\\text{ABCDEFGHI JKLMNOPQRSTUVWXYZ}$\n\n\n-----Output-----\n\nPrint 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).\n\n\n-----Examples-----\nInput\nAHA\n\nOutput\nYES\n\nInput\nZ\n\nOutput\nNO\n\nInput\nXO\n\nOutput\nNO\n    \"\"\"\n",
        "canonical_solution": "\ndef Sopfi():\n    s=input()\n    M={\"A\",\"H\",\"I\",\"M\",\"O\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\"}\n    ans=\"YES\"\n    n=len(s)\n    for i in range(len(s)//2):\n        x=s[i]\n        y=s[n-i-1]\n        if(x!=y or x not in M):\n            ans=\"NO\"\n            break\n    if(n%2==1):\n        if(s[n//2] not in M):\n            ans=\"NO\"\n    print(ans)\n        \n    ",
        "inputs": [
            "AHA\n",
            "Z\n",
            "XO\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef Sopfi():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                7,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "If Statement Body",
                14,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef dXhQN():\n    \"\"\"Haiku is a short form of Japanese poetry. A Haiku consists of three phrases with 5, 7 and 5 syllables, in this order.\nIroha is looking for X,Y,Z-Haiku (defined below) in integer sequences.\nConsider all integer sequences of length N whose elements are between 1 and 10, inclusive. Out of those 10^N sequences, how many contain an X,Y,Z-Haiku?\nHere, an integer sequence a_0, a_1, ..., a_{N-1} is said to contain an X,Y,Z-Haiku if and only if there exist four indices x, y, z, w (0 ≦ x < y < z < w ≦ N) such that all of the following are satisfied:\n - a_x + a_{x+1} + ... + a_{y-1} = X\n - a_y + a_{y+1} + ... + a_{z-1} = Y\n - a_z + a_{z+1} + ... + a_{w-1} = Z\nSince the answer can be extremely large, print the number modulo 10^9+7.\n\n-----Constraints-----\n - 3 ≦ N ≦ 40\n - 1 ≦ X ≦ 5\n - 1 ≦ Y ≦ 7\n - 1 ≦ Z ≦ 5\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN X Y Z\n\n-----Output-----\nPrint the number of the sequences that contain an X,Y,Z-Haiku, modulo 10^9+7.\n\n-----Sample Input-----\n3 5 7 5\n\n-----Sample Output-----\n1\n\nHere, the only sequence that contains a 5,7,5-Haiku is [5, 7, 5].\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef dXhQN():\n    # coding: utf-8\n    # Your code here!\n    read = sys.stdin.read\n    readline = sys.stdin.readline\n    n,X,Y,Z = list(map(int,read().split()))\n    N = 1<<(X+Y+Z)\n    NX = 1<<X\n    NY = 1<<(X+Y)\n    NZ = 1<<(X+Y+Z)\n    MX = (1<<X) - 1\n    MY = (1<<(Y+X)) - (1<<X)\n    MZ = (1<<(X+Y+Z)) - (1<<(Y+X))\n    MMX = MX<<1\n    MMY = MY<<1\n    MMZ = MZ<<1\n    dp = [0]*N\n    dp[1] = 1\n    MOD = 10**9+7\n    for _ in range(n):\n        ndp = [0]*N\n        #cnt = 0\n        #bad = 0\n        for mask in range(N):\n            if dp[mask]==0: continue\n            mx = mask&MX\n            my = mask&MY\n            mz = mask&MZ\n            \n            for j in range(1,11):\n                nmx = mx << j\n                nmx &= MMX\n                nmy = my << j\n                nmy &= MMY\n                nmz = mz << j\n                nmz &= MMZ\n                nmask = nmx|nmy|nmz|1\n                if not nmask&(1<<(X+Y+Z)):\n                    ndp[nmask] += dp[mask]\n                    ndp[nmask] %= MOD\n        dp = ndp\n        #print(sum(dp),\"sum\")\n    ans = (pow(10,n,MOD)-sum(dp))\n    print((ans%MOD))",
        "inputs": [
            "3 5 7 5\n",
            "4 5 7 5\n",
            "37 4 2 3\n"
        ],
        "outputs": [
            "1\n",
            "34\n",
            "863912418\n"
        ],
        "starter_code": "\ndef dXhQN():\n",
        "scope": [
            [
                "Function Body",
                2,
                45
            ],
            [
                "For Loop Body",
                21,
                42
            ],
            [
                "For Loop Body",
                25,
                41
            ],
            [
                "If Statement Body",
                26,
                26
            ],
            [
                "For Loop Body",
                31,
                41
            ],
            [
                "If Statement Body",
                39,
                41
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef VGnNj():\n    \"\"\"You are given a permutation $p_1, p_2, \\ldots, p_n$.\n\nIn one move you can swap two adjacent values.\n\nYou want to perform a minimum number of moves, such that in the end there will exist a subsegment $1,2,\\ldots, k$, in other words in the end there should be an integer $i$, $1 \\leq i \\leq n-k+1$ such that $p_i = 1, p_{i+1} = 2, \\ldots, p_{i+k-1}=k$.\n\nLet $f(k)$ be the minimum number of moves that you need to make a subsegment with values $1,2,\\ldots,k$ appear in the permutation.\n\nYou need to find $f(1), f(2), \\ldots, f(n)$.\n\n\n-----Input-----\n\nThe first line of input contains one integer $n$ ($1 \\leq n \\leq 200\\,000$): the number of elements in the permutation.\n\nThe next line of input contains $n$ integers $p_1, p_2, \\ldots, p_n$: given permutation ($1 \\leq p_i \\leq n$).\n\n\n-----Output-----\n\nPrint $n$ integers, the minimum number of moves that you need to make a subsegment with values $1,2,\\ldots,k$ appear in the permutation, for $k=1, 2, \\ldots, n$.\n\n\n-----Examples-----\nInput\n5\n5 4 3 2 1\n\nOutput\n0 1 3 6 10 \n\nInput\n3\n1 2 3\n\nOutput\n0 0 0\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef VGnNj():\n    reader = (s.rstrip() for s in sys.stdin)\n    input = reader.__next__\n    class Binary_Indexed_Tree():\n        def __init__(self, n):\n            self.n = n\n            self.data = [0]*(n+1)\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n        def get(self, i):\n            return self.sum_range(i, i)\n        def sum(self, i):\n            ret = 0\n            while i:\n                ret += self.data[i]\n                i &= i-1\n            return ret\n        def sum_range(self, l, r):\n            return self.sum(r)-self.sum(l-1)\n        def lower_bound(self, w):\n            if w<=0:\n                return 0\n            i = 0\n            k = 1<<(self.n.bit_length())\n            while k:\n                if i+k <= self.n and self.data[i+k] < w:\n                    w -= self.data[i+k]\n                    i += k\n                k >>= 1\n            return i+1\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = {j:i for i,j in enumerate(a)}\n    BIT1 = Binary_Indexed_Tree(n)\n    BIT2 = Binary_Indexed_Tree(n)\n    BIT3 = Binary_Indexed_Tree(n)\n    tentou = 0\n    ans = []\n    for i in range(n):\n        tmp = 0\n        p = d[i+1]\n        inv_p = n-p\n        tentou += BIT1.sum(inv_p)\n        BIT1.add(inv_p, 1)\n        BIT2.add(p+1, 1)\n        BIT3.add(p+1, p+1)\n        m = i//2+1\n        mean = BIT2.lower_bound(i//2+1)\n        tmp = 0\n        if i%2 == 0:\n            tmp -= m*(m-1)\n        else:\n            tmp -= m*m\n        tmp += tentou\n        left = BIT3.sum_range(1, mean)\n        right = BIT3.sum_range(mean, n)\n        if i%2 == 0:\n            left = mean*m - left\n            right = right - mean*m\n        else:\n            left = mean*m - left\n            right = right - mean*(m+1)\n        tmp += left + right\n        ans.append(tmp)\n    print(*ans)",
        "inputs": [
            "5\n5 4 3 2 1\n",
            "3\n1 2 3\n",
            "1\n1\n"
        ],
        "outputs": [
            "0 1 3 6 10 \n",
            "0 0 0 \n",
            "0 \n"
        ],
        "starter_code": "\ndef VGnNj():\n",
        "scope": [
            [
                "Function Body",
                2,
                68
            ],
            [
                "Generator Expression",
                3,
                3
            ],
            [
                "Class Body",
                5,
                33
            ],
            [
                "Function Body",
                6,
                8
            ],
            [
                "Function Body",
                9,
                12
            ],
            [
                "While Loop Body",
                10,
                12
            ],
            [
                "Function Body",
                13,
                14
            ],
            [
                "Function Body",
                15,
                20
            ],
            [
                "While Loop Body",
                17,
                19
            ],
            [
                "Function Body",
                21,
                22
            ],
            [
                "Function Body",
                23,
                33
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "While Loop Body",
                28,
                32
            ],
            [
                "If Statement Body",
                29,
                31
            ],
            [
                "Dict Comprehension",
                36,
                36
            ],
            [
                "For Loop Body",
                42,
                67
            ],
            [
                "If Statement Body",
                53,
                56
            ],
            [
                "If Statement Body",
                60,
                65
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef RPAkU():\n    \"\"\"A robot is put at the origin in a two-dimensional plane.\nInitially, the robot is facing in the positive x-axis direction.\nThis robot will be given an instruction sequence s.\ns consists of the following two kinds of letters, and will be executed in order from front to back.\n - F : Move in the current direction by distance 1.\n - T : Turn 90 degrees, either clockwise or counterclockwise.\nThe objective of the robot is to be at coordinates (x, y) after all the instructions are executed.\nDetermine whether this objective is achievable.\n\n-----Constraints-----\n - s consists of F and T.\n - 1 \\leq |s| \\leq 8 000\n - x and y are integers.\n - |x|, |y| \\leq |s|\n\n-----Input-----\nInput is given from Standard Input in the following format:\ns\nx y\n\n-----Output-----\nIf the objective is achievable, print Yes; if it is not, print No.\n\n-----Sample Input-----\nFTFFTFFF\n4 2\n\n-----Sample Output-----\nYes\n\nThe objective can be achieved by, for example, turning counterclockwise in the first T and turning clockwise in the second T.\n    \"\"\"\n",
        "canonical_solution": "from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import *\ndef RPAkU():\n    def read():\n      return int(input())\n     \n    def reads():\n      return [int(x) for x in input().split()]\n    S = input()\n    x, y = reads()\n    qs = [len(s) for s in S.split('T')]\n    def knapsack(xs, target):\n      es = {0}\n      for x in xs:\n        es = {e - x for e in es} | {e + x for e in es}\n      return target in es\n    ans = knapsack(qs[2::2], x-qs[0]) and knapsack(qs[1::2], y)\n    print(\"Yes\" if ans else \"No\")",
        "inputs": [
            "FTFFTFFF\n4 2\n",
            "FTFFTFFF\n-2 -2\n",
            "FF\n1 0\n"
        ],
        "outputs": [
            "Yes\n",
            "Yes\n",
            "No\n"
        ],
        "starter_code": "\ndef RPAkU():\n",
        "scope": [
            [
                "Function Body",
                6,
                21
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Function Body",
                10,
                11
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "List Comprehension",
                14,
                14
            ],
            [
                "Function Body",
                15,
                19
            ],
            [
                "For Loop Body",
                17,
                18
            ],
            [
                "Set Comprehension",
                18,
                18
            ],
            [
                "Set Comprehension",
                18,
                18
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef xBWvN():\n    \"\"\"There are n types of coins in Byteland. Conveniently, the denomination of the coin type k divides the denomination of the coin type k + 1, the denomination of the coin type 1 equals 1 tugrick. The ratio of the denominations of coin types k + 1 and k equals a_{k}. It is known that for each x there are at most 20 coin types of denomination x.\n\nByteasar has b_{k} coins of type k with him, and he needs to pay exactly m tugricks. It is known that Byteasar never has more than 3·10^5 coins with him. Byteasar want to know how many ways there are to pay exactly m tugricks. Two ways are different if there is an integer k such that the amount of coins of type k differs in these two ways. As all Byteland citizens, Byteasar wants to know the number of ways modulo 10^9 + 7.\n\n\n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 3·10^5) — the number of coin types.\n\nThe second line contains n - 1 integers a_1, a_2, ..., a_{n} - 1 (1 ≤ a_{k} ≤ 10^9) — the ratios between the coin types denominations. It is guaranteed that for each x there are at most 20 coin types of denomination x.\n\nThe third line contains n non-negative integers b_1, b_2, ..., b_{n} — the number of coins of each type Byteasar has. It is guaranteed that the sum of these integers doesn't exceed 3·10^5.\n\nThe fourth line contains single integer m (0 ≤ m < 10^10000) — the amount in tugricks Byteasar needs to pay.\n\n\n-----Output-----\n\nPrint single integer — the number of ways to pay exactly m tugricks modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n1\n\n4\n2\n\nOutput\n1\n\nInput\n2\n1\n4 4\n2\n\nOutput\n3\n\nInput\n3\n3 3\n10 10 10\n17\n\nOutput\n6\n\n\n\n-----Note-----\n\nIn the first example Byteasar has 4 coins of denomination 1, and he has to pay 2 tugricks. There is only one way.\n\nIn the second example Byteasar has 4 coins of each of two different types of denomination 1, he has to pay 2 tugricks. There are 3 ways: pay one coin of the first type and one coin of the other, pay two coins of the first type, and pay two coins of the second type.\n\nIn the third example the denominations are equal to 1, 3, 9.\n    \"\"\"\n",
        "canonical_solution": "\ndef xBWvN():\n    p = 1000000007\n    \n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    m = int(input())\n    \n    d = [1] * 300001\n    td = [0] * 300001\n    L = b[0]\n    for i in range(1, n):\n    \tif a[i - 1] != 1:\n    \t\tt = m % a[i - 1]\n    \t\tif L < t:\n    \t\t\tprint(0)\n    \t\t\treturn\n    \t\tm //= a[i - 1]\n    \t\tfor j in range((L - t) // a[i - 1] + 1):\n    \t\t\td[j] = d[t]\n    \t\t\tt += a[i - 1]\n    \t\tL = j\n    \tk = 0\n    \tfor j in range(L + b[i] + 1):\n    \t\tif j <= L:\n    \t\t\tk += d[j]\n    \t\tk %= p\n    \t\ttd[j] = k\n    \t\tif j >= b[i]:\n    \t\t\tk -= d[j - b[i]]\n    \tL += b[i]\n    \tfor j in range(L + 1):\n    \t\td[j] = td[j]\n    print(d[m] if m <= L else 0)",
        "inputs": [
            "1\n\n4\n2\n",
            "2\n1\n4 4\n2\n",
            "3\n3 3\n10 10 10\n17\n"
        ],
        "outputs": [
            "1\n",
            "3\n",
            "6\n"
        ],
        "starter_code": "\ndef xBWvN():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "For Loop Body",
                13,
                34
            ],
            [
                "If Statement Body",
                14,
                23
            ],
            [
                "If Statement Body",
                16,
                18
            ],
            [
                "For Loop Body",
                20,
                22
            ],
            [
                "For Loop Body",
                25,
                31
            ],
            [
                "If Statement Body",
                26,
                27
            ],
            [
                "If Statement Body",
                30,
                31
            ],
            [
                "For Loop Body",
                33,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef MDfer():\n    \"\"\"Paul hates palindromes. He assumes that string s is tolerable if each its character is one of the first p letters of the English alphabet and s doesn't contain any palindrome contiguous substring of length 2 or more.\n\nPaul has found a tolerable string s of length n. Help him find the lexicographically next tolerable string of the same length or else state that such string does not exist.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers: n and p (1 ≤ n ≤ 1000; 1 ≤ p ≤ 26). The second line contains string s, consisting of n small English letters. It is guaranteed that the string is tolerable (according to the above definition).\n\n\n-----Output-----\n\nIf the lexicographically next tolerable string of the same length exists, print it. Otherwise, print \"NO\" (without the quotes).\n\n\n-----Examples-----\nInput\n3 3\ncba\n\nOutput\nNO\n\nInput\n3 4\ncba\n\nOutput\ncbd\n\nInput\n4 4\nabcd\n\nOutput\nabda\n\n\n\n-----Note-----\n\nString s is lexicographically larger (or simply larger) than string t with the same length, if there is number i, such that s_1 = t_1, ..., s_{i} = t_{i}, s_{i} + 1 > t_{i} + 1.\n\nThe lexicographically next tolerable string is the lexicographically minimum tolerable string which is larger than the given one.\n\nA palindrome is a string that reads the same forward or reversed.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef MDfer():\n    3\n    def solve(s, k):\n        l = len(s)\n        for i in range(l-1, -1, -1):\n            prev = s[max(i-2, 0):i]\n            z = s[i] + 1\n            while z in prev:\n                z += 1\n            if z >= k:\n                continue\n            # Gotcha!\n            ret = s[:i] + [z]\n            while len(ret) < l:\n                prev = ret[max(len(ret)-2, 0):len(ret)]\n                z = 0\n                while z in prev:\n                    z += 1\n                ret.append(z)\n            return ret\n        return None\n    def __starting_point():\n        l, k = list(map(int, sys.stdin.readline().split()))\n        s = [ord(c) - ord('a') for c in sys.stdin.readline().strip()]\n        ans = solve(s, k)\n        if ans is None:\n            print('NO')\n        else:\n            print(''.join(chr(ord('a') + x) for x in ans))\n    __starting_point()",
        "inputs": [
            "3 3\ncba\n",
            "3 4\ncba\n",
            "4 4\nabcd\n"
        ],
        "outputs": [
            "NO\n",
            "cbd\n",
            "abda\n"
        ],
        "starter_code": "\ndef MDfer():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                4,
                22
            ],
            [
                "For Loop Body",
                6,
                21
            ],
            [
                "While Loop Body",
                9,
                10
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "While Loop Body",
                15,
                20
            ],
            [
                "While Loop Body",
                18,
                19
            ],
            [
                "Function Body",
                23,
                30
            ],
            [
                "List Comprehension",
                25,
                25
            ],
            [
                "If Statement Body",
                27,
                30
            ],
            [
                "Generator Expression",
                30,
                30
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef yAcHN():\n    \"\"\"Recently Vasya learned that, given two points with different $x$ coordinates, you can draw through them exactly one parabola with equation of type $y = x^2 + bx + c$, where $b$ and $c$ are reals. Let's call such a parabola an $U$-shaped one.\n\nVasya drew several distinct points with integer coordinates on a plane and then drew an $U$-shaped parabola through each pair of the points that have different $x$ coordinates. The picture became somewhat messy, but Vasya still wants to count how many of the parabolas drawn don't have any drawn point inside their internal area. Help Vasya.\n\nThe internal area of an $U$-shaped parabola is the part of the plane that lies strictly above the parabola when the $y$ axis is directed upwards.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100\\,000$) — the number of points.\n\nThe next $n$ lines describe the points, the $i$-th of them contains two integers $x_i$ and $y_i$ — the coordinates of the $i$-th point. It is guaranteed that all points are distinct and that the coordinates do not exceed $10^6$ by absolute value.\n\n\n-----Output-----\n\nIn the only line print a single integer — the number of $U$-shaped parabolas that pass through at least two of the given points and do not contain any of the given points inside their internal area (excluding the parabola itself).\n\n\n-----Examples-----\nInput\n3\n-1 0\n0 2\n1 0\n\nOutput\n2\n\nInput\n5\n1 0\n1 -1\n0 -1\n-1 0\n-1 -1\n\nOutput\n1\n\n\n\n-----Note-----\n\nOn the pictures below all $U$-shaped parabolas that pass through at least two given points are drawn for each of the examples. The $U$-shaped parabolas that do not have any given point inside their internal area are drawn in red.  [Image] The first example. \n\n [Image] The second example.\n    \"\"\"\n",
        "canonical_solution": "\ndef yAcHN():\n    n = int(input())\n    rows = [input().split() for _ in range(n)]\n    rows = [(int(x),int(y)) for x,y in rows]\n    points = {}\n    for x,y in rows:\n        if x in points:\n            points[x] = max(y, points[x])\n        else:\n            points[x] = y\n    points = sorted(points.items(),key=lambda point: point[0])\n    \n    \n    def above(p,p1,p2):\n        \"\"\"\n        x1 < x2\n        y1 = x1^2 + bx1 + c\n        y2 = x2^2 + bx2 + c\n        y >? x^2 + bx + c\n    \n        y2 - y1 = x2^2 - x1^2 + bx2 - bx1\n        b = (y2 - y1 - x2^2 + x1^2) / (x2 - x1)\n        b * (x2 - x1) = y2 - y1 - x2^2 + x1^2\n    \n        c = y1 - x1^2 - bx1\n        c * (x2 - x1) = (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\n    \n        y * (x2 - x1) >? (x^2 + bx + c) * (x2 - x1)\n        y * (x2 - x1) >?\n            x^2 * (x2 - x1)\n            + x * (y2 - y1 - x2^2 + x1^2)\n            + (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\n        \"\"\"\n        x,y = p\n        x1,y1 = p1\n        x2,y2 = p2\n    \n        x_2 = x**2\n        x12 = x1**2\n        x22 = x2**2\n        x2_x1 = x2 - x1\n        eq_b = y2 - y1 - x22 + x12\n    \n        term_y = y * x2_x1\n        term_x2 = x_2 * x2_x1\n        term_x = x * eq_b\n        term_c = (y1 - x12) * x2_x1 - (x1 * eq_b)\n    \n        return term_y >= term_x2 + term_x + term_c\n    \n    #print(above(points[2],points[0],points[1]))\n    \n    \n    Us = []\n    for i, p in enumerate(points):\n        while len(Us) >= 2:\n            p1, p2 = Us[-2:]\n            if above(p,p1,p2):\n                Us.pop()\n            else:\n                break\n        Us.append(p)\n    \n    out = len(Us) - 1\n    print(out)",
        "inputs": [
            "3\n-1 0\n0 2\n1 0\n",
            "5\n1 0\n1 -1\n0 -1\n-1 0\n-1 -1\n",
            "1\n-751115 -925948\n"
        ],
        "outputs": [
            "2\n",
            "1\n",
            "0\n"
        ],
        "starter_code": "\ndef yAcHN():\n",
        "scope": [
            [
                "Function Body",
                2,
                66
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ],
            [
                "Lambda Expression",
                12,
                12
            ],
            [
                "Function Body",
                15,
                50
            ],
            [
                "For Loop Body",
                56,
                63
            ],
            [
                "While Loop Body",
                57,
                62
            ],
            [
                "If Statement Body",
                59,
                62
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef fRkVg():\n    \"\"\"Have you ever played Hanabi? If not, then you've got to try it out! This problem deals with a simplified version of the game.\n\nOverall, the game has 25 types of cards (5 distinct colors and 5 distinct values). Borya is holding n cards. The game is somewhat complicated by the fact that everybody sees Borya's cards except for Borya himself. Borya knows which cards he has but he knows nothing about the order they lie in. Note that Borya can have multiple identical cards (and for each of the 25 types of cards he knows exactly how many cards of this type he has).\n\nThe aim of the other players is to achieve the state when Borya knows the color and number value of each of his cards. For that, other players can give him hints. The hints can be of two types: color hints and value hints. \n\nA color hint goes like that: a player names some color and points at all the cards of this color. \n\nSimilarly goes the value hint. A player names some value and points at all the cards that contain the value.\n\nDetermine what minimum number of hints the other players should make for Borya to be certain about each card's color and value.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 100) — the number of Borya's cards. The next line contains the descriptions of n cards. The description of each card consists of exactly two characters. The first character shows the color (overall this position can contain five distinct letters — R, G, B, Y, W). The second character shows the card's value (a digit from 1 to 5). Borya doesn't know exact order of the cards they lie in.\n\n\n-----Output-----\n\nPrint a single integer — the minimum number of hints that the other players should make.\n\n\n-----Examples-----\nInput\n2\nG3 G3\n\nOutput\n0\n\nInput\n4\nG4 R4 R3 B3\n\nOutput\n2\n\nInput\n5\nB1 Y1 W1 G1 R1\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample Borya already knows for each card that it is a green three.\n\nIn the second sample we can show all fours and all red cards.\n\nIn the third sample you need to make hints about any four colors.\n    \"\"\"\n",
        "canonical_solution": "import itertools\ndef fRkVg():\n    \"\"\"\n    Codeforces Round 253 Div 1 Problem A\n    Author  : chaotic_iak\n    Language: Python 3.3.4\n    \"\"\"\n    def read(mode=2):\n        # 0: String\n        # 1: List of strings\n        # 2: List of integers\n        inputs = input().strip()\n        if mode == 0:\n            return inputs\n        if mode == 1:\n            return inputs.split()\n        if mode == 2:\n            return [int(x) for x in inputs.split()]\n    def write(s=\"\\n\"):\n        if isinstance(s, list): s = \" \".join(map(str,s))\n        s = str(s)\n        print(s, end=\"\")\n    ################################################### SOLUTION\n    covers = itertools.product([0,1], repeat=10)\n    n, = read()\n    s = read(1)\n    a = [0] * 25\n    colors = \"RGBYW\"\n    for i in s:\n        a[colors.index(i[0]) * 5 + int(i[1])-1] |= 1\n    def check(cover):\n        nonlocal a\n        unknowns = [0] * 11\n        for i in range(25):\n            if not a[i]: continue\n            id = -1\n            if not cover[i%5]: id = 5+i//5\n            if not cover[5+i//5]:\n                if id == -1:\n                    id = i%5\n                else:\n                    id = 10\n            if id > -1:\n                if unknowns[id]: return False\n                unknowns[id] = 1\n        return True\n    mn = 99\n    for i in covers:\n        if check(i):\n            mn = min(mn, sum(i))\n    print(mn)",
        "inputs": [
            "2\nG3 G3\n",
            "4\nG4 R4 R3 B3\n",
            "5\nB1 Y1 W1 G1 R1\n"
        ],
        "outputs": [
            "0\n",
            "2\n",
            "4\n"
        ],
        "starter_code": "\ndef fRkVg():\n",
        "scope": [
            [
                "Function Body",
                2,
                51
            ],
            [
                "Function Body",
                8,
                18
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "Function Body",
                19,
                22
            ],
            [
                "If Statement Body",
                20,
                20
            ],
            [
                "For Loop Body",
                29,
                30
            ],
            [
                "Function Body",
                31,
                46
            ],
            [
                "For Loop Body",
                34,
                45
            ],
            [
                "If Statement Body",
                35,
                35
            ],
            [
                "If Statement Body",
                37,
                37
            ],
            [
                "If Statement Body",
                38,
                42
            ],
            [
                "If Statement Body",
                39,
                42
            ],
            [
                "If Statement Body",
                43,
                45
            ],
            [
                "If Statement Body",
                44,
                44
            ],
            [
                "For Loop Body",
                48,
                50
            ],
            [
                "If Statement Body",
                49,
                50
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef psJQR():\n    \"\"\"Mayor of city S just hates trees and lawns. They take so much space and there could be a road on the place they occupy!\n\nThe Mayor thinks that one of the main city streets could be considerably widened on account of lawn nobody needs anyway. Moreover, that might help reduce the car jams which happen from time to time on the street.\n\nThe street is split into n equal length parts from left to right, the i-th part is characterized by two integers: width of road s_{i} and width of lawn g_{i}. [Image] \n\nFor each of n parts the Mayor should decide the size of lawn to demolish. For the i-th part he can reduce lawn width by integer x_{i} (0 ≤ x_{i} ≤ g_{i}). After it new road width of the i-th part will be equal to s'_{i} = s_{i} + x_{i} and new lawn width will be equal to g'_{i} = g_{i} - x_{i}.\n\nOn the one hand, the Mayor wants to demolish as much lawn as possible (and replace it with road). On the other hand, he does not want to create a rapid widening or narrowing of the road, which would lead to car accidents. To avoid that, the Mayor decided that width of the road for consecutive parts should differ by at most 1, i.e. for each i (1 ≤ i < n) the inequation |s'_{i} + 1 - s'_{i}| ≤ 1 should hold. Initially this condition might not be true.\n\nYou need to find the the total width of lawns the Mayor will destroy according to his plan.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 2·10^5) — number of parts of the street.\n\nEach of the following n lines contains two integers s_{i}, g_{i} (1 ≤ s_{i} ≤ 10^6, 0 ≤ g_{i} ≤ 10^6) — current width of road and width of the lawn on the i-th part of the street.\n\n\n-----Output-----\n\nIn the first line print the total width of lawns which will be removed.\n\nIn the second line print n integers s'_1, s'_2, ..., s'_{n} (s_{i} ≤ s'_{i} ≤ s_{i} + g_{i}) — new widths of the road starting from the first part and to the last.\n\nIf there is no solution, print the only integer -1 in the first line.\n\n\n-----Examples-----\nInput\n3\n4 5\n4 5\n4 10\n\nOutput\n16\n9 9 10 \n\nInput\n4\n1 100\n100 1\n1 100\n100 1\n\nOutput\n202\n101 101 101 101 \n\nInput\n3\n1 1\n100 100\n1 1\n\nOutput\n-1\n    \"\"\"\n",
        "canonical_solution": "\ndef psJQR():\n    t = []\n    l = []\n    r = []\n    for _ in range(int(input())):\n    \ts, g = map(int, input().split())\n    \tt.append(s)\n    \tl.append(s)\n    \tr.append(g + s)\n    \t\n    for i in range(1, len(l)):\n    \tif l[i] < l[i - 1]:\n    \t\tl[i] = l[i - 1] - 1\n    \tif r[i] > r[i - 1]:\n    \t\tr[i] = r[i - 1] + 1\n    \t\t\n    for i in range(len(l) - 2, -1, -1):\n    \tif l[i] < l[i + 1]:\n    \t\tl[i] = l[i + 1] - 1\n    \tif r[i] > r[i + 1]:\n    \t\tr[i] = r[i + 1] + 1\n    \n    if [1 for a, b in zip(l, r) if a > b]:\n    \tprint(-1)\n    else:\n    \tprint(sum([b - a for a, b in zip(t, r)]))\n    \tprint(' '.join(map(str, r)))",
        "inputs": [
            "3\n4 5\n4 5\n4 10\n",
            "4\n1 100\n100 1\n1 100\n100 1\n",
            "3\n1 1\n100 100\n1 1\n"
        ],
        "outputs": [
            "16\n9 9 10 \n",
            "202\n101 101 101 101 \n",
            "-1\n"
        ],
        "starter_code": "\ndef psJQR():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "For Loop Body",
                6,
                10
            ],
            [
                "For Loop Body",
                12,
                16
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "For Loop Body",
                18,
                22
            ],
            [
                "If Statement Body",
                19,
                20
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "If Statement Body",
                24,
                28
            ],
            [
                "List Comprehension",
                24,
                24
            ],
            [
                "List Comprehension",
                27,
                27
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef JpbLV():\n    \"\"\"There are N bags, each containing two white balls. The i-th box contains two balls with integers x_i and y_i written on them, respectively.\nFor each of these bags, you will paint one of the balls red, and paint the other blue.\nAfterwards, the 2N balls will be classified according to color.\nThen, we will define the following:\n - R_{max}: the maximum integer written on a ball painted in red\n - R_{min}: the minimum integer written on a ball painted in red\n - B_{max}: the maximum integer written on a ball painted in blue\n - B_{min}: the minimum integer written on a ball painted in blue\nFind the minimum possible value of (R_{max} - R_{min}) \\times (B_{max} - B_{min}).\n\n-----Constraints-----\n - 1 ≤ N ≤ 200,000\n - 1 ≤ x_i, y_i ≤ 10^9\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nx_1 y_1\nx_2 y_2\n:\nx_N y_N\n\n-----Output-----\nPrint the minimum possible value.\n\n-----Sample Input-----\n3\n1 2\n3 4\n5 6\n\n-----Sample Output-----\n15\n\nThe optimal solution is to paint the balls with x_1, x_2, y_3 red, and paint the balls with y_1, y_2, x_3 blue.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef JpbLV():\n    def input():\n    \treturn sys.stdin.readline()[:-1]\n    n = int(input())\n    d = []\n    M, m = 0, 10**30\n    M_of_m, m_of_M = 0, 10**30\n    for _ in range(n):\n    \tx, y = map(int, input().split())\n    \tg, l = max(x, y), min(x, y)\n    \td.append([l, g])\n    \tM = max(M, g)\n    \tm = min(m, l)\n    \tM_of_m = max(M_of_m, l)\n    \tm_of_M = min(m_of_M, g)\n    ans1 = (M - m_of_M) * (M_of_m - m)\n    M_other, m_other = M_of_m, m\n    m_reversed = 10**30\n    gap = M_other - m_other\n    d.sort(key=min)\n    for i in range(n-1):\n    \tM_other = max(M_other, d[i][1])\n    \tm_reversed = min(m_reversed, d[i][1])\n    \tm_other = min(m_reversed, d[i+1][0])\n    \tgap = min(gap, M_other - m_other)\n    M_other = max(M_other, d[n-1][1])\n    m_reversed = min(m_reversed, d[i][1])\n    gap = min(gap, M_other - m_reversed)\n    ans2 = (M - m) * gap\n    #print(ans1, ans2)\n    print(min(ans1, ans2))",
        "inputs": [
            "3\n1 2\n3 4\n5 6\n",
            "3\n1010 10\n1000 1\n20 1020\n",
            "2\n1 1\n1000000000 1000000000\n"
        ],
        "outputs": [
            "15\n",
            "380\n",
            "999999998000000001\n"
        ],
        "starter_code": "\ndef JpbLV():\n",
        "scope": [
            [
                "Function Body",
                2,
                32
            ],
            [
                "Function Body",
                3,
                4
            ],
            [
                "For Loop Body",
                9,
                16
            ],
            [
                "For Loop Body",
                22,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef etCjh():\n    \"\"\"An array of integers $p_{1},p_{2}, \\ldots,p_{n}$ is called a permutation if it contains each number from $1$ to $n$ exactly once. For example, the following arrays are permutations: $[3,1,2], [1], [1,2,3,4,5]$ and $[4,3,1,2]$. The following arrays are not permutations: $[2], [1,1], [2,3,4]$.\n\nThere is a hidden permutation of length $n$.\n\nFor each index $i$, you are given $s_{i}$, which equals to the sum of all $p_{j}$ such that $j < i$ and $p_{j} < p_{i}$. In other words, $s_i$ is the sum of elements before the $i$-th element that are smaller than the $i$-th element.\n\nYour task is to restore the permutation.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$) — the size of the permutation.\n\nThe second line contains $n$ integers $s_{1}, s_{2}, \\ldots, s_{n}$ ($0 \\le s_{i} \\le \\frac{n(n-1)}{2}$).\n\nIt is guaranteed that the array $s$ corresponds to a valid permutation of length $n$.\n\n\n-----Output-----\n\nPrint $n$ integers $p_{1}, p_{2}, \\ldots, p_{n}$ — the elements of the restored permutation. We can show that the answer is always unique.\n\n\n-----Examples-----\nInput\n3\n0 0 0\n\nOutput\n3 2 1\n\nInput\n2\n0 1\n\nOutput\n1 2\n\nInput\n5\n0 1 1 1 10\n\nOutput\n1 4 3 2 5\n\n\n\n-----Note-----\n\nIn the first example for each $i$ there is no index $j$ satisfying both conditions, hence $s_i$ are always $0$.\n\nIn the second example for $i = 2$ it happens that $j = 1$ satisfies the conditions, so $s_2 = p_1$.\n\nIn the third example for $i = 2, 3, 4$ only $j = 1$ satisfies the conditions, so $s_2 = s_3 = s_4 = 1$. For $i = 5$ all $j = 1, 2, 3, 4$ are possible, so $s_5 = p_1 + p_2 + p_3 + p_4 = 10$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef etCjh():\n    input = sys.stdin.readline\n    n=int(input())\n    A=list(map(int,input().split()))\n    BIT=[0]*(n+1)\n    def update(v,w):\n        while v<=n:\n            BIT[v]+=w\n            v+=(v&(-v))\n    def getvalue(v):\n        ANS=0\n        while v!=0:\n            ANS+=BIT[v]\n            v-=(v&(-v))\n        return ANS\n    for i in range(1,n+1):\n        update(i,i)\n    ANS=[-1]*n\n    for i in range(n-1,-1,-1):\n        MIN=0\n        MAX=n\n        k=A[i]\n        while True:\n            x=(MIN+MAX+1)//2\n            if getvalue(x)>k:\n                if getvalue(x-1)==k:\n                    ANS[i]=x\n                    break\n                else:\n                    MAX=x\n            else:\n                MIN=x\n        update(x,-x)\n                \n    print(*ANS)",
        "inputs": [
            "3\n0 0 0\n",
            "2\n0 1\n",
            "5\n0 1 1 1 10\n"
        ],
        "outputs": [
            "3 2 1\n",
            "1 2\n",
            "1 4 3 2 5\n"
        ],
        "starter_code": "\ndef etCjh():\n",
        "scope": [
            [
                "Function Body",
                2,
                36
            ],
            [
                "Function Body",
                7,
                10
            ],
            [
                "While Loop Body",
                8,
                10
            ],
            [
                "Function Body",
                11,
                16
            ],
            [
                "While Loop Body",
                13,
                15
            ],
            [
                "For Loop Body",
                17,
                18
            ],
            [
                "For Loop Body",
                20,
                34
            ],
            [
                "While Loop Body",
                24,
                33
            ],
            [
                "If Statement Body",
                26,
                33
            ],
            [
                "If Statement Body",
                27,
                31
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef qwnxS():\n    \"\"\"A has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.\n\nB now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.\n\nYou have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print \"YES\", otherwise print \"NO\" (without the quotes).\n\n\n-----Input-----\n\nThe first and only line consists of a string $S$ ($ 1 \\le |S| \\le 5\\,000 $). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.\n\n\n-----Output-----\n\nPrint \"YES\" or \"NO\", according to the condition.\n\n\n-----Examples-----\nInput\naaabccc\n\nOutput\nYES\n\nInput\nbbacc\n\nOutput\nNO\n\nInput\naabc\n\nOutput\nYES\n\n\n\n-----Note-----\n\nConsider first example: the number of 'c' is equal to the number of 'a'. \n\nConsider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.\n\nConsider third example: the number of 'c' is equal to the number of 'b'.\n    \"\"\"\n",
        "canonical_solution": "\ndef qwnxS():\n    '''input\n    aabc\n    '''\n    \n    def list_input():\n        return list(map(int,input().split()))\n    def map_input():\n        return map(int,input().split())\n    def map_string():\n        return input().split()\n        \n    s = input()\n    a = s.count('a')\n    b = s.count('b')\n    c = s.count('c')\n    ans = \"YES\"\n    if(a == 0 or b == 0): ans = \"NO\"\n    if(c != a and c != b): ans = \"NO\"\n    for i in range(len(s)-1):\n    \tif(s[i] > s[i+1]): ans = \"NO\"\n    print(ans)\t",
        "inputs": [
            "aaabccc\n",
            "bbacc\n",
            "aabc\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "YES\n"
        ],
        "starter_code": "\ndef qwnxS():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Function Body",
                9,
                10
            ],
            [
                "Function Body",
                11,
                12
            ],
            [
                "If Statement Body",
                19,
                19
            ],
            [
                "If Statement Body",
                20,
                20
            ],
            [
                "For Loop Body",
                21,
                22
            ],
            [
                "If Statement Body",
                22,
                22
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef rxbwV():\n    \"\"\"Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $1$ to $n$ and then $3n$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $7n+1$ times instead of $3n$ times. Because it is more random, OK?!\n\nYou somehow get a test from one of these problems and now you want to know from which one.\n\n\n-----Input-----\n\nIn the first line of input there is one integer $n$ ($10^{3} \\le n \\le 10^{6}$).\n\nIn the second line there are $n$ distinct integers between $1$ and $n$ — the permutation of size $n$ from the test.\n\nIt is guaranteed that all tests except for sample are generated this way: First we choose $n$ — the size of the permutation. Then we randomly choose a method to generate a permutation — the one of Petr or the one of Alex. Then we generate a permutation using chosen method.\n\n\n-----Output-----\n\nIf the test is generated via Petr's method print \"Petr\" (without quotes). If the test is generated via Alex's method print \"Um_nik\" (without quotes).\n\n\n-----Example-----\nInput\n5\n2 4 5 1 3\n\nOutput\nPetr\n\n\n\n-----Note-----\n\nPlease note that the sample is not a valid test (because of limitations for $n$) and is given only to illustrate input/output format. Your program still has to print correct answer to this test to get AC.\n\nDue to randomness of input hacks in this problem are forbidden.\n    \"\"\"\n",
        "canonical_solution": "\ndef rxbwV():\n    n = int(input())\n    l = [int(x) - 1 for x in input().split()]\n    parity = 0\n    explore = set(l)\n    while len(explore) > 0:\n        x = explore.pop()\n        tmp = x\n        found = [x]\n        while l[tmp] != x:\n            tmp = l[tmp]\n            found.append(tmp)\n        for i in found[1:]:\n            explore.remove(i)\n        parity ^= (len(found) - 1) % 2\n    \n    if parity == n % 2:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")",
        "inputs": [
            "5\n2 4 5 1 3\n"
        ],
        "outputs": [
            "Petr\n"
        ],
        "starter_code": "\ndef rxbwV():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "While Loop Body",
                7,
                16
            ],
            [
                "While Loop Body",
                11,
                13
            ],
            [
                "For Loop Body",
                14,
                15
            ],
            [
                "If Statement Body",
                18,
                21
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef wnjId():\n    \"\"\"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings a and b of equal length are called equivalent in one of the two cases:   They are equal.  If we split string a into two halves of the same size a_1 and a_2, and string b into two halves of the same size b_1 and b_2, then one of the following is correct:   a_1 is equivalent to b_1, and a_2 is equivalent to b_2  a_1 is equivalent to b_2, and a_2 is equivalent to b_1  \n\nAs a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.\n\nGerald has already completed this home task. Now it's your turn!\n\n\n-----Input-----\n\nThe first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200 000 and consists of lowercase English letters. The strings have the same length.\n\n\n-----Output-----\n\nPrint \"YES\" (without the quotes), if these two strings are equivalent, and \"NO\" (without the quotes) otherwise.\n\n\n-----Examples-----\nInput\naaba\nabaa\n\nOutput\nYES\n\nInput\naabb\nabab\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample you should split the first string into strings \"aa\" and \"ba\", the second one — into strings \"ab\" and \"aa\". \"aa\" is equivalent to \"aa\"; \"ab\" is equivalent to \"ba\" as \"ab\" = \"a\" + \"b\", \"ba\" = \"b\" + \"a\".\n\nIn the second sample the first string can be splitted into strings \"aa\" and \"bb\", that are equivalent only to themselves. That's why string \"aabb\" is equivalent only to itself and to string \"bbaa\".\n    \"\"\"\n",
        "canonical_solution": "\ndef wnjId():\n    def main():\n        a = list(input())\n        b = list(input())\n    \n        n = len(a)\n        k = n\n        while k % 2 == 0:\n            k = k // 2\n    \n        while k != n:\n            pairs = n // (k * 2)\n            for i in range(0, pairs * 2, 2):\n                if a[k * i:k * (i + 1)] > a[k * (i + 1):k * (i + 2)]:\n                    a[k * i:k * (i + 1)], a[k * (i + 1):k * (i + 2)] = a[k * (i + 1):k * (i + 2)], a[k * i:k * (i + 1)]\n                if b[k * i:k * (i + 1)] > b[k * (i + 1):k * (i + 2)]:\n                    b[k * i:k * (i + 1)], b[k * (i + 1):k * (i + 2)] = b[k * (i + 1):k * (i + 2)], b[k * i:k * (i + 1)]\n            k *= 2\n    \n        if a == b:\n            print('YES')\n        else:\n            print('NO')\n    \n    \n    main()\n    ",
        "inputs": [
            "aaba\nabaa\n",
            "aabb\nabab\n",
            "a\na\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "YES\n"
        ],
        "starter_code": "\ndef wnjId():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                3,
                24
            ],
            [
                "While Loop Body",
                9,
                10
            ],
            [
                "While Loop Body",
                12,
                19
            ],
            [
                "For Loop Body",
                14,
                18
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                21,
                24
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef irsRD():\n    \"\"\"Summer is coming! It's time for Iahub and Iahubina to work out, as they both want to look hot at the beach. The gym where they go is a matrix a with n lines and m columns. Let number a[i][j] represents the calories burned by performing workout at the cell of gym in the i-th line and the j-th column.\n\nIahub starts with workout located at line 1 and column 1. He needs to finish with workout a[n][m]. After finishing workout a[i][j], he can go to workout a[i + 1][j] or a[i][j + 1]. Similarly, Iahubina starts with workout a[n][1] and she needs to finish with workout a[1][m]. After finishing workout from cell a[i][j], she goes to either a[i][j + 1] or a[i - 1][j]. \n\nThere is one additional condition for their training. They have to meet in exactly one cell of gym. At that cell, none of them will work out. They will talk about fast exponentiation (pretty odd small talk) and then both of them will move to the next workout.\n\nIf a workout was done by either Iahub or Iahubina, it counts as total gain. Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible. Note, that Iahub and Iahubina can perform workouts with different speed, so the number of cells that they use to reach meet cell may differs.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000). Each of the next n lines contains m integers: j-th number from i-th line denotes element a[i][j] (0 ≤ a[i][j] ≤ 10^5).\n\n\n-----Output-----\n\nThe output contains a single number — the maximum total gain possible. \n\n\n-----Examples-----\nInput\n3 3\n100 100 100\n100 1 100\n100 100 100\n\nOutput\n800\n\n\n-----Note-----\n\nIahub will choose exercises a[1][1] → a[1][2] → a[2][2] → a[3][2] → a[3][3]. Iahubina will choose exercises a[3][1] → a[2][1] → a[2][2] → a[2][3] → a[1][3].\n    \"\"\"\n",
        "canonical_solution": "\ndef irsRD():\n    def main():\n        n, m = list(map(int, input().split()))\n        aa = []\n        for _ in range(n):\n            row = list(map(int, input().split()))\n            row.append(0)\n            aa.append(row)\n        aa.append([0] * (m + 1))\n        d1, d2, d3, d4 = ([[0] * (m + 1) for _ in range(n + 1)] for _ in (1, 2, 3, 4))\n        for i in range(n):\n            for j in range(m):\n                d1[i][j] = max(d1[i - 1][j], d1[i][j - 1]) + aa[i][j]\n        for i in range(n):\n            for j in range(m - 1, -1, -1):\n                d2[i][j] = max(d2[i - 1][j], d2[i][j + 1]) + aa[i][j]\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                d3[i][j] = max(d3[i + 1][j], d3[i][j - 1]) + aa[i][j]\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                d4[i][j] = max(d4[i + 1][j], d4[i][j + 1]) + aa[i][j]\n        print((max(\n            max(d1[i][j - 1] + d2[i - 1][j] + d3[i + 1][j] + d4[i][j + 1] for i in range(1, n - 1) for j in range(1, m - 1)),\n            max(d1[i - 1][j] + d2[i][j + 1] + d3[i][j - 1] + d4[i + 1][j] for i in range(1, n - 1) for j in range(1, m - 1)))))\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "3 3\n100 100 100\n100 1 100\n100 100 100\n",
            "4 5\n87882 40786 3691 85313 46694\n28884 16067 3242 97367 78518\n4250 35501 9780 14435 19004\n64673 65438 56977 64495 27280\n",
            "3 3\n3 1 2\n3 2 0\n2 3 2\n"
        ],
        "outputs": [
            "800",
            "747898",
            "16"
        ],
        "starter_code": "\ndef irsRD():\n",
        "scope": [
            [
                "Function Body",
                2,
                32
            ],
            [
                "Function Body",
                3,
                26
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "Generator Expression",
                11,
                11
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "For Loop Body",
                13,
                14
            ],
            [
                "For Loop Body",
                15,
                17
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                18,
                20
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "For Loop Body",
                21,
                23
            ],
            [
                "For Loop Body",
                22,
                23
            ],
            [
                "Generator Expression",
                25,
                25
            ],
            [
                "Generator Expression",
                26,
                26
            ],
            [
                "Function Body",
                29,
                30
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef lXCNz():\n    \"\"\"Sasha and Kolya decided to get drunk with Coke, again. This time they have k types of Coke. i-th type is characterised by its carbon dioxide concentration $\\frac{a_{i}}{1000}$. Today, on the party in honour of Sergiy of Vancouver they decided to prepare a glass of Coke with carbon dioxide concentration $\\frac{n}{1000}$. The drink should also be tasty, so the glass can contain only integer number of liters of each Coke type (some types can be not presented in the glass). Also, they want to minimize the total volume of Coke in the glass.\n\nCarbon dioxide concentration is defined as the volume of carbone dioxide in the Coke divided by the total volume of Coke. When you mix two Cokes, the volume of carbon dioxide sums up, and the total volume of Coke sums up as well.\n\nHelp them, find the minimal natural number of liters needed to create a glass with carbon dioxide concentration $\\frac{n}{1000}$. Assume that the friends have unlimited amount of each Coke type.\n\n\n-----Input-----\n\nThe first line contains two integers n, k (0 ≤ n ≤ 1000, 1 ≤ k ≤ 10^6) — carbon dioxide concentration the friends want and the number of Coke types.\n\nThe second line contains k integers a_1, a_2, ..., a_{k} (0 ≤ a_{i} ≤ 1000) — carbon dioxide concentration of each type of Coke. Some Coke types can have same concentration.\n\n\n-----Output-----\n\nPrint the minimal natural number of liter needed to prepare a glass with carbon dioxide concentration $\\frac{n}{1000}$, or -1 if it is impossible.\n\n\n-----Examples-----\nInput\n400 4\n100 300 450 500\n\nOutput\n2\n\nInput\n50 2\n100 25\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample case, we can achieve concentration $\\frac{400}{1000}$ using one liter of Coke of types $\\frac{300}{1000}$ and $\\frac{500}{1000}$: $\\frac{300 + 500}{1000 + 1000} = \\frac{400}{1000}$.\n\nIn the second case, we can achieve concentration $\\frac{50}{1000}$ using two liters of $\\frac{25}{1000}$ type and one liter of $\\frac{100}{1000}$ type: $\\frac{25 + 25 + 100}{3 \\cdot 1000} = \\frac{50}{1000}$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef lXCNz():\n    ##\n    ##\n    ##\n    def line():\n        return sys.stdin.readline()\n    def numbers():\n        return list(map(int, line().split()))\n    def number():\n        return int(line())\n    adjlist = {}\n    n, k = 0, 0\n    mark = [False]*2010\n    edges = [False]*1010\n    # bfs for \"ssph\"\n    def bfs(s):\n        \n        i = 0\n        frontier = [s]\n        while frontier:\n            if mark[s]:\n                break;\n            next_frontier = []\n            for u in frontier:\n                # check next state\n                for v, isState in enumerate(edges):\n                    if isState:\n                        # check new node\n                        state = u + (n - 1000) - v\n                        if state >= 0 and state <= 2000 and not mark[state]:\n                            mark[state] = True\n                            next_frontier.append(state)\n            frontier = next_frontier\n            i += 1\n        if mark[s]:\n            return i\n        else:\n            return -1\n    # main program\n    [n, k] = numbers()\n    concentrations = numbers()\n    # reading edges\n    for x in concentrations:\n        edges[x] = True\n    n = n + 1000\n    ans = bfs(1000)\n    print(ans)\n    # 1496438704903",
        "inputs": [
            "400 4\n100 300 450 500\n",
            "50 2\n100 25\n",
            "500 3\n1000 5 5\n"
        ],
        "outputs": [
            "2\n",
            "3\n",
            "199\n"
        ],
        "starter_code": "\ndef lXCNz():\n",
        "scope": [
            [
                "Function Body",
                2,
                48
            ],
            [
                "Function Body",
                6,
                7
            ],
            [
                "Function Body",
                8,
                9
            ],
            [
                "Function Body",
                10,
                11
            ],
            [
                "Function Body",
                17,
                39
            ],
            [
                "While Loop Body",
                21,
                35
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "For Loop Body",
                25,
                33
            ],
            [
                "For Loop Body",
                27,
                33
            ],
            [
                "If Statement Body",
                28,
                33
            ],
            [
                "If Statement Body",
                31,
                33
            ],
            [
                "If Statement Body",
                36,
                39
            ],
            [
                "For Loop Body",
                44,
                45
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef bPvlQ():\n    \"\"\"THE SxPLAY & KIVΛ - 漂流 KIVΛ & Nikki Simmons - Perspectives\n\nWith a new body, our idol Aroma White (or should we call her Kaori Minamiya?) begins to uncover her lost past through the OS space.\n\nThe space can be considered a 2D plane, with an infinite number of data nodes, indexed from $0$, with their coordinates defined as follows:  The coordinates of the $0$-th node is $(x_0, y_0)$  For $i > 0$, the coordinates of $i$-th node is $(a_x \\cdot x_{i-1} + b_x, a_y \\cdot y_{i-1} + b_y)$ \n\nInitially Aroma stands at the point $(x_s, y_s)$. She can stay in OS space for at most $t$ seconds, because after this time she has to warp back to the real world. She doesn't need to return to the entry point $(x_s, y_s)$ to warp home.\n\nWhile within the OS space, Aroma can do the following actions:  From the point $(x, y)$, Aroma can move to one of the following points: $(x-1, y)$, $(x+1, y)$, $(x, y-1)$ or $(x, y+1)$. This action requires $1$ second.  If there is a data node at where Aroma is staying, she can collect it. We can assume this action costs $0$ seconds. Of course, each data node can be collected at most once. \n\nAroma wants to collect as many data as possible before warping back. Can you help her in calculating the maximum number of data nodes she could collect within $t$ seconds?\n\n\n-----Input-----\n\nThe first line contains integers $x_0$, $y_0$, $a_x$, $a_y$, $b_x$, $b_y$ ($1 \\leq x_0, y_0 \\leq 10^{16}$, $2 \\leq a_x, a_y \\leq 100$, $0 \\leq b_x, b_y \\leq 10^{16}$), which define the coordinates of the data nodes.\n\nThe second line contains integers $x_s$, $y_s$, $t$ ($1 \\leq x_s, y_s, t \\leq 10^{16}$) – the initial Aroma's coordinates and the amount of time available.\n\n\n-----Output-----\n\nPrint a single integer — the maximum number of data nodes Aroma can collect within $t$ seconds.\n\n\n-----Examples-----\nInput\n1 1 2 3 1 0\n2 4 20\n\nOutput\n3\nInput\n1 1 2 3 1 0\n15 27 26\n\nOutput\n2\nInput\n1 1 2 3 1 0\n2 2 1\n\nOutput\n0\n\n\n-----Note-----\n\nIn all three examples, the coordinates of the first $5$ data nodes are $(1, 1)$, $(3, 3)$, $(7, 9)$, $(15, 27)$ and $(31, 81)$ (remember that nodes are numbered from $0$).\n\nIn the first example, the optimal route to collect $3$ nodes is as follows:   Go to the coordinates $(3, 3)$ and collect the $1$-st node. This takes $|3 - 2| + |3 - 4| = 2$ seconds.  Go to the coordinates $(1, 1)$ and collect the $0$-th node. This takes $|1 - 3| + |1 - 3| = 4$ seconds.  Go to the coordinates $(7, 9)$ and collect the $2$-nd node. This takes $|7 - 1| + |9 - 1| = 14$ seconds. \n\nIn the second example, the optimal route to collect $2$ nodes is as follows:   Collect the $3$-rd node. This requires no seconds.  Go to the coordinates $(7, 9)$ and collect the $2$-th node. This takes $|15 - 7| + |27 - 9| = 26$ seconds. \n\nIn the third example, Aroma can't collect any nodes. She should have taken proper rest instead of rushing into the OS space like that.\n    \"\"\"\n",
        "canonical_solution": "\ndef bPvlQ():\n    x0, y0, A, C, B, D = list(map(int, input().split()))\n    \n    pts = [[x0, y0]]\n    for i in range(100):\n    \tnx, ny = [pts[-1][0] * A + B, pts[-1][1] * C + D]\n    \tpts.append([nx, ny])\n    \tif max(nx, ny) > 10000000000000000 * 10000000000000000: break\n    \n    \n    x, y, t = list(map(int, input().split()))\n    # print (pts[0])\n    # print (pts[1])\n    # print (pts[2])\n    # print (pts[3])\n    _max = 0\n    for i in range(len(pts)):\n    \tfor j in range(len(pts)):\n    \t\tif abs(pts[i][0] - pts[j][0]) + abs(pts[i][1] - pts[j][1]) + abs(x - pts[i][0]) + abs(y - pts[i][1]) <= t:\n    \t\t\t_max = max(_max, abs(i - j) + 1)\n    print(_max)\n    ",
        "inputs": [
            "1 1 2 3 1 0\n2 4 20\n",
            "1 1 2 3 1 0\n15 27 26\n",
            "1 1 2 3 1 0\n2 2 1\n"
        ],
        "outputs": [
            "3",
            "2",
            "0"
        ],
        "starter_code": "\ndef bPvlQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "If Statement Body",
                9,
                9
            ],
            [
                "For Loop Body",
                18,
                21
            ],
            [
                "For Loop Body",
                19,
                21
            ],
            [
                "If Statement Body",
                20,
                21
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef WlHfr():\n    \"\"\"Vova and Marina love offering puzzles to each other. Today Marina offered Vova to cope with the following task.\n\nVova has a non-directed graph consisting of n vertices and m edges without loops and multiple edges. Let's define the operation of contraction two vertices a and b that are not connected by an edge. As a result of this operation vertices a and b are deleted and instead of them a new vertex x is added into the graph, and also edges are drawn from it to all vertices that were connected with a or with b (specifically, if the vertex was connected with both a and b, then also exactly one edge is added from x to it). Thus, as a result of contraction again a non-directed graph is formed, it contains no loops nor multiple edges, and it contains (n - 1) vertices.\n\nVova must perform the contraction an arbitrary number of times to transform the given graph into a chain of the maximum length. A chain of length k (k ≥ 0) is a connected graph whose vertices can be numbered with integers from 1 to k + 1 so that the edges of the graph connect all pairs of vertices (i, i + 1) (1 ≤ i ≤ k) and only them. Specifically, the graph that consists of one vertex is a chain of length 0. The vertices that are formed as a result of the contraction are allowed to be used in the following operations of contraction.\n\n [Image] The picture illustrates the contraction of two vertices marked by red. \n\nHelp Vova cope with his girlfriend's task. Find the maximum length of the chain that can be obtained from the resulting graph or else determine that it is impossible to obtain the chain.\n\n\n-----Input-----\n\nThe first line contains two integers n, m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the original graph.\n\nNext m lines contain the descriptions of edges in the format a_{i}, b_{i} (1 ≤ a_{i}, b_{i} ≤ n, a_{i} ≠ b_{i}), which means that there is an edge between vertices a_{i} and b_{i}. It is guaranteed that there is at most one edge between each pair of vertexes.\n\n\n-----Output-----\n\nIf it is impossible to obtain a chain from the given graph, print  - 1. Otherwise, print the maximum possible number of edges in the resulting chain.\n\n\n-----Examples-----\nInput\n5 4\n1 2\n2 3\n3 4\n3 5\n\nOutput\n3\n\nInput\n4 6\n1 2\n2 3\n1 3\n3 4\n2 4\n1 4\n\nOutput\n-1\n\nInput\n4 2\n1 3\n2 4\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample test you can contract vertices 4 and 5 and obtain a chain of length 3.\n\nIn the second sample test it is initially impossible to contract any pair of vertexes, so it is impossible to achieve the desired result.\n\nIn the third sample test you can contract vertices 1 and 2 and obtain a chain of length 2.\n    \"\"\"\n",
        "canonical_solution": "\ndef WlHfr():\n    n, m = list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for i in range(m):\n        p, q = list(map(int, input().split()))\n        g[p - 1].append(q - 1)\n        g[q - 1].append(p - 1)\n    \n    comp = [-1] * n\n    def shortest(root):\n        dist = [-1] * n\n        q = [0] * n\n        left, right = 0, 1\n        q[left] = root\n        dist[root] = 0\n        good = True\n        while left < right:\n            x = q[left]\n            left = left + 1\n            for i in g[x]:\n                if dist[i] == -1: \n                    dist[i] = 1 + dist[x]\n                    q[right] = i\n                    right = right + 1\n                elif dist[i] == dist[x]:\n                    good = False \n        far = 0\n        for i in dist: \n            if far < i:\n                far = i\n        return good, far, dist\n    \n    arr = [0] * n\n    good = True\n    for i in range(n):\n        _, opt, dist = shortest(i)\n        if _ is False: good = False\n        if comp[i] == -1:\n            for j in range(n): \n                if dist[j] != -1: comp[j] = i\n        if arr[comp[i]] < opt: \n            arr[comp[i]] = opt\n    \n    if good is False: print('-1')\n    else: print(sum(arr))\n    \n    ",
        "inputs": [
            "5 4\n1 2\n2 3\n3 4\n3 5\n",
            "4 6\n1 2\n2 3\n1 3\n3 4\n2 4\n1 4\n",
            "4 2\n1 3\n2 4\n"
        ],
        "outputs": [
            "3\n",
            "-1\n",
            "2\n"
        ],
        "starter_code": "\ndef WlHfr():\n",
        "scope": [
            [
                "Function Body",
                2,
                46
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "Function Body",
                11,
                32
            ],
            [
                "While Loop Body",
                18,
                27
            ],
            [
                "For Loop Body",
                21,
                27
            ],
            [
                "If Statement Body",
                22,
                27
            ],
            [
                "If Statement Body",
                26,
                27
            ],
            [
                "For Loop Body",
                29,
                31
            ],
            [
                "If Statement Body",
                30,
                31
            ],
            [
                "For Loop Body",
                36,
                43
            ],
            [
                "If Statement Body",
                38,
                38
            ],
            [
                "If Statement Body",
                39,
                41
            ],
            [
                "For Loop Body",
                40,
                41
            ],
            [
                "If Statement Body",
                41,
                41
            ],
            [
                "If Statement Body",
                42,
                43
            ],
            [
                "If Statement Body",
                45,
                46
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef dEnUm():\n    \"\"\"Vasya came up with his own weather forecasting method. He knows the information about the average air temperature for each of the last n days. Assume that the average air temperature for each day is integral.\n\nVasya believes that if the average temperatures over the last n days form an arithmetic progression, where the first term equals to the average temperature on the first day, the second term equals to the average temperature on the second day and so on, then the average temperature of the next (n + 1)-th day will be equal to the next term of the arithmetic progression. Otherwise, according to Vasya's method, the temperature of the (n + 1)-th day will be equal to the temperature of the n-th day.\n\nYour task is to help Vasya predict the average temperature for tomorrow, i. e. for the (n + 1)-th day.\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 100) — the number of days for which the average air temperature is known.\n\nThe second line contains a sequence of integers t_1, t_2, ..., t_{n} ( - 1000 ≤ t_{i} ≤ 1000) — where t_{i} is the average temperature in the i-th day.\n\n\n-----Output-----\n\nPrint the average air temperature in the (n + 1)-th day, which Vasya predicts according to his method. Note that the absolute value of the predicted temperature can exceed 1000.\n\n\n-----Examples-----\nInput\n5\n10 5 0 -5 -10\n\nOutput\n-15\n\nInput\n4\n1 1 1 1\n\nOutput\n1\n\nInput\n3\n5 1 -5\n\nOutput\n-5\n\nInput\n2\n900 1000\n\nOutput\n1100\n\n\n\n-----Note-----\n\nIn the first example the sequence of the average temperatures is an arithmetic progression where the first term is 10 and each following terms decreases by 5. So the predicted average temperature for the sixth day is  - 10 - 5 =  - 15.\n\nIn the second example the sequence of the average temperatures is an arithmetic progression where the first term is 1 and each following terms equals to the previous one. So the predicted average temperature in the fifth day is 1.\n\nIn the third example the average temperatures do not form an arithmetic progression, so the average temperature of the fourth day equals to the temperature of the third day and equals to  - 5.\n\nIn the fourth example the sequence of the average temperatures is an arithmetic progression where the first term is 900 and each the following terms increase by 100. So predicted average temperature in the third day is 1000 + 100 = 1100.\n    \"\"\"\n",
        "canonical_solution": "\ndef dEnUm():\n    count = int(input())\n    array = list(map(int, input().split()))\n    \n    diff = array[0] - array[1]\n    holds = True\n    \n    for index in range(1, len(array)-1):\n        if array[index] - array[index+1] != diff:\n            holds = False\n    \n    if holds:\n        print(array[-1] - (array[-2] - array[-1]))\n    else:\n        print(array[-1])\n    \n            \n    ",
        "inputs": [
            "5\n10 5 0 -5 -10\n",
            "4\n1 1 1 1\n",
            "3\n5 1 -5\n"
        ],
        "outputs": [
            "-15\n",
            "1\n",
            "-5\n"
        ],
        "starter_code": "\ndef dEnUm():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                9,
                11
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef qeFzN():\n    \"\"\"This is the harder version of the problem. In this version, $1 \\le n \\le 10^6$ and $0 \\leq a_i \\leq 10^6$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problems\n\nChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $n$ boxes of chocolate, numbered from $1$ to $n$. Initially, the $i$-th box contains $a_i$ chocolate pieces.\n\nSince Bob is a typical nice guy, he will not send Alice $n$ empty boxes. In other words, at least one of $a_1, a_2, \\ldots, a_n$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $k > 1$ such that the number of pieces in each box is divisible by $k$. Note that Alice won't mind if there exists some empty boxes. \n\nCharlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $i$ and put it into either box $i-1$ or box $i+1$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^6$) — the number of chocolate boxes.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^6$) — the number of chocolate pieces in the $i$-th box.\n\nIt is guaranteed that at least one of $a_1, a_2, \\ldots, a_n$ is positive.\n\n\n-----Output-----\n\nIf there is no way for Charlie to make Alice happy, print $-1$.\n\nOtherwise, print a single integer $x$ — the minimum number of seconds for Charlie to help Bob make Alice happy.\n\n\n-----Examples-----\nInput\n3\n4 8 5\n\nOutput\n9\n\nInput\n5\n3 10 2 1 5\n\nOutput\n2\n\nInput\n4\n0 5 15 10\n\nOutput\n0\n\nInput\n1\n1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first example, Charlie can move all chocolate pieces to the second box. Each box will be divisible by $17$.\n\nIn the second example, Charlie can move a piece from box $2$ to box $3$ and a piece from box $4$ to box $5$. Each box will be divisible by $3$.\n\nIn the third example, each box is already divisible by $5$.\n\nIn the fourth example, since Charlie has no available move, he cannot help Bob make Alice happy.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef qeFzN():\n    # 素因数分解\n    def prime_decomposition(n):\n        i = 2\n        table = []\n        while i * i <= n:\n            while n % i == 0:\n                n //= i\n                table.append(i)\n            i += 1\n        if n > 1:\n            table.append(n)\n        return table\n    input = sys.stdin.readline\n    N = int(input())\n    A = list(map(int, input().split()))\n    # かけらを移動させて共通因数を持つようにする\n    su = sum(A)\n    if su == 1:\n        print(-1)\n        return\n    primes = sorted(set(prime_decomposition(su)))\n    ans = 10**18\n    for p in primes:\n        an = 0\n        half = p >> 1\n        cnt = 0\n        for a in A:\n            a %= p\n            cnt += a\n            if cnt <= half:\n                an += cnt\n            else:\n                if cnt < p:\n                    an += p - cnt\n                else:\n                    cnt -= p\n                    if cnt <= half:\n                        an += cnt\n                    else:\n                        an += p - cnt\n            if ans <= an:\n                break\n        else:\n            ans = min(ans, an)\n    print(ans)",
        "inputs": [
            "3\n4 8 5\n",
            "5\n3 10 2 1 5\n",
            "4\n0 5 15 10\n"
        ],
        "outputs": [
            "9\n",
            "2\n",
            "0\n"
        ],
        "starter_code": "\ndef qeFzN():\n",
        "scope": [
            [
                "Function Body",
                2,
                47
            ],
            [
                "Function Body",
                4,
                14
            ],
            [
                "While Loop Body",
                7,
                11
            ],
            [
                "While Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                12,
                13
            ],
            [
                "If Statement Body",
                20,
                22
            ],
            [
                "For Loop Body",
                25,
                46
            ],
            [
                "For Loop Body",
                29,
                46
            ],
            [
                "If Statement Body",
                32,
                42
            ],
            [
                "If Statement Body",
                35,
                42
            ],
            [
                "If Statement Body",
                39,
                42
            ],
            [
                "If Statement Body",
                43,
                44
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef vyiWM():\n    \"\"\"N hotels are located on a straight line. The coordinate of the i-th hotel (1 \\leq i \\leq N) is x_i.\nTak the traveler has the following two personal principles:\n - He never travels a distance of more than L in a single day.\n - He never sleeps in the open. That is, he must stay at a hotel at the end of a day.\nYou are given Q queries. The j-th (1 \\leq j \\leq Q) query is described by two distinct integers a_j and b_j.\nFor each query, find the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel following his principles.\nIt is guaranteed that he can always travel from the a_j-th hotel to the b_j-th hotel, in any given input.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq L \\leq 10^9\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq x_i < x_2 < ... < x_N \\leq 10^9\n - x_{i+1} - x_i \\leq L\n - 1 \\leq a_j,b_j \\leq N\n - a_j \\neq b_j\n - N,\\,L,\\,Q,\\,x_i,\\,a_j,\\,b_j are integers.\n\n-----Partial Score-----\n - 200 points will be awarded for passing the test set satisfying N \\leq 10^3 and Q \\leq 10^3.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nx_1 x_2 ... x_N\nL\nQ\na_1 b_1\na_2 b_2\n:\na_Q b_Q\n\n-----Output-----\nPrint Q lines.\nThe j-th line (1 \\leq j \\leq Q) should contain the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel.\n\n-----Sample Input-----\n9\n1 3 6 13 15 18 19 29 31\n10\n4\n1 8\n7 3\n6 7\n8 5\n\n-----Sample Output-----\n4\n2\n1\n2\n\nFor the 1-st query, he can travel from the 1-st hotel to the 8-th hotel in 4 days, as follows:\n - Day 1: Travel from the 1-st hotel to the 2-nd hotel. The distance traveled is 2.\n - Day 2: Travel from the 2-nd hotel to the 4-th hotel. The distance traveled is 10.\n - Day 3: Travel from the 4-th hotel to the 7-th hotel. The distance traveled is 6.\n - Day 4: Travel from the 7-th hotel to the 8-th hotel. The distance traveled is 10.\n    \"\"\"\n",
        "canonical_solution": "\ndef vyiWM():\n    N = int(input())\n    X = list(map(int, input().split()))\n    L = int(input())\n    \n    def one_step(i):\n      goal = X[i] + L\n      \n      # find largest j s.t. X[j] <= X[i] + L\n      low = 0\n      high = N\n      while high - low > 1:\n        mid = (high + low)//2\n        if X[mid] <= goal:\n          low = mid\n        else:\n          high = mid\n      \n      return low\n    \n    onesteps = [one_step(i) for i in range(N)]\n    \n    def double(layer):\n      return [layer[layer[i]] for i in range(N)]\n    \n    NUM_LAYERS = 20\n    layers = [onesteps]\n    for _ in range(NUM_LAYERS):\n      layers.append(double(layers[-1]))\n      \n    def query(a, b):\n      if a > b:\n        a, b = b, a\n      \n      ans = 0\n      while a < b:\n        ind = 0\n        while layers[ind + 1][a] < b:\n          ind += 1\n        ans += 2 ** ind\n        a = layers[ind][a]\n      return ans\n      \n    Q = int(input())\n    for _ in range(Q):\n      a, b = map(int, input().split())\n      a -= 1\n      b -= 1\n      print(query(a, b))",
        "inputs": [
            "9\n1 3 6 13 15 18 19 29 31\n10\n4\n1 8\n7 3\n6 7\n8 5\n"
        ],
        "outputs": [
            "4\n2\n1\n2\n"
        ],
        "starter_code": "\ndef vyiWM():\n",
        "scope": [
            [
                "Function Body",
                2,
                50
            ],
            [
                "Function Body",
                7,
                20
            ],
            [
                "While Loop Body",
                13,
                18
            ],
            [
                "If Statement Body",
                15,
                18
            ],
            [
                "List Comprehension",
                22,
                22
            ],
            [
                "Function Body",
                24,
                25
            ],
            [
                "List Comprehension",
                25,
                25
            ],
            [
                "For Loop Body",
                29,
                30
            ],
            [
                "Function Body",
                32,
                43
            ],
            [
                "If Statement Body",
                33,
                34
            ],
            [
                "While Loop Body",
                37,
                42
            ],
            [
                "While Loop Body",
                39,
                40
            ],
            [
                "For Loop Body",
                46,
                50
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef BwvfX():\n    \"\"\"Squirrel Liss is interested in sequences. She also has preferences of integers. She thinks n integers a_1, a_2, ..., a_{n} are good.\n\nNow she is interested in good sequences. A sequence x_1, x_2, ..., x_{k} is called good if it satisfies the following three conditions:  The sequence is strictly increasing, i.e. x_{i} < x_{i} + 1 for each i (1 ≤ i ≤ k - 1).  No two adjacent elements are coprime, i.e. gcd(x_{i}, x_{i} + 1) > 1 for each i (1 ≤ i ≤ k - 1) (where gcd(p, q) denotes the greatest common divisor of the integers p and q).  All elements of the sequence are good integers. \n\nFind the length of the longest good sequence.\n\n\n-----Input-----\n\nThe input consists of two lines. The first line contains a single integer n (1 ≤ n ≤ 10^5) — the number of good integers. The second line contains a single-space separated list of good integers a_1, a_2, ..., a_{n} in strictly increasing order (1 ≤ a_{i} ≤ 10^5; a_{i} < a_{i} + 1).\n\n\n-----Output-----\n\nPrint a single integer — the length of the longest good sequence.\n\n\n-----Examples-----\nInput\n5\n2 3 4 6 9\n\nOutput\n4\n\nInput\n9\n1 2 3 5 6 7 8 9 10\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example, the following sequences are examples of good sequences: [2; 4; 6; 9], [2; 4; 6], [3; 9], [6]. The length of the longest good sequence is 4.\n    \"\"\"\n",
        "canonical_solution": "\ndef BwvfX():\n    n = 100001\n    p = [0] * n\n    t = [[] for i in range(n)]\n    t[1] = [1]\n    for i in range(2, n):\n        if not t[i]:\n            t[i] = [i]\n            for j in range(2 * i, n, i): t[j].append(i)\n    input()\n    a = list(map(int, input().split()))\n    for i in a:\n        x = max(p[j] for j in t[i]) + 1\n        for j in t[i]: p[j] = x\n    print(max(p))",
        "inputs": [
            "5\n2 3 4 6 9\n",
            "9\n1 2 3 5 6 7 8 9 10\n",
            "4\n1 2 4 6\n"
        ],
        "outputs": [
            "4\n",
            "4\n",
            "3\n"
        ],
        "starter_code": "\ndef BwvfX():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                7,
                10
            ],
            [
                "If Statement Body",
                8,
                10
            ],
            [
                "For Loop Body",
                10,
                10
            ],
            [
                "For Loop Body",
                13,
                15
            ],
            [
                "Generator Expression",
                14,
                14
            ],
            [
                "For Loop Body",
                15,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef aQEMN():\n    \"\"\"Leha decided to move to a quiet town Vičkopolis, because he was tired by living in Bankopolis. Upon arrival he immediately began to expand his network of hacked computers. During the week Leha managed to get access to n computers throughout the town. Incidentally all the computers, which were hacked by Leha, lie on the same straight line, due to the reason that there is the only one straight street in Vičkopolis.\n\nLet's denote the coordinate system on this street. Besides let's number all the hacked computers with integers from 1 to n. So the i-th hacked computer is located at the point x_{i}. Moreover the coordinates of all computers are distinct. \n\nLeha is determined to have a little rest after a hard week. Therefore he is going to invite his friend Noora to a restaurant. However the girl agrees to go on a date with the only one condition: Leha have to solve a simple task.\n\nLeha should calculate a sum of F(a) for all a, where a is a non-empty subset of the set, that consists of all hacked computers. Formally, let's denote A the set of all integers from 1 to n. Noora asks the hacker to find value of the expression $\\sum_{a \\subseteq A, a \\neq \\varnothing} F(a)$. Here F(a) is calculated as the maximum among the distances between all pairs of computers from the set a. Formally, $F(a) = \\operatorname{max}_{i, j \\in a}|x_{i} - x_{j}|$. Since the required sum can be quite large Noora asks to find it modulo 10^9 + 7.\n\nThough, Leha is too tired. Consequently he is not able to solve this task. Help the hacker to attend a date.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 ≤ n ≤ 3·10^5) denoting the number of hacked computers.\n\nThe second line contains n integers x_1, x_2, ..., x_{n} (1 ≤ x_{i} ≤ 10^9) denoting the coordinates of hacked computers. It is guaranteed that all x_{i} are distinct.\n\n\n-----Output-----\n\nPrint a single integer — the required sum modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n2\n4 7\n\nOutput\n3\n\nInput\n3\n4 3 1\n\nOutput\n9\n\n\n\n-----Note-----\n\nThere are three non-empty subsets in the first sample test:$\\{4 \\}$, $\\{7 \\}$ and $\\{4,7 \\}$. The first and the second subset increase the sum by 0 and the third subset increases the sum by 7 - 4 = 3. In total the answer is 0 + 0 + 3 = 3.\n\nThere are seven non-empty subsets in the second sample test. Among them only the following subsets increase the answer: $\\{4,3 \\}$, $\\{4,1 \\}$, $\\{3,1 \\}$, $\\{4,3,1 \\}$. In total the sum is (4 - 3) + (4 - 1) + (3 - 1) + (4 - 1) = 9.\n    \"\"\"\n",
        "canonical_solution": "\ndef aQEMN():\n    3\n    # Copyright (C) 2017 Sayutin Dmitry.\n    #\n    # This program is free software; you can redistribute it and/or\n    # modify it under the terms of the GNU General Public License as\n    # published by the Free Software Foundation; version 3\n    #\n    # This program is distributed in the hope that it will be useful,\n    # but WITHOUT ANY WARRANTY; without even the implied warranty of\n    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    # GNU General Public License for more details.\n    #\n    # You should have received a copy of the GNU General Public License\n    # along with this program; If not, see <http://www.gnu.org/licenses/>.\n    \n    def main():\n        mod = 10 ** 9 + 7\n        pws = [None for i in range(4 * (10 ** 5))]\n        pws[0] = 1\n        for i in range(1, (4 * (10 ** 5))):\n            pws[i] = 2 * pws[i - 1] % mod\n        \n        n = int(input())\n        seq = list(map(int, input().split()))\n    \n        seq.sort()\n        \n        ans = 0\n        for i in range(n):\n            ans += seq[i] * (pws[i] - 1)\n            ans -= seq[i] * (pws[n - i - 1] - 1)\n            ans = ans % mod\n        print(ans)\n    \n    main()\n    ",
        "inputs": [
            "2\n4 7\n",
            "3\n4 3 1\n",
            "20\n8 11 13 19 21 34 36 44 57 58 61 63 76 78 79 81 85 86 90 95\n"
        ],
        "outputs": [
            "3\n",
            "9\n",
            "83396599\n"
        ],
        "starter_code": "\ndef aQEMN():\n",
        "scope": [
            [
                "Function Body",
                2,
                37
            ],
            [
                "Function Body",
                18,
                35
            ],
            [
                "List Comprehension",
                20,
                20
            ],
            [
                "For Loop Body",
                22,
                23
            ],
            [
                "For Loop Body",
                31,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef Wdcuo():\n    \"\"\"There are N people, conveniently numbered 1 through N.\nWe want to divide them into some number of groups, under the following two conditions:\n - Every group contains between A and B people, inclusive.\n - Let F_i be the number of the groups containing exactly i people. Then, for all i, either F_i=0 or C≤F_i≤D holds.\nFind the number of these ways to divide the people into groups.\nHere, two ways to divide them into groups is considered different if and only if there exists two people such that they belong to the same group in exactly one of the two ways.\nSince the number of these ways can be extremely large, print the count modulo 10^9+7.\n\n-----Constraints-----\n - 1≤N≤10^3\n - 1≤A≤B≤N\n - 1≤C≤D≤N\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN A B C D\n\n-----Output-----\nPrint the number of ways to divide the people into groups under the conditions, modulo 10^9+7.\n\n-----Sample Input-----\n3 1 3 1 2\n\n-----Sample Output-----\n4\n\nThere are four ways to divide the people:\n - (1,2),(3)\n - (1,3),(2)\n - (2,3),(1)\n - (1,2,3)\nThe following way to divide the people does not count: (1),(2),(3). This is because it only satisfies the first condition and not the second.\n    \"\"\"\n",
        "canonical_solution": "\ndef Wdcuo():\n    def main():\n        mod = 10**9+7\n        inv_n = [0]*1001\n        nCr = [[1]*(i+1) for i in range(1001)]\n        for i in range(1001):\n            inv_n[i] = pow(i, mod-2, mod)\n        for i in range(2, 1001):\n            for j in range(1, i):\n                nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j]) % mod\n        n, a, b, c, d = list(map(int, input().split()))\n        dp = [0]*(n+1)\n        dp[0] = 1\n    \n        for A in range(b, a-1, -1):\n            dp2 = [i for i in dp]\n            for N in range(n-c*A, -1, -1):\n                e = dp[N]\n                if e:\n                    temp = 1\n                    for C in range(1, c):\n                        temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                    for C in range(c, min(d, (n-N)//A)+1):\n                        temp = temp*nCr[n-N-(C-1)*A][A]*inv_n[C] % mod\n                        dp2[N+C*A] = (dp2[N+C*A]+temp*e) % mod\n            dp = dp2\n        print((dp[-1]))\n    \n    \n    main()\n    ",
        "inputs": [
            "3 1 3 1 2\n",
            "7 2 3 1 3\n",
            "1000 1 1000 1 1000\n"
        ],
        "outputs": [
            "4\n",
            "105\n",
            "465231251\n"
        ],
        "starter_code": "\ndef Wdcuo():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                3,
                28
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                9,
                11
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                16,
                27
            ],
            [
                "List Comprehension",
                17,
                17
            ],
            [
                "For Loop Body",
                18,
                26
            ],
            [
                "If Statement Body",
                20,
                26
            ],
            [
                "For Loop Body",
                22,
                23
            ],
            [
                "For Loop Body",
                24,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef XOUdT():\n    \"\"\"Iahub likes trees very much. Recently he discovered an interesting tree named propagating tree. The tree consists of n nodes numbered from 1 to n, each node i having an initial value a_{i}. The root of the tree is node 1.\n\nThis tree has a special property: when a value val is added to a value of node i, the value -val is added to values of all the children of node i. Note that when you add value -val to a child of node i, you also add -(-val) to all children of the child of node i and so on. Look an example explanation to understand better how it works.\n\nThis tree supports two types of queries:\n\n  \"1 x val\" — val is added to the value of node x;  \"2 x\" — print the current value of node x. \n\nIn order to help Iahub understand the tree better, you must answer m queries of the preceding type.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1000). Each of the next n–1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i}, u_{i} ≤ n), meaning that there is an edge between nodes v_{i} and u_{i}.\n\nEach of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.\n\n\n-----Output-----\n\nFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.\n\n\n-----Examples-----\nInput\n5 5\n1 2 1 1 2\n1 2\n1 3\n2 4\n2 5\n1 2 3\n1 1 2\n2 1\n2 2\n2 4\n\nOutput\n3\n3\n0\n\n\n\n-----Note-----\n\nThe values of the nodes are [1, 2, 1, 1, 2] at the beginning.\n\nThen value 3 is added to node 2. It propagates and value -3 is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So the values of the nodes are [1, 5, 1,  - 2,  - 1].\n\nThen value 2 is added to node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node 3 has no sons, so it cannot propagate from there. The values of the nodes are [3, 3,  - 1, 0, 1].\n\nYou can see all the definitions about the tree at the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)\n    \"\"\"\n",
        "canonical_solution": "from collections import deque\nimport sys\ndef XOUdT():\n    class BIT():\n        \"\"\"区間加算、一点取得クエリをそれぞれO(logN)で応えるデータ構造を構築する\n        add: 区間[begin, end)にvalを加える\n        get_val: i番目(0-indexed)の値を求める\n        \"\"\"\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 1)\n        def get_val(self, i):\n            i = i + 1\n            s = 0\n            while i <= self.n:\n                s += self.bit[i]\n                i += i & -i\n            return s\n        def _add(self, i, val):\n            while i > 0:\n                self.bit[i] += val\n                i -= i & -i\n        def add(self, i, j, val):\n            self._add(j, val)\n            self._add(i, -val)\n    input = sys.stdin.readline\n    def eular_tour(tree: list, root: int):\n        \"\"\"頂点に対するオイラーツアーを行う\n        posの部分木に区間[begin[pos], end[pos])が対応する\n        \"\"\"\n        n = len(tree)\n        res = []\n        begin = [-1] * n\n        end = [-1] * n\n        visited = [False] * n\n        visited[root] = True\n        q = deque([root])\n        while q:\n            pos = q.pop()\n            res.append(pos)\n            end[pos] = len(res)\n            if begin[pos] == -1:\n                begin[pos] = len(res) - 1\n            for next_pos in tree[pos]:\n                if visited[next_pos]:\n                    continue\n                else:\n                    visited[next_pos] = True\n                    q.append(pos)\n                    q.append(next_pos)\n        return res, begin, end\n    n, q = map(int, input().split())\n    init_cost = list(map(int, input().split()))\n    info = [list(map(int, input().split())) for i in range(n-1)]\n    query = [list(map(int, input().split())) for i in range(q)]\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = info[i]\n        a -= 1\n        b -= 1\n        tree[a].append(b)\n        tree[b].append(a)\n    res, begin, end = eular_tour(tree, 0)\n    even_res = []\n    odd_res = []\n    for i in range(len(res)):\n        if i % 2 == 0:\n            even_res.append(res[i])\n        else:\n            odd_res.append(res[i])\n    even_bit = BIT(len(even_res))\n    odd_bit = BIT(len(odd_res))\n    for i in range(q):\n        if query[i][0] == 1:\n            _, pos, cost = query[i]\n            pos -= 1\n            if begin[pos] % 2 == 0:\n                even_bit.add(begin[pos] // 2, (end[pos] + 1) // 2, cost)\n                odd_bit.add(begin[pos] // 2, end[pos] // 2, -cost)    \n            else:\n                odd_bit.add(begin[pos] // 2, end[pos] // 2, cost) \n                even_bit.add((begin[pos] + 1) // 2, end[pos] // 2, -cost) \n        else:\n            _, pos = query[i]\n            pos -= 1\n            if begin[pos] % 2 == 0:\n                ans = even_bit.get_val(begin[pos] // 2)\n            else:\n                ans = odd_bit.get_val(begin[pos] // 2)\n            print(ans + init_cost[pos])",
        "inputs": [
            "5 5\n1 2 1 1 2\n1 2\n1 3\n2 4\n2 5\n1 2 3\n1 1 2\n2 1\n2 2\n2 4\n",
            "10 10\n137 197 856 768 825 894 86 174 218 326\n7 8\n4 7\n8 9\n7 10\n1 2\n2 4\n3 6\n3 5\n2 3\n1 9 624\n2 1\n2 4\n1 6 505\n1 8 467\n1 3 643\n2 1\n1 8 631\n2 4\n1 7 244\n",
            "10 10\n418 45 865 869 745 901 177 773 854 462\n4 8\n1 4\n3 6\n1 5\n1 10\n5 9\n1 2\n4 7\n1 3\n2 2\n1 6 246\n1 4 296\n1 2 378\n1 8 648\n2 6\n1 5 288\n1 6 981\n1 2 868\n2 7\n"
        ],
        "outputs": [
            "3\n3\n0\n",
            "137\n768\n137\n768\n",
            "45\n1147\n-119\n"
        ],
        "starter_code": "\ndef XOUdT():\n",
        "scope": [
            [
                "Function Body",
                3,
                90
            ],
            [
                "Class Body",
                4,
                25
            ],
            [
                "Function Body",
                9,
                11
            ],
            [
                "Function Body",
                12,
                18
            ],
            [
                "While Loop Body",
                15,
                17
            ],
            [
                "Function Body",
                19,
                22
            ],
            [
                "While Loop Body",
                20,
                22
            ],
            [
                "Function Body",
                23,
                25
            ],
            [
                "Function Body",
                27,
                51
            ],
            [
                "While Loop Body",
                38,
                50
            ],
            [
                "If Statement Body",
                42,
                43
            ],
            [
                "For Loop Body",
                44,
                50
            ],
            [
                "If Statement Body",
                45,
                50
            ],
            [
                "List Comprehension",
                54,
                54
            ],
            [
                "List Comprehension",
                55,
                55
            ],
            [
                "List Comprehension",
                56,
                56
            ],
            [
                "For Loop Body",
                57,
                62
            ],
            [
                "For Loop Body",
                66,
                70
            ],
            [
                "If Statement Body",
                67,
                70
            ],
            [
                "For Loop Body",
                73,
                90
            ],
            [
                "If Statement Body",
                74,
                90
            ],
            [
                "If Statement Body",
                77,
                82
            ],
            [
                "If Statement Body",
                86,
                89
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef ZqVIF():\n    \"\"\"Barney lives in country USC (United States of Charzeh). USC has n cities numbered from 1 through n and n - 1 roads between them. Cities and roads of USC form a rooted tree (Barney's not sure why it is rooted). Root of the tree is the city number 1. Thus if one will start his journey from city 1, he can visit any city he wants by following roads.\n\n [Image] \n\nSome girl has stolen Barney's heart, and Barney wants to find her. He starts looking for in the root of the tree and (since he is Barney Stinson not a random guy), he uses a random DFS to search in the cities. A pseudo code of this algorithm is as follows:\n\n\n\nlet starting_time be an array of length n\n\ncurrent_time = 0\n\ndfs(v):\n\n        current_time = current_time + 1\n\n        starting_time[v] = current_time\n\n        shuffle children[v] randomly (each permutation with equal possibility)\n\n        // children[v] is vector of children cities of city v\n\n        for u in children[v]:\n\n                dfs(u)\n\n\n\nAs told before, Barney will start his journey in the root of the tree (equivalent to call dfs(1)).\n\nNow Barney needs to pack a backpack and so he wants to know more about his upcoming journey: for every city i, Barney wants to know the expected value of starting_time[i]. He's a friend of Jon Snow and knows nothing, that's why he asked for your help.\n\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 ≤ n ≤ 10^5) — the number of cities in USC.\n\nThe second line contains n - 1 integers p_2, p_3, ..., p_{n} (1 ≤ p_{i} < i), where p_{i} is the number of the parent city of city number i in the tree, meaning there is a road between cities numbered p_{i} and i in USC.\n\n\n-----Output-----\n\nIn the first and only line of output print n numbers, where i-th number is the expected value of starting_time[i].\n\nYour answer for each city will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n7\n1 2 1 1 4 4\n\nOutput\n1.0 4.0 5.0 3.5 4.5 5.0 5.0 \n\nInput\n12\n1 1 2 2 4 4 3 3 1 10 8\n\nOutput\n1.0 5.0 5.5 6.5 7.5 8.0 8.0 7.0 7.5 6.5 7.5 8.0\n    \"\"\"\n",
        "canonical_solution": "\ndef ZqVIF():\n    n = int(input())\n    pos,tree,ans,sz = list(map(int,input().split())) if n > 1 else [],[],[],[]\n    for i in range(n):\n      tree.append([])\n      ans.append(0.0)\n      sz.append(0)\n    \n    for i in range(n-1):\n      tree[pos[i]-1].append(i+1)\n    \n    for i in range(n)[::-1]:\n      sz[i] = 1\n      for to in tree[i]:\n        sz[i] += sz[to]\n    \n    for i in range(n):\n      for to in tree[i]:\n        ans[to] = ans[i] + 1 + (sz[i]-1-sz[to]) * 0.5\n    \n    st = lambda i: str(i+1)\n    print(' '.join(list(map(st,ans))))",
        "inputs": [
            "7\n1 2 1 1 4 4\n",
            "12\n1 1 2 2 4 4 3 3 1 10 8\n",
            "3\n1 2\n"
        ],
        "outputs": [
            "1.0 4.0 5.0 3.5 4.5 5.0 5.0 \n",
            "1.0 5.0 5.5 6.5 7.5 8.0 8.0 7.0 7.5 6.5 7.5 8.0 \n",
            "1.0 2.0 3.0 \n"
        ],
        "starter_code": "\ndef ZqVIF():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                13,
                16
            ],
            [
                "For Loop Body",
                15,
                16
            ],
            [
                "For Loop Body",
                18,
                20
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "Lambda Expression",
                22,
                22
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef ftzLi():\n    \"\"\"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:\n\n  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. \n\nOn each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).\n\nFind the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.\n\n\n-----Input-----\n\nThe first line contains a positive integer n (1 ≤ n ≤ 100) — the number of days of Vasya's vacations.\n\nThe second line contains the sequence of integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 3) separated by space, where: \n\n  a_{i} equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  a_{i} equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  a_{i} equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  a_{i} equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.\n\n\n-----Output-----\n\nPrint the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:\n\n  to do sport on any two consecutive days,  to write the contest on any two consecutive days. \n\n\n-----Examples-----\nInput\n4\n\n1 3 2 0\n\n\nOutput\n2\n\n\nInput\n7\n\n1 3 3 2 1 2 3\n\n\nOutput\n0\n\n\nInput\n2\n\n2 2\n\n\nOutput\n1\n\n\n\n\n-----Note-----\n\nIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.\n\nIn the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.\n\nIn the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef ftzLi():\n    inp = sys.stdin\n    #inp = open('input.txt', 'r')\n    n = int(inp.readline())\n    a = list(map(int, inp.readline().split()))\n    best = [0, 0, 0]\n    for i in range(n):\n        nx_best = [0, 0, 0]\n        if a[i] in (1, 3):\n            nx_best[1] = max(best[0], best[2]) + 1\n        if a[i] in (2, 3):\n            nx_best[2] = max(best[0], best[1]) + 1\n        nx_best[0] = max(best)\n        best = nx_best[:]\n    print(n - max(best))",
        "inputs": [
            "4\n1 3 2 0\n",
            "7\n1 3 3 2 1 2 3\n",
            "2\n2 2\n"
        ],
        "outputs": [
            "2\n",
            "0\n",
            "1\n"
        ],
        "starter_code": "\ndef ftzLi():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                8,
                15
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "If Statement Body",
                12,
                13
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef WyDVr():\n    \"\"\"Let N be a positive even number.\nWe have a permutation of (1, 2, ..., N), p = (p_1, p_2, ..., p_N).\nSnuke is constructing another permutation of (1, 2, ..., N), q, following the procedure below.\nFirst, let q be an empty sequence.\nThen, perform the following operation until p becomes empty:\n - Select two adjacent elements in p, and call them x and y in order. Remove x and y from p (reducing the length of p by 2), and insert x and y, preserving the original order, at the beginning of q.\nWhen p becomes empty, q will be a permutation of (1, 2, ..., N).\nFind the lexicographically smallest permutation that can be obtained as q.\n\n-----Constraints-----\n - N is an even number.\n - 2 ≤ N ≤ 2 × 10^5\n - p is a permutation of (1, 2, ..., N).\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\np_1 p_2 ... p_N\n\n-----Output-----\nPrint the lexicographically smallest permutation, with spaces in between.\n\n-----Sample Input-----\n4\n3 2 4 1\n\n-----Sample Output-----\n3 1 2 4\n\nThe solution above is obtained as follows:pq(3, 2, 4, 1)()↓↓(3, 1)(2, 4)↓↓()(3, 1, 2, 4)\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport numpy as np\nfrom heapq import heappush, heappop\ndef WyDVr():\n    input = sys.stdin.readline\n    N = int(input())\n    A = np.array(input().split(), dtype=np.int32)\n    a_to_i = {a:i for i,a in enumerate(A)}\n    # sparse table を使ってRMQ\n    # parityの同じところだけを見るようにしておく\n    U = len(A).bit_length()\n    sp = [None,A]\n    for i in range(2,U):\n        L = 1 << (i-1)\n        sp.append(np.minimum(sp[-1][:-L], sp[-1][L:]))\n    def RMQ(x,y):\n        # x番目から偶数番目だけ見て[x,y]での最小値を返す\n        d = y - x\n        if d <= 1:\n            return A[x]\n        n = d.bit_length()\n        return min(sp[n-1][x], sp[n-1][y+2-(1<<(n-1))])\n    def F(x,y):\n        # 辞書式で最小の2つ組をとる\n        # そのあと、今後調べないといけない区間の一覧を返す\n        x1 = RMQ(x,y-1)\n        i1 = a_to_i[x1]\n        x2 = RMQ(i1+1,y)\n        i2 = a_to_i[x2]\n        task = ((x,y) for x,y in ((x,i1-1), (i1+1,i2-1), (i2+1,y)) if y > x)\n        return x1,x2,task\n    q = [(None,None,((0,N-1),))]\n    answer = []\n    while q:\n        x,y,task = heappop(q)\n        answer.append(x)\n        answer.append(y)\n        for left,right in task:\n            heappush(q,F(left,right))\n    print(' '.join(map(str,answer[2:])))",
        "inputs": [
            "4\n3 2 4 1\n",
            "2\n1 2\n",
            "8\n4 6 3 2 8 5 7 1\n"
        ],
        "outputs": [
            "3 1 2 4\n",
            "1 2\n",
            "3 1 2 7 4 6 8 5\n"
        ],
        "starter_code": "\ndef WyDVr():\n",
        "scope": [
            [
                "Function Body",
                4,
                40
            ],
            [
                "Dict Comprehension",
                8,
                8
            ],
            [
                "For Loop Body",
                13,
                15
            ],
            [
                "Function Body",
                16,
                22
            ],
            [
                "If Statement Body",
                19,
                20
            ],
            [
                "Function Body",
                23,
                31
            ],
            [
                "Generator Expression",
                30,
                30
            ],
            [
                "While Loop Body",
                34,
                39
            ],
            [
                "For Loop Body",
                38,
                39
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef QJMHf():\n    \"\"\"Æsir - CHAOS Æsir - V.\n\n\"Everything has been planned out. No more hidden concerns. The condition of Cytus is also perfect.\n\nThe time right now...... 00:01:12......\n\nIt's time.\"\n\nThe emotion samples are now sufficient. After almost 3 years, it's time for Ivy to awake her bonded sister, Vanessa.\n\nThe system inside A.R.C.'s Library core can be considered as an undirected graph with infinite number of processing nodes, numbered with all positive integers ($1, 2, 3, \\ldots$). The node with a number $x$ ($x > 1$), is directly connected with a node with number $\\frac{x}{f(x)}$, with $f(x)$ being the lowest prime divisor of $x$.\n\nVanessa's mind is divided into $n$ fragments. Due to more than 500 years of coma, the fragments have been scattered: the $i$-th fragment is now located at the node with a number $k_i!$ (a factorial of $k_i$).\n\nTo maximize the chance of successful awakening, Ivy decides to place the samples in a node $P$, so that the total length of paths from each fragment to $P$ is smallest possible. If there are multiple fragments located at the same node, the path from that node to $P$ needs to be counted multiple times.\n\nIn the world of zeros and ones, such a requirement is very simple for Ivy. Not longer than a second later, she has already figured out such a node.\n\nBut for a mere human like you, is this still possible?\n\nFor simplicity, please answer the minimal sum of paths' lengths from every fragment to the emotion samples' assembly node $P$.\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$) — number of fragments of Vanessa's mind.\n\nThe second line contains $n$ integers: $k_1, k_2, \\ldots, k_n$ ($0 \\le k_i \\le 5000$), denoting the nodes where fragments of Vanessa's mind are located: the $i$-th fragment is at the node with a number $k_i!$.\n\n\n-----Output-----\n\nPrint a single integer, denoting the minimal sum of path from every fragment to the node with the emotion samples (a.k.a. node $P$).\n\nAs a reminder, if there are multiple fragments at the same node, the distance from that node to $P$ needs to be counted multiple times as well.\n\n\n-----Examples-----\nInput\n3\n2 1 4\n\nOutput\n5\n\nInput\n4\n3 1 4 4\n\nOutput\n6\n\nInput\n4\n3 1 4 1\n\nOutput\n6\n\nInput\n5\n3 1 4 1 5\n\nOutput\n11\n\n\n\n-----Note-----\n\nConsidering the first $24$ nodes of the system, the node network will look as follows (the nodes $1!$, $2!$, $3!$, $4!$ are drawn bold):\n\n[Image]\n\nFor the first example, Ivy will place the emotion samples at the node $1$. From here:\n\n  The distance from Vanessa's first fragment to the node $1$ is $1$.  The distance from Vanessa's second fragment to the node $1$ is $0$.  The distance from Vanessa's third fragment to the node $1$ is $4$. \n\nThe total length is $5$.\n\nFor the second example, the assembly node will be $6$. From here:\n\n  The distance from Vanessa's first fragment to the node $6$ is $0$.  The distance from Vanessa's second fragment to the node $6$ is $2$.  The distance from Vanessa's third fragment to the node $6$ is $2$.  The distance from Vanessa's fourth fragment to the node $6$ is again $2$. \n\nThe total path length is $6$.\n    \"\"\"\n",
        "canonical_solution": "\ndef QJMHf():\n    T = 1\n    for test_no in range(T):\n    \tMAXK = 5000\n    \tn = int(input())\n    \tcnt = [0] * (MAXK + 1)\n    \tprimeExponential = [[0 for j in range(MAXK + 1)] for i in range(MAXK + 1)]\n    \n    \tline, num = (input() + ' '), 0\n    \tfor c in line:\n    \t\tif c != ' ': num = num * 10 + (ord(c) - 48)\n    \t\telse:\n    \t\t\tcnt[num] += 1\n    \t\t\tnum = 0\n    \n    \tfor i in range(2, MAXK + 1):\n    \t\tfor j in range(0, MAXK + 1): primeExponential[i][j] += primeExponential[i-1][j]\n    \t\ttmp, x = i, 2\n    \t\twhile x * x <= tmp:\n    \t\t\twhile tmp % x == 0:\n    \t\t\t\tprimeExponential[i][x] += 1\n    \t\t\t\ttmp //= x\n    \t\t\tx += 1\n    \t\tif tmp > 1: primeExponential[i][tmp] += 1\n    \n    \tbestPD = [1] * (MAXK + 1)\n    \tans, cur = 0, 0\n    \n    \tfor i in range(1, MAXK + 1):\n    \t\tif cnt[i] == 0: continue\n    \t\tfor j in range(1, MAXK + 1):\n    \t\t\tans += primeExponential[i][j] * cnt[i]\n    \t\t\tcur += primeExponential[i][j] * cnt[i]\n    \t\t\tif primeExponential[i][j]: bestPD[i] = j\n    \n    \tfrequency = [0] * (MAXK + 1)\n    \twhile max(bestPD) > 1:\n    \t\tfor i in range(MAXK + 1): frequency[i] = 0\n    \t\tfor i in range(MAXK + 1): frequency[bestPD[i]] += cnt[i]\n    \n    \t\tbestGroup = max(frequency)\n    \t\tbestPrime = frequency.index(bestGroup)\n    \t\tif bestGroup * 2 <= n: break\n    \t\tif bestPrime == 1: break\n    \t\tcur -= bestGroup\n    \t\tcur += (n - bestGroup); ans = min(ans, cur)\n    \n    \t\tfor i in range(MAXK + 1):\n    \t\t\tif bestPD[i] != bestPrime: bestPD[i] = 1\n    \t\t\tif bestPD[i] == 1: continue\n    \t\t\tprimeExponential[i][bestPD[i]] -= 1\n    \t\t\twhile bestPD[i] > 1 and primeExponential[i][bestPD[i]] == 0: bestPD[i] -= 1\n    \n    \tprint(ans)",
        "inputs": [
            "3\n2 1 4\n",
            "4\n3 1 4 4\n",
            "4\n3 1 4 1\n"
        ],
        "outputs": [
            "5\n",
            "6\n",
            "6\n"
        ],
        "starter_code": "\ndef QJMHf():\n",
        "scope": [
            [
                "Function Body",
                2,
                55
            ],
            [
                "For Loop Body",
                4,
                55
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "For Loop Body",
                11,
                15
            ],
            [
                "If Statement Body",
                12,
                15
            ],
            [
                "For Loop Body",
                17,
                25
            ],
            [
                "For Loop Body",
                18,
                18
            ],
            [
                "While Loop Body",
                20,
                24
            ],
            [
                "While Loop Body",
                21,
                23
            ],
            [
                "If Statement Body",
                25,
                25
            ],
            [
                "For Loop Body",
                30,
                35
            ],
            [
                "If Statement Body",
                31,
                31
            ],
            [
                "For Loop Body",
                32,
                35
            ],
            [
                "If Statement Body",
                35,
                35
            ],
            [
                "While Loop Body",
                38,
                53
            ],
            [
                "For Loop Body",
                39,
                39
            ],
            [
                "For Loop Body",
                40,
                40
            ],
            [
                "If Statement Body",
                44,
                44
            ],
            [
                "If Statement Body",
                45,
                45
            ],
            [
                "For Loop Body",
                49,
                53
            ],
            [
                "If Statement Body",
                50,
                50
            ],
            [
                "If Statement Body",
                51,
                51
            ],
            [
                "While Loop Body",
                53,
                53
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef IdpYA():\n    \"\"\"A team of furry rescue rangers was sitting idle in their hollow tree when suddenly they received a signal of distress. In a few moments they were ready, and the dirigible of the rescue chipmunks hit the road.\n\nWe assume that the action takes place on a Cartesian plane. The headquarters of the rescuers is located at point (x_1, y_1), and the distress signal came from the point (x_2, y_2).\n\nDue to Gadget's engineering talent, the rescuers' dirigible can instantly change its current velocity and direction of movement at any moment and as many times as needed. The only limitation is: the speed of the aircraft relative to the air can not exceed $v_{\\operatorname{max}}$ meters per second.\n\nOf course, Gadget is a true rescuer and wants to reach the destination as soon as possible. The matter is complicated by the fact that the wind is blowing in the air and it affects the movement of the dirigible. According to the weather forecast, the wind will be defined by the vector (v_{x}, v_{y}) for the nearest t seconds, and then will change to (w_{x}, w_{y}). These vectors give both the direction and velocity of the wind. Formally, if a dirigible is located at the point (x, y), while its own velocity relative to the air is equal to zero and the wind (u_{x}, u_{y}) is blowing, then after $T$ seconds the new position of the dirigible will be $(x + \\tau \\cdot u_{x}, y + \\tau \\cdot u_{y})$.\n\nGadget is busy piloting the aircraft, so she asked Chip to calculate how long will it take them to reach the destination if they fly optimally. He coped with the task easily, but Dale is convinced that Chip has given the random value, aiming only not to lose the face in front of Gadget. Dale has asked you to find the right answer.\n\nIt is guaranteed that the speed of the wind at any moment of time is strictly less than the maximum possible speed of the airship relative to the air.\n\n\n-----Input-----\n\nThe first line of the input contains four integers x_1, y_1, x_2, y_2 (|x_1|,  |y_1|,  |x_2|,  |y_2| ≤ 10 000) — the coordinates of the rescuers' headquarters and the point, where signal of the distress came from, respectively. \n\nThe second line contains two integers $v_{\\operatorname{max}}$ and t (0 < v, t ≤ 1000), which are denoting the maximum speed of the chipmunk dirigible relative to the air and the moment of time when the wind changes according to the weather forecast, respectively. \n\nNext follow one per line two pairs of integer (v_{x}, v_{y}) and (w_{x}, w_{y}), describing the wind for the first t seconds and the wind that will blow at all the remaining time, respectively. It is guaranteed that $v_{x}^{2} + v_{y}^{2} < v_{\\operatorname{max}}^{2}$ and $w_{x}^{2} + w_{y}^{2} < v_{\\operatorname{max}}^{2}$.\n\n\n-----Output-----\n\nPrint a single real value — the minimum time the rescuers need to get to point (x_2, y_2). You answer will be considered correct if its absolute or relative error does not exceed 10^{ - 6}. \n\nNamely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n\n-----Examples-----\nInput\n0 0 5 5\n3 2\n-1 -1\n-1 0\n\nOutput\n3.729935587093555327\n\nInput\n0 0 0 1000\n100 1000\n-50 0\n50 0\n\nOutput\n11.547005383792516398\n    \"\"\"\n",
        "canonical_solution": "import math\ndef IdpYA():\n    x1, y1, x2, y2 = list(map(int, input().split(' ')[:4]))\n    u_max, tau = list(map(int, input().split(' ')[:2]))\n    vx, vy = list(map(int, input().split(' ')[:2]))\n    wx, wy = list(map(int, input().split(' ')[:2]))\n    A = (x2 - x1, y2 - y1)\n    v = (-vx, -vy)\n    w = (-wx, -wy)\n    B = (A[0] + tau * v[0], A[1] + tau * v[1])\n    def solve_sqr_eq(a, b, c):\n        d = b**2 - 4*a*c\n        if d >= 0:\n            return ((-b + math.sqrt(d)) / (2*a), (-b - math.sqrt(d)) / (2*a))\n        else:\n            return None\n    a = v[0]**2 + v[1]**2 - u_max**2\n    b = 2 * A[0] * v[0] + 2 * A[1] * v[1]\n    c = A[0]**2 + A[1]**2\n    r = solve_sqr_eq(a, b, c)\n    if r is not None:\n        t1, t2 = r\n        t_min = min(t1, t2)\n        t_max = max(t1, t2)\n        if 0 <= t_min <= tau:\n            print(t_min)\n            return\n        if 0 <= t_max <= tau:\n            print(t_max)\n            return\n    a = w[0]**2 + w[1]**2 - u_max**2\n    b = 2 * B[0] * w[0] + 2 * B[1] * w[1] - u_max**2 * 2 * tau\n    c = B[0]**2 + B[1]**2 - u_max**2 * tau**2\n    r = solve_sqr_eq(a, b, c)\n    if r is not None:\n        t1, t2 = r\n        t_min = min(t1, t2)\n        t_max = max(t1, t2)\n        if 0 <= t_min :\n            print(t_min + tau)\n            return\n        if 0 <= t_max:\n            print(t_max + tau)\n            return",
        "inputs": [
            "0 0 5 5\n3 2\n-1 -1\n-1 0\n",
            "0 0 0 1000\n100 1000\n-50 0\n50 0\n",
            "0 0 0 1000\n100 5\n0 -50\n0 50\n"
        ],
        "outputs": [
            "3.7299355870935553\n",
            "11.547005383792516\n",
            "10.0\n"
        ],
        "starter_code": "\ndef IdpYA():\n",
        "scope": [
            [
                "Function Body",
                2,
                44
            ],
            [
                "Function Body",
                11,
                16
            ],
            [
                "If Statement Body",
                13,
                16
            ],
            [
                "If Statement Body",
                21,
                30
            ],
            [
                "If Statement Body",
                25,
                27
            ],
            [
                "If Statement Body",
                28,
                30
            ],
            [
                "If Statement Body",
                35,
                44
            ],
            [
                "If Statement Body",
                39,
                41
            ],
            [
                "If Statement Body",
                42,
                44
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef AQmCE():\n    \"\"\"Let's introduce a number system which is based on a roman digits. There are digits I, V, X, L which correspond to the numbers $1$, $5$, $10$ and $50$ respectively. The use of other roman digits is not allowed.\n\nNumbers in this system are written as a sequence of one or more digits. We define the value of the sequence simply as the sum of digits in it.\n\nFor example, the number XXXV evaluates to $35$ and the number IXI — to $12$.\n\nPay attention to the difference to the traditional roman system — in our system any sequence of digits is valid, moreover the order of digits doesn't matter, for example IX means $11$, not $9$.\n\nOne can notice that this system is ambiguous, and some numbers can be written in many different ways. Your goal is to determine how many distinct integers can be represented by exactly $n$ roman digits I, V, X, L.\n\n\n-----Input-----\n\nThe only line of the input file contains a single integer $n$ ($1 \\le n \\le 10^9$) — the number of roman digits to use.\n\n\n-----Output-----\n\nOutput a single integer — the number of distinct integers which can be represented using $n$ roman digits exactly.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n4\n\nInput\n2\n\nOutput\n10\n\nInput\n10\n\nOutput\n244\n\n\n\n-----Note-----\n\nIn the first sample there are exactly $4$ integers which can be represented — I, V, X and L.\n\nIn the second sample it is possible to represent integers $2$ (II), $6$ (VI), $10$ (VV), $11$ (XI), $15$ (XV), $20$ (XX), $51$ (IL), $55$ (VL), $60$ (XL) and $100$ (LL).\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef AQmCE():\n    # add 0,4,9,49\n    # this is a stupid solution\n    #sys.stdin=open(\"data.txt\")\n    input=sys.stdin.readline\n    n=int(input())\n    # do a stupid approach\n    dp=[0]*150\n    s=set([0])\n    for i in range(150):\n        dp[i]=len(s)\n        s2=set(s)\n        for j in s:\n            s2.add(j+4)\n            s2.add(j+9)\n            s2.add(j+49)\n        s=s2\n    if 0:\n        for i in range(100):\n            if dp[i+49]-dp[i]!=2401:\n                print(i)\n    if n<150: print(dp[n])\n    else:\n        stuff=(n//49)\n        while n-stuff*49+49<150: stuff-=1\n        print(dp[n-stuff*49]+2401*stuff)",
        "inputs": [
            "1\n",
            "2\n",
            "10\n"
        ],
        "outputs": [
            "4\n",
            "10\n",
            "244\n"
        ],
        "starter_code": "\ndef AQmCE():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "For Loop Body",
                11,
                18
            ],
            [
                "For Loop Body",
                14,
                17
            ],
            [
                "If Statement Body",
                19,
                22
            ],
            [
                "For Loop Body",
                20,
                22
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "If Statement Body",
                23,
                27
            ],
            [
                "While Loop Body",
                26,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef emhqF():\n    \"\"\"Sereja loves number sequences very much. That's why he decided to make himself a new one following a certain algorithm.\n\nSereja takes a blank piece of paper. Then he starts writing out the sequence in m stages. Each time he either adds a new number to the end of the sequence or takes l first elements of the current sequence and adds them c times to the end. More formally, if we represent the current sequence as a_1, a_2, ..., a_{n}, then after we apply the described operation, the sequence transforms into a_1, a_2, ..., a_{n}[, a_1, a_2, ..., a_{l}] (the block in the square brackets must be repeated c times). \n\nA day has passed and Sereja has completed the sequence. He wonders what are the values of some of its elements. Help Sereja.\n\n\n-----Input-----\n\nThe first line contains integer m (1 ≤ m ≤ 10^5) — the number of stages to build a sequence. \n\nNext m lines contain the description of the stages in the order they follow. The first number in the line is a type of stage (1 or 2). Type 1 means adding one number to the end of the sequence, in this case the line contains integer x_{i} (1 ≤ x_{i} ≤ 10^5) — the number to add. Type 2 means copying a prefix of length l_{i} to the end c_{i} times, in this case the line further contains two integers l_{i}, c_{i} (1 ≤ l_{i} ≤ 10^5, 1 ≤ c_{i} ≤ 10^4), l_{i} is the length of the prefix, c_{i} is the number of copyings. It is guaranteed that the length of prefix l_{i} is never larger than the current length of the sequence.\n\nThe next line contains integer n (1 ≤ n ≤ 10^5) — the number of elements Sereja is interested in. The next line contains the numbers of elements of the final sequence Sereja is interested in. The numbers are given in the strictly increasing order. It is guaranteed that all numbers are strictly larger than zero and do not exceed the length of the resulting sequence. Consider the elements of the final sequence numbered starting from 1 from the beginning to the end of the sequence.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint the elements that Sereja is interested in, in the order in which their numbers occur in the input. \n\n\n-----Examples-----\nInput\n6\n1 1\n1 2\n2 2 1\n1 3\n2 5 2\n1 4\n16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nOutput\n1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4\n    \"\"\"\n",
        "canonical_solution": "\ndef emhqF():\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,input().split())))\n    m=int(input())\n    b=list(map(lambda x:int(x)-1,input().split()))\n    c=[]\n    now=0\n    k=0\n    ans=[]\n    for i in range(n):\n        t=a[i]\n        last=now\n        if t[0]==1:\n            now+=1\n            if len(c)<100000: c.append(t[1])\n            if k<m and b[k]==now-1: \n                ans.append(t[1])\n                k+=1\n        else:\n            now+=t[1]*t[2]\n            while t[2]:\n                if len(c)<100000: c.extend(c[:t[1]])\n                else: break\n                t[2]-=1\n            while k<m and last<=b[k]<now:\n                ans.append(c[(b[k]-last)%t[1]])\n                k+=1    \n    for i in range(m):\n        print(ans[i],end=' ')\n    ",
        "inputs": [
            "6\n1 1\n1 2\n2 2 1\n1 3\n2 5 2\n1 4\n16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n",
            "2\n1 33085\n1 44638\n2\n1 2\n",
            "10\n1 57757\n1 45234\n1 80807\n1 38496\n1 27469\n1 42645\n1 72643\n1 33235\n1 10843\n1 80598\n10\n1 2 3 4 5 6 7 8 9 10\n"
        ],
        "outputs": [
            "1 2 1 2 3 1 2 1 2 3 1 2 1 2 3 4\n",
            "33085 44638\n",
            "57757 45234 80807 38496 27469 42645 72643 33235 10843 80598\n"
        ],
        "starter_code": "\ndef emhqF():\n",
        "scope": [
            [
                "Function Body",
                2,
                32
            ],
            [
                "For Loop Body",
                5,
                6
            ],
            [
                "Lambda Expression",
                8,
                8
            ],
            [
                "For Loop Body",
                13,
                30
            ],
            [
                "If Statement Body",
                16,
                30
            ],
            [
                "If Statement Body",
                18,
                18
            ],
            [
                "If Statement Body",
                19,
                21
            ],
            [
                "While Loop Body",
                24,
                27
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "While Loop Body",
                28,
                30
            ],
            [
                "For Loop Body",
                31,
                32
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef bsKAi():\n    \"\"\"Codefortia is a small island country located somewhere in the West Pacific. It consists of $n$ settlements connected by $m$ bidirectional gravel roads. Curiously enough, the beliefs of the inhabitants require the time needed to pass each road to be equal either to $a$ or $b$ seconds. It's guaranteed that one can go between any pair of settlements by following a sequence of roads.\n\nCodefortia was recently struck by the financial crisis. Therefore, the king decided to abandon some of the roads so that:\n\n  it will be possible to travel between each pair of cities using the remaining roads only,  the sum of times required to pass each remaining road will be minimum possible (in other words, remaining roads must form minimum spanning tree, using the time to pass the road as its weight),  among all the plans minimizing the sum of times above, the time required to travel between the king's residence (in settlement $1$) and the parliament house (in settlement $p$) using the remaining roads only will be minimum possible. \n\nThe king, however, forgot where the parliament house was. For each settlement $p = 1, 2, \\dots, n$, can you tell what is the minimum time required to travel between the king's residence and the parliament house (located in settlement $p$) after some roads are abandoned?\n\n\n-----Input-----\n\nThe first line of the input contains four integers $n$, $m$, $a$ and $b$ ($2 \\leq n \\leq 70$, $n - 1 \\leq m \\leq 200$, $1 \\leq a < b \\leq 10^7$) — the number of settlements and gravel roads in Codefortia, and two possible travel times. Each of the following lines contains three integers $u, v, c$ ($1 \\leq u, v \\leq n$, $u \\neq v$, $c \\in \\{a, b\\}$) denoting a single gravel road between the settlements $u$ and $v$, which requires $c$ minutes to travel.\n\nYou can assume that the road network is connected and has no loops or multiedges.\n\n\n-----Output-----\n\nOutput a single line containing $n$ integers. The $p$-th of them should denote the minimum possible time required to travel from $1$ to $p$ after the selected roads are abandoned. Note that for each $p$ you can abandon a different set of roads.\n\n\n-----Examples-----\nInput\n5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n\nOutput\n0 25 60 40 20\n\nInput\n6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n\nOutput\n0 13 26 39 26 13\n\n\n\n-----Note-----\n\nThe minimum possible sum of times required to pass each road in the first example is $85$ — exactly one of the roads with passing time $25$ must be abandoned. Note that after one of these roads is abandoned, it's now impossible to travel between settlements $1$ and $3$ in time $50$.\n    \"\"\"\n",
        "canonical_solution": "import heapq\ndef bsKAi():\n    n,m,a,b=map(int,input().split())\n    graph={i:[] for i in range(n)}\n    for i in range(m):\n        u,v,w=map(int,input().split())\n        graph[u-1].append((v-1,w))\n        graph[v-1].append((u-1,w))\n    components=[-1]*n\n    comp=-1\n    for i in range(n):\n        if components[i]==-1:\n            comp+=1\n            components[i]=comp\n            prev=[]\n            layer=[i]\n            while layer!=[]:\n                newlayer=[]\n                for guy in layer:\n                    for guy1 in graph[guy]:\n                        if guy1[1]==a and components[guy1[0]]==-1:\n                            newlayer.append(guy1[0])\n                            components[guy1[0]]=comp\n                prev=layer[:]\n                layer=newlayer[:]\n    useless=[]\n    for guy in graph:\n        for neigh in graph[guy]:\n            if components[guy]==components[neigh[0]] and neigh[1]==b:\n                useless.append((guy,neigh))\n    for guy in useless:\n        graph[guy[0]].remove(guy[1])\n    counts=[0]*(comp+1)\n    for i in range(n):\n        counts[components[i]]+=1\n    bad=[]\n    for i in range(comp+1):\n        if counts[i]<=3:\n            bad.append(i)\n            for j in range(n):\n                if components[j]==i:\n                    components[j]=-1\n    for guy in bad[::-1]:\n        for i in range(n):\n            if components[i]>guy:\n                components[i]-=1\n    comp-=len(bad)\n    comp+=1\n    dists=[[float(\"inf\") for i in range(2**comp)] for j in range(n)]\n    dists[0][0]=0\n    pq=[]\n    heapq.heappush(pq,[0,0,0])\n    remaining=n\n    visited=[0]*n\n    while len(pq)>0 and remaining>0:\n        dist,vert,mask=heapq.heappop(pq)\n        if visited[vert]==0:\n            visited[vert]=1\n            remaining-=1\n        for neigh in graph[vert]:\n            if neigh[1]==b:\n                if components[vert]==components[neigh[0]] and components[vert]!=-1:\n                    continue\n                if components[neigh[0]]!=-1:\n                    if mask & (2**components[neigh[0]])>0:\n                        continue\n                if components[vert]!=-1:\n                    maskn=mask+2**(components[vert])\n                else:\n                    maskn=mask\n            else:\n                maskn=mask\n            if dist+neigh[1]<dists[neigh[0]][maskn]:\n                dists[neigh[0]][maskn]=dist+neigh[1]\n                heapq.heappush(pq,[dist+neigh[1],neigh[0],maskn])\n    optimal=[str(min(dists[i])) for i in range(n)]\n    print(\" \".join(optimal))",
        "inputs": [
            "5 5 20 25\n1 2 25\n2 3 25\n3 4 20\n4 5 20\n5 1 20\n",
            "6 7 13 22\n1 2 13\n2 3 13\n1 4 22\n3 4 13\n4 5 13\n5 6 13\n6 1 13\n",
            "2 1 1 2\n2 1 1\n"
        ],
        "outputs": [
            "0 25 60 40 20\n",
            "0 13 26 39 26 13\n",
            "0 1\n"
        ],
        "starter_code": "\ndef bsKAi():\n",
        "scope": [
            [
                "Function Body",
                2,
                77
            ],
            [
                "Dict Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "For Loop Body",
                11,
                25
            ],
            [
                "If Statement Body",
                12,
                25
            ],
            [
                "While Loop Body",
                17,
                25
            ],
            [
                "For Loop Body",
                19,
                23
            ],
            [
                "For Loop Body",
                20,
                23
            ],
            [
                "If Statement Body",
                21,
                23
            ],
            [
                "For Loop Body",
                27,
                30
            ],
            [
                "For Loop Body",
                28,
                30
            ],
            [
                "If Statement Body",
                29,
                30
            ],
            [
                "For Loop Body",
                31,
                32
            ],
            [
                "For Loop Body",
                34,
                35
            ],
            [
                "For Loop Body",
                37,
                42
            ],
            [
                "If Statement Body",
                38,
                42
            ],
            [
                "For Loop Body",
                40,
                42
            ],
            [
                "If Statement Body",
                41,
                42
            ],
            [
                "For Loop Body",
                43,
                46
            ],
            [
                "For Loop Body",
                44,
                46
            ],
            [
                "If Statement Body",
                45,
                46
            ],
            [
                "List Comprehension",
                49,
                49
            ],
            [
                "List Comprehension",
                49,
                49
            ],
            [
                "While Loop Body",
                55,
                75
            ],
            [
                "If Statement Body",
                57,
                59
            ],
            [
                "For Loop Body",
                60,
                75
            ],
            [
                "If Statement Body",
                61,
                72
            ],
            [
                "If Statement Body",
                62,
                63
            ],
            [
                "If Statement Body",
                64,
                66
            ],
            [
                "If Statement Body",
                65,
                66
            ],
            [
                "If Statement Body",
                67,
                70
            ],
            [
                "If Statement Body",
                73,
                75
            ],
            [
                "List Comprehension",
                76,
                76
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef LMDdJ():\n    \"\"\"Iahub got lost in a very big desert. The desert can be represented as a n × n square matrix, where each cell is a zone of the desert. The cell (i, j) represents the cell at row i and column j (1 ≤ i, j ≤ n). Iahub can go from one cell (i, j) only down or right, that is to cells (i + 1, j) or (i, j + 1). \n\nAlso, there are m cells that are occupied by volcanoes, which Iahub cannot enter. \n\nIahub is initially at cell (1, 1) and he needs to travel to cell (n, n). Knowing that Iahub needs 1 second to travel from one cell to another, find the minimum time in which he can arrive in cell (n, n).\n\n\n-----Input-----\n\nThe first line contains two integers n (1 ≤ n ≤ 10^9) and m (1 ≤ m ≤ 10^5). Each of the next m lines contains a pair of integers, x and y (1 ≤ x, y ≤ n), representing the coordinates of the volcanoes.\n\nConsider matrix rows are numbered from 1 to n from top to bottom, and matrix columns are numbered from 1 to n from left to right. There is no volcano in cell (1, 1). No two volcanoes occupy the same location. \n\n\n-----Output-----\n\nPrint one integer, the minimum time in which Iahub can arrive at cell (n, n). If no solution exists (there is no path to the final cell), print -1.\n\n\n-----Examples-----\nInput\n4 2\n1 3\n1 4\n\nOutput\n6\n\nInput\n7 8\n1 6\n2 6\n3 5\n3 6\n4 3\n5 1\n5 2\n5 3\n\nOutput\n12\n\nInput\n2 2\n1 2\n2 1\n\nOutput\n-1\n\n\n\n-----Note-----\n\nConsider the first sample. A possible road is: (1, 1)  →  (1, 2)  →  (2, 2)  →  (2, 3)  →  (3, 3)  →  (3, 4)  →  (4, 4).\n    \"\"\"\n",
        "canonical_solution": "\ndef LMDdJ():\n    __author__ = 'Pavel Mavrin'\n    \n    n, m = [int(x) for x in input().split()]\n    a = []\n    for i in range(m):\n        a.append([int(x) - 1 for x in input().split()])\n    \n    a.sort(key=lambda x: x[0] * n + x[1])\n    a.append([n - 1, n])\n    \n    d = [[0, 1]]\n    r = 0\n    i = 0\n    while i < len(a):\n        if a[i][0] == r:\n            dd = []\n            j = 0\n            while i < len(a) and a[i][0] == r and j < len(d):\n                if a[i][1] < d[j][0]:\n                    i += 1\n                elif a[i][1] == d[j][0]:\n                    d[j][0] += 1\n                    if d[j][0] >= d[j][1]:\n                        j += 1\n                    i += 1\n                else:\n                    dd.append([d[j][0], a[i][1]])\n                    d[j][0] = a[i][1] + 1\n                    while j < len(d) and d[j][1] <= a[i][1] + 1:\n                        j += 1\n                    if j < len(d):\n                        d[j][0] = max(d[j][0], a[i][1] + 1)\n            if j < len(d):\n                dd.append([d[j][0], n])\n            while i < len(a) and (a[i][0] == r):\n                i += 1\n            d = dd\n            r += 1\n            if len(d) == 0:\n                break\n        else:\n            r = a[i][0]\n            d = [[d[0][0], n]]\n        #print(r, i, d)\n    \n    if len(d) == 0 or d[len(d) - 1][1] < n:\n        print(-1)\n    else:\n        print(2 * (n - 1))\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
        "inputs": [
            "4 2\n1 3\n1 4\n",
            "7 8\n1 6\n2 6\n3 5\n3 6\n4 3\n5 1\n5 2\n5 3\n",
            "2 2\n1 2\n2 1\n"
        ],
        "outputs": [
            "6\n",
            "12\n",
            "-1\n"
        ],
        "starter_code": "\ndef LMDdJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                51
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "Lambda Expression",
                10,
                10
            ],
            [
                "While Loop Body",
                16,
                45
            ],
            [
                "If Statement Body",
                17,
                45
            ],
            [
                "While Loop Body",
                20,
                34
            ],
            [
                "If Statement Body",
                21,
                34
            ],
            [
                "If Statement Body",
                23,
                34
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "While Loop Body",
                31,
                32
            ],
            [
                "If Statement Body",
                33,
                34
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "While Loop Body",
                37,
                38
            ],
            [
                "If Statement Body",
                41,
                42
            ],
            [
                "If Statement Body",
                48,
                51
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef mpDTo():\n    \"\"\"There is an automatic door at the entrance of a factory. The door works in the following way:  when one or several people come to the door and it is closed, the door immediately opens automatically and all people immediately come inside,  when one or several people come to the door and it is open, all people immediately come inside,  opened door immediately closes in d seconds after its opening,  if the door is closing and one or several people are coming to the door at the same moment, then all of them will have enough time to enter and only after that the door will close. \n\nFor example, if d = 3 and four people are coming at four different moments of time t_1 = 4, t_2 = 7, t_3 = 9 and t_4 = 13 then the door will open three times: at moments 4, 9 and 13. It will close at moments 7 and 12.\n\nIt is known that n employees will enter at moments a, 2·a, 3·a, ..., n·a (the value a is positive integer). Also m clients will enter at moments t_1, t_2, ..., t_{m}.\n\nWrite program to find the number of times the automatic door will open. Assume that the door is initially closed.\n\n\n-----Input-----\n\nThe first line contains four integers n, m, a and d (1 ≤ n, a ≤ 10^9, 1 ≤ m ≤ 10^5, 1 ≤ d ≤ 10^18) — the number of the employees, the number of the clients, the moment of time when the first employee will come and the period of time in which the door closes.\n\nThe second line contains integer sequence t_1, t_2, ..., t_{m} (1 ≤ t_{i} ≤ 10^18) — moments of time when clients will come. The values t_{i} are given in non-decreasing order.\n\n\n-----Output-----\n\nPrint the number of times the door will open.\n\n\n-----Examples-----\nInput\n1 1 3 4\n7\n\nOutput\n1\n\nInput\n4 3 4 2\n7 9 11\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example the only employee will come at moment 3. At this moment the door will open and will stay open until the moment 7. At the same moment of time the client will come, so at first he will enter and only after it the door will close. Thus the door will open one time.\n    \"\"\"\n",
        "canonical_solution": "\ndef mpDTo():\n    def solve():\n        n1, m, a, d = list(map(int, input().split()))\n        t = list(map(int, input().split()))\n        from bisect import insort\n        from math import floor\n        insort(t, a * n1)\n        pred = 0\n        k = 0\n        kpred = 0\n        n = 0\n        step = d // a + 1\n        sol = 0\n        fl = 0\n        for i in t:\n            if (i > pred):\n                if fl == 0:\n                    n = (i - pred + (pred % a)) // a\n                    if n != 0:\n                        k += (n // step) * step - step * (n % step == 0) + 1\n                        if k > n1:\n                            k = n1\n                            fl = 1\n                    # print(k)\n                    if (k * a + d >= i) and (n != 0):\n                        pred = k * a + d\n                    else:\n                        pred = i + d\n                        k = floor(pred // a)\n                        sol += 1\n                    # if n==0:\n                    k = min(floor(pred // a), n1)\n                    sol += n // step + (n % step != 0)\n                else:\n                    sol += 1\n                    pred = i + d\n            if i == a * n1:\n                fl = 1\n                # print(i,pred,sol,n,step,k, fl)\n        print(sol)\n    solve()",
        "inputs": [
            "1 1 3 4\n7\n",
            "4 3 4 2\n7 9 11\n",
            "10 10 51 69\n154 170 170 183 251 337 412 426 445 452\n"
        ],
        "outputs": [
            "1\n",
            "4\n",
            "6\n"
        ],
        "starter_code": "\ndef mpDTo():\n",
        "scope": [
            [
                "Function Body",
                2,
                42
            ],
            [
                "Function Body",
                3,
                41
            ],
            [
                "For Loop Body",
                16,
                39
            ],
            [
                "If Statement Body",
                17,
                37
            ],
            [
                "If Statement Body",
                18,
                37
            ],
            [
                "If Statement Body",
                20,
                24
            ],
            [
                "If Statement Body",
                22,
                24
            ],
            [
                "If Statement Body",
                26,
                31
            ],
            [
                "If Statement Body",
                38,
                39
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef bKFnP():\n    \"\"\"A schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 ≤ n ≤ 500 000) — the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer — the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space  — the resulting sequence itself.\n\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin\ndef bKFnP():\n    #stdin = open('input.txt')\n    n = int(stdin.readline())\n    seq = [int(x) for x in stdin.readline().split()]\n    carry = seq[0]\n    result = [carry]\n    mark = False\n    cur_len = 0\n    max_len = 0\n    i = 1\n    while i < len(seq) - 1:\n        if mark:\n            if seq[i] != seq[i + 1]:\n                cur_len += 1\n            else:\n                if cur_len > max_len:\n                    max_len = cur_len\n                if seq[i] == carry:\n                    result.extend([carry]*cur_len)\n                else:\n                    result.extend([carry]*(cur_len//2))\n                    result.extend([seq[i]]*(cur_len//2))\n                result.append(seq[i])\n                mark = False\n                cur_len = 0\n        elif seq[i] != seq[i - 1] and seq[i] != seq[i + 1]:\n            mark = True\n            cur_len = 1\n            carry = seq[i - 1]\n        else:\n            result.append(seq[i])\n        i += 1\n    if mark:\n        if cur_len > max_len:\n                max_len = cur_len\n        if seq[i] == carry:\n            result.extend([carry]*cur_len)\n        else:\n            result.extend([carry]*(cur_len//2))\n            result.extend([seq[i]]*(cur_len//2))\n    result.append(seq[i])\n    print((max_len + 1)//2)\n    for x in result:\n        print(x, end=' ')",
        "inputs": [
            "4\n0 0 1 1\n",
            "5\n0 1 0 1 0\n",
            "3\n1 0 0\n"
        ],
        "outputs": [
            "0\n0 0 1 1\n",
            "2\n0 0 0 0 0\n",
            "0\n1 0 0\n"
        ],
        "starter_code": "\ndef bKFnP():\n",
        "scope": [
            [
                "Function Body",
                2,
                45
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "While Loop Body",
                12,
                33
            ],
            [
                "If Statement Body",
                13,
                32
            ],
            [
                "If Statement Body",
                14,
                26
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                19,
                23
            ],
            [
                "If Statement Body",
                27,
                32
            ],
            [
                "If Statement Body",
                34,
                41
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "If Statement Body",
                37,
                41
            ],
            [
                "For Loop Body",
                44,
                45
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef Gtbmq():\n    \"\"\"After a wonderful evening in the restaurant the time to go home came. Leha as a true gentlemen suggested Noora to give her a lift. Certainly the girl agreed with pleasure. Suddenly one problem appeared: Leha cannot find his car on a huge parking near the restaurant. So he decided to turn to the watchman for help.\n\nFormally the parking can be represented as a matrix 10^9 × 10^9. There is exactly one car in every cell of the matrix. All cars have their own machine numbers represented as a positive integer. Let's index the columns of the matrix by integers from 1 to 10^9 from left to right and the rows by integers from 1 to 10^9 from top to bottom. By coincidence it turned out, that for every cell (x, y) the number of the car, which stands in this cell, is equal to the minimum positive integer, which can't be found in the cells (i, y) and (x, j), 1 ≤ i < x, 1 ≤ j < y. $\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$ The upper left fragment 5 × 5 of the parking \n\nLeha wants to ask the watchman q requests, which can help him to find his car. Every request is represented as five integers x_1, y_1, x_2, y_2, k. The watchman have to consider all cells (x, y) of the matrix, such that x_1 ≤ x ≤ x_2 and y_1 ≤ y ≤ y_2, and if the number of the car in cell (x, y) does not exceed k, increase the answer to the request by the number of the car in cell (x, y). For each request Leha asks the watchman to tell him the resulting sum. Due to the fact that the sum can turn out to be quite large, hacker asks to calculate it modulo 10^9 + 7.\n\nHowever the requests seem to be impracticable for the watchman. Help the watchman to answer all Leha's requests.\n\n\n-----Input-----\n\nThe first line contains one integer q (1 ≤ q ≤ 10^4) — the number of Leha's requests.\n\nThe next q lines contain five integers x_1, y_1, x_2, y_2, k (1 ≤ x_1 ≤ x_2 ≤ 10^9, 1 ≤ y_1 ≤ y_2 ≤ 10^9, 1 ≤ k ≤ 2·10^9) — parameters of Leha's requests.\n\n\n-----Output-----\n\nPrint exactly q lines — in the first line print the answer to the first request, in the second — the answer to the second request and so on.\n\n\n-----Example-----\nInput\n4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n\nOutput\n1\n13\n93\n0\n\n\n\n-----Note-----\n\nLet's analyze all the requests. In each case the requested submatrix is highlighted in blue.\n\nIn the first request (k = 1) Leha asks only about the upper left parking cell. In this cell the car's number is 1. Consequentally the answer is 1.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the second request (k = 5) suitable numbers are 4, 1, 2, 3, 2, 1. Consequentally the answer is 4 + 1 + 2 + 3 + 2 + 1 = 13.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the third request (k = 10000) Leha asks about the upper left frament 5 × 5 of the parking. Since k is big enough, the answer is equal to 93.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n\nIn the last request (k = 2) none of the cur's numbers are suitable, so the answer is 0.\n\n$\\left. \\begin{array}{|l|l|l|l|l|} \\hline 1 & {2} & {3} & {4} & {5} \\\\ \\hline 2 & {1} & {4} & {3} & {6} \\\\ \\hline 3 & {4} & {1} & {2} & {7} \\\\ \\hline 4 & {3} & {2} & {1} & {8} \\\\ \\hline 5 & {6} & {7} & {8} & {1} \\\\ \\hline \\end{array} \\right.$\n    \"\"\"\n",
        "canonical_solution": "\ndef Gtbmq():\n    mod = 1000000007\n    \n    def sum(x, y, k, add) :\n        if k < add : return 0\n        up = x + add\n        if up > k : up = k\n        add = add + 1\n        return y * ( ( (add + up) * (up - add + 1) // 2 ) % mod ) % mod\n    \n    def solve(x, y, k, add = 0) :\n        if x == 0 or y == 0 : return 0\n        if x > y :\n            x, y = y, x\n        pw = 1\n        while (pw << 1) <= y :\n            pw <<= 1\n        if pw <= x :\n            return ( sum(pw, pw, k, add)\\\n                     + sum(pw, x + y - pw - pw, k, add + pw)\\\n                     + solve(x - pw, y - pw, k, add) ) % mod\n        else :\n            return ( sum(pw, x, k, add)\\\n                     + solve(x, y - pw, k, add + pw) ) % mod\n    \n    q = int(input())\n    for i in range(0, q) :\n        x1, y1, x2, y2, k = list(map(int, input().split()))    \n        ans = ( solve(x2, y2, k)\\\n                - solve(x1 - 1, y2, k)\\\n                - solve(x2, y1 - 1, k)\\\n                + solve(x1 - 1, y1 - 1, k) ) % mod\n        if ans < 0 : ans += mod\n        print(ans)\n    ",
        "inputs": [
            "4\n1 1 1 1 1\n3 2 5 4 5\n1 1 5 5 10000\n1 4 2 5 2\n",
            "10\n3 7 4 10 7\n6 1 7 10 18\n9 6 10 8 3\n1 8 3 10 3\n10 4 10 5 19\n8 9 9 10 10\n10 1 10 5 4\n8 1 9 4 18\n6 3 9 5 1\n6 6 9 6 16\n",
            "10\n1 1 2 2 8\n3 4 5 9 4\n2 10 5 10 6\n8 5 10 8 8\n1 2 8 2 20\n8 6 10 8 20\n6 7 6 7 9\n8 5 10 10 13\n1 8 10 9 13\n9 8 10 9 3\n"
        ],
        "outputs": [
            "1\n13\n93\n0\n",
            "22\n130\n0\n0\n25\n3\n0\n68\n0\n22\n",
            "6\n13\n0\n10\n36\n95\n4\n42\n94\n3\n"
        ],
        "starter_code": "\ndef Gtbmq():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "Function Body",
                5,
                10
            ],
            [
                "If Statement Body",
                6,
                6
            ],
            [
                "If Statement Body",
                8,
                8
            ],
            [
                "Function Body",
                12,
                25
            ],
            [
                "If Statement Body",
                13,
                13
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "While Loop Body",
                17,
                18
            ],
            [
                "If Statement Body",
                19,
                25
            ],
            [
                "For Loop Body",
                28,
                35
            ],
            [
                "If Statement Body",
                34,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef MrPKZ():\n    \"\"\"Bessie has way too many friends because she is everyone's favorite cow! Her new friend Rabbit is trying to hop over so they can play! \n\nMore specifically, he wants to get from $(0,0)$ to $(x,0)$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $n$ favorite numbers: $a_1, a_2, \\ldots, a_n$. What is the minimum number of hops Rabbit needs to get from $(0,0)$ to $(x,0)$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.\n\nRecall that the Euclidean distance between points $(x_i, y_i)$ and $(x_j, y_j)$ is $\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$.\n\nFor example, if Rabbit has favorite numbers $1$ and $3$ he could hop from $(0,0)$ to $(4,0)$ in two hops as shown below. Note that there also exists other valid ways to hop to $(4,0)$ in $2$ hops (e.g. $(0,0)$ $\\rightarrow$ $(2,-\\sqrt{5})$ $\\rightarrow$ $(4,0)$).\n\n $1$ Here is a graphic for the first example. Both hops have distance $3$, one of Rabbit's favorite numbers. \n\nIn other words, each time Rabbit chooses some number $a_i$ and hops with distance equal to $a_i$ in any direction he wants. The same number can be used multiple times.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 1000$)  — the number of test cases. Next $2t$ lines contain test cases — two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5$, $1 \\le x \\le 10^9$)  — the number of favorite numbers and the distance Rabbit wants to travel, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$)  — Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print a single integer — the minimum number of hops needed.\n\n\n-----Example-----\nInput\n4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n\nOutput\n2\n3\n1\n2\n\n\n\n-----Note-----\n\nThe first test case of the sample is shown in the picture above. Rabbit can hop to $(2,\\sqrt{5})$, then to $(4,0)$ for a total of two hops. Each hop has a distance of $3$, which is one of his favorite numbers.\n\nIn the second test case of the sample, one way for Rabbit to hop $3$ times is: $(0,0)$ $\\rightarrow$ $(4,0)$ $\\rightarrow$ $(8,0)$ $\\rightarrow$ $(12,0)$.\n\nIn the third test case of the sample, Rabbit can hop from $(0,0)$ to $(5,0)$.\n\nIn the fourth test case of the sample, Rabbit can hop: $(0,0)$ $\\rightarrow$ $(5,10\\sqrt{2})$ $\\rightarrow$ $(10,0)$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef MrPKZ():\n    #sys.stdin=open(\"data.txt\")\n    input=sys.stdin.readline\n    mii=lambda:list(map(int,input().split()))\n    for _ in range(int(input())):\n        n,x=mii()\n        has=0\n        a=0\n        for i in mii():\n            if x==i: has=1\n            a=max(a,i)\n        if has:\n            print(1)\n        else:\n            print(max(2,(x-1)//a+1))",
        "inputs": [
            "4\n2 4\n1 3\n3 12\n3 4 5\n1 5\n5\n2 10\n15 4\n",
            "1\n10 999999733\n25 68 91 55 36 29 96 4 63 3\n",
            "1\n19 1000000000\n15 8 22 12 10 16 2 17 14 7 20 23 9 18 3 19 21 11 1\n"
        ],
        "outputs": [
            "2\n3\n1\n2\n",
            "10416664\n",
            "43478261\n"
        ],
        "starter_code": "\ndef MrPKZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "For Loop Body",
                6,
                16
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "If Statement Body",
                11,
                11
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef POgCJ():\n    \"\"\"Takahashi and Aoki are going to together construct a sequence of integers.\nFirst, Takahashi will provide a sequence of integers a, satisfying all of the following conditions:\n - The length of a is N.\n - Each element in a is an integer between 1 and K, inclusive.\n - a is a palindrome, that is, reversing the order of elements in a will result in the same sequence as the original.\nThen, Aoki will perform the following operation an arbitrary number of times:\n - Move the first element in a to the end of a.\nHow many sequences a can be obtained after this procedure, modulo 10^9+7?\n\n-----Constraints-----\n - 1≤N≤10^9\n - 1≤K≤10^9\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN K\n\n-----Output-----\nPrint the number of the sequences a that can be obtained after the procedure, modulo 10^9+7.\n\n-----Sample Input-----\n4 2\n\n-----Sample Output-----\n6\n\nThe following six sequences can be obtained:\n - (1, 1, 1, 1)\n - (1, 1, 2, 2)\n - (1, 2, 2, 1)\n - (2, 2, 1, 1)\n - (2, 1, 1, 2)\n - (2, 2, 2, 2)\n    \"\"\"\n",
        "canonical_solution": "\ndef POgCJ():\n    N, K = map(int, input().split())\n    S = []; T = []\n    for x in range(1, int(N**.5)+1):\n        if N % x == 0:\n            S.append(x)\n            if x*x < N:\n                T.append(N//x)\n    T.reverse()\n    S += T\n    M = len(S)\n    U = []\n    \n    MOD = 10**9 + 7\n    ans = 0\n    v = 0\n    for i in range(M):\n        x = S[i]\n        v = pow(K, (x+1)//2, MOD)\n        for j in range(i):\n            y = S[j]\n            if x % y == 0:\n                v -= U[j]\n        U.append(v % MOD)\n        ans = (ans + (v * x if x & 1 else v * (x//2))) % MOD\n    print(ans)",
        "inputs": [
            "4 2\n",
            "1 10\n",
            "6 3\n"
        ],
        "outputs": [
            "6\n",
            "10\n",
            "75\n"
        ],
        "starter_code": "\ndef POgCJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "For Loop Body",
                5,
                9
            ],
            [
                "If Statement Body",
                6,
                9
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "For Loop Body",
                18,
                26
            ],
            [
                "For Loop Body",
                21,
                24
            ],
            [
                "If Statement Body",
                23,
                24
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef YGbOk():\n    \"\"\"Greg has an array a = a_1, a_2, ..., a_{n} and m operations. Each operation looks as: l_{i}, r_{i}, d_{i}, (1 ≤ l_{i} ≤ r_{i} ≤ n). To apply operation i to the array means to increase all array elements with numbers l_{i}, l_{i} + 1, ..., r_{i} by value d_{i}.\n\nGreg wrote down k queries on a piece of paper. Each query has the following form: x_{i}, y_{i}, (1 ≤ x_{i} ≤ y_{i} ≤ m). That means that one should apply operations with numbers x_{i}, x_{i} + 1, ..., y_{i} to the array.\n\nNow Greg is wondering, what the array a will be after all the queries are executed. Help Greg.\n\n\n-----Input-----\n\nThe first line contains integers n, m, k (1 ≤ n, m, k ≤ 10^5). The second line contains n integers: a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 10^5) — the initial array.\n\nNext m lines contain operations, the operation number i is written as three integers: l_{i}, r_{i}, d_{i}, (1 ≤ l_{i} ≤ r_{i} ≤ n), (0 ≤ d_{i} ≤ 10^5).\n\nNext k lines contain the queries, the query number i is written as two integers: x_{i}, y_{i}, (1 ≤ x_{i} ≤ y_{i} ≤ m).\n\nThe numbers in the lines are separated by single spaces.\n\n\n-----Output-----\n\nOn a single line print n integers a_1, a_2, ..., a_{n} — the array after executing all the queries. Separate the printed numbers by spaces.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n\n\n-----Examples-----\nInput\n3 3 3\n1 2 3\n1 2 1\n1 3 2\n2 3 4\n1 2\n1 3\n2 3\n\nOutput\n9 18 17\n\nInput\n1 1 1\n1\n1 1 1\n1 1\n\nOutput\n2\n\nInput\n4 3 6\n1 2 3 4\n1 2 1\n2 3 2\n3 4 4\n1 2\n1 3\n2 3\n1 2\n1 3\n2 3\n\nOutput\n5 18 31 20\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin, stdout\ndef YGbOk():\n    rd = lambda: list(map(int, stdin.readline().split()))\n    n, m, k = rd()\n    a = rd()\n    b = [rd() for _ in range(m)]\n    x = [0]*(m+1)\n    y = [0]*(n+1)\n    for _ in range(k):\n      l, r = rd()\n      x[l-1] += 1\n      x[r  ] -= 1\n    s = 0\n    for i in range(m):\n      l, r, d = b[i]\n      s += x[i]\n      y[l-1] += s*d\n      y[r  ] -= s*d\n    s = 0\n    for i in range(n):\n      s += y[i]\n      a[i] += s\n    print(' '.join(map(str, a)))",
        "inputs": [
            "3 3 3\n1 2 3\n1 2 1\n1 3 2\n2 3 4\n1 2\n1 3\n2 3\n",
            "1 1 1\n1\n1 1 1\n1 1\n",
            "4 3 6\n1 2 3 4\n1 2 1\n2 3 2\n3 4 4\n1 2\n1 3\n2 3\n1 2\n1 3\n2 3\n"
        ],
        "outputs": [
            "9 18 17\n",
            "2\n",
            "5 18 31 20\n"
        ],
        "starter_code": "\ndef YGbOk():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "Lambda Expression",
                3,
                3
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "For Loop Body",
                14,
                18
            ],
            [
                "For Loop Body",
                20,
                22
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef RqVHI():\n    \"\"\"Pari wants to buy an expensive chocolate from Arya. She has n coins, the value of the i-th coin is c_{i}. The price of the chocolate is k, so Pari will take a subset of her coins with sum equal to k and give it to Arya.\n\nLooking at her coins, a question came to her mind: after giving the coins to Arya, what values does Arya can make with them? She is jealous and she doesn't want Arya to make a lot of values. So she wants to know all the values x, such that Arya will be able to make x using some subset of coins with the sum k.\n\nFormally, Pari wants to know the values x such that there exists a subset of coins with the sum k such that some subset of this subset has the sum x, i.e. there is exists some way to pay for the chocolate, such that Arya will be able to make the sum x using these coins.\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1  ≤  n, k  ≤  500) — the number of coins and the price of the chocolate, respectively.\n\nNext line will contain n integers c_1, c_2, ..., c_{n} (1 ≤ c_{i} ≤ 500) — the values of Pari's coins.\n\nIt's guaranteed that one can make value k using these coins.\n\n\n-----Output-----\n\nFirst line of the output must contain a single integer q— the number of suitable values x. Then print q integers in ascending order — the values that Arya can make for some subset of coins of Pari that pays for the chocolate.\n\n\n-----Examples-----\nInput\n6 18\n5 6 1 10 12 2\n\nOutput\n16\n0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 \n\nInput\n3 50\n25 25 50\n\nOutput\n3\n0 25 50\n    \"\"\"\n",
        "canonical_solution": "\ndef RqVHI():\n    #coding gbk\n    #!usr/bin/ENV\n    cin =lambda : list(map(int,input().split()))\n    n, k = cin()\n    c=list(cin())\n    dp = [0]*(k+1)\n    dp[0]=1\n    for i in c:\n        tmp = dp[:]\n        for x in range(k,i-1,-1):\n            tmp[x] |= dp[x-i]|(dp[x-i]<<i)\n        dp = tmp\n    b = bin(dp[-1])\n    ans = [i for i in range(k + 1) if b[-i - 1] == '1']\n    print(len(ans))\n    print(*ans)\n    ",
        "inputs": [
            "6 18\n5 6 1 10 12 2\n",
            "3 50\n25 25 50\n",
            "1 79\n79\n"
        ],
        "outputs": [
            "16\n0 1 2 3 5 6 7 8 10 11 12 13 15 16 17 18 \n",
            "3\n0 25 50 \n",
            "2\n0 79 \n"
        ],
        "starter_code": "\ndef RqVHI():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "For Loop Body",
                10,
                14
            ],
            [
                "For Loop Body",
                12,
                13
            ],
            [
                "List Comprehension",
                16,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef omkNf():\n    \"\"\"Appleman has a very big sheet of paper. This sheet has a form of rectangle with dimensions 1 × n. Your task is help Appleman with folding of such a sheet. Actually, you need to perform q queries. Each query will have one of the following types:  Fold the sheet of paper at position p_{i}. After this query the leftmost part of the paper with dimensions 1 × p_{i} must be above the rightmost part of the paper with dimensions 1 × ([current width of sheet] - p_{i}).  Count what is the total width of the paper pieces, if we will make two described later cuts and consider only the pieces between the cuts. We will make one cut at distance l_{i} from the left border of the current sheet of paper and the other at distance r_{i} from the left border of the current sheet of paper. \n\nPlease look at the explanation of the first test example for better understanding of the problem.\n\n\n-----Input-----\n\nThe first line contains two integers: n and q (1  ≤ n ≤ 10^5; 1 ≤ q ≤ 10^5) — the width of the paper and the number of queries.\n\nEach of the following q lines contains one of the described queries in the following format:  \"1 p_{i}\" (1 ≤ p_{i} < [current width of sheet]) — the first type query.  \"2 l_{i} r_{i}\" (0 ≤ l_{i} < r_{i} ≤ [current width of sheet]) — the second type query. \n\n\n-----Output-----\n\nFor each query of the second type, output the answer.\n\n\n-----Examples-----\nInput\n7 4\n1 3\n1 2\n2 0 1\n2 1 2\n\nOutput\n4\n3\n\nInput\n10 9\n2 2 9\n1 1\n2 0 1\n1 8\n2 0 8\n1 2\n2 1 3\n1 4\n2 2 4\n\nOutput\n7\n2\n10\n4\n5\n\n\n\n-----Note-----\n\nThe pictures below show the shapes of the paper during the queries of the first example: [Image] \n\nAfter the first fold operation the sheet has width equal to 4, after the second one the width of the sheet equals to 2.\n    \"\"\"\n",
        "canonical_solution": "from itertools import starmap\ndef omkNf():\n    def main():\n        n, q = list(map(int, input().split()))\n        a = list(range(n + 1))\n        flipped = False\n        start = 0\n        end = n\n        for _ in range(q):\n            cmd, *args = list(map(int, input().split()))\n            if cmd == 1:\n                p = args[0]\n                if p > end-start-p:\n                    flipped = not flipped\n                    p = end-start-p\n                if flipped:\n                    a[end-p:end-2*p:-1] = starmap(\n                        lambda a, b: a+n-b,\n                        list(zip(a[end-p:end-2*p:-1], a[end-p:end]))\n                    )\n                    end -= p\n                else:\n                    start += p\n                    a[start:start+p] = starmap(\n                        lambda a, b: a-b,\n                        list(zip(a[start:start+p], a[start:start-p:-1]))\n                    )\n            else:\n                l, r = args\n                if flipped:\n                    l, r = end-start-r, end-start-l\n                print(a[start + r] - a[start + l])\n    def __starting_point():\n        main()\n    __starting_point()",
        "inputs": [
            "7 4\n1 3\n1 2\n2 0 1\n2 1 2\n",
            "10 9\n2 2 9\n1 1\n2 0 1\n1 8\n2 0 8\n1 2\n2 1 3\n1 4\n2 2 4\n",
            "10 5\n2 1 9\n2 4 10\n1 1\n2 0 1\n2 0 1\n"
        ],
        "outputs": [
            "4\n3\n",
            "7\n2\n10\n4\n5\n",
            "8\n6\n2\n2\n"
        ],
        "starter_code": "\ndef omkNf():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "Function Body",
                3,
                32
            ],
            [
                "For Loop Body",
                9,
                32
            ],
            [
                "If Statement Body",
                11,
                32
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "If Statement Body",
                16,
                27
            ],
            [
                "Lambda Expression",
                18,
                18
            ],
            [
                "Lambda Expression",
                25,
                25
            ],
            [
                "If Statement Body",
                30,
                31
            ],
            [
                "Function Body",
                33,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef gJpyw():\n    \"\"\"The BFS algorithm is defined as follows.  Consider an undirected graph with vertices numbered from $1$ to $n$. Initialize $q$ as a new queue containing only vertex $1$, mark the vertex $1$ as used.  Extract a vertex $v$ from the head of the queue $q$.  Print the index of vertex $v$.  Iterate in arbitrary order through all such vertices $u$ that $u$ is a neighbor of $v$ and is not marked yet as used. Mark the vertex $u$ as used and insert it into the tail of the queue $q$.  If the queue is not empty, continue from step 2.  Otherwise finish. \n\nSince the order of choosing neighbors of each vertex can vary, it turns out that there may be multiple sequences which BFS can print.\n\nIn this problem you need to check whether a given sequence corresponds to some valid BFS traversal of the given tree starting from vertex $1$. The tree is an undirected graph, such that there is exactly one simple path between any two vertices.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) which denotes the number of nodes in the tree. \n\nThe following $n - 1$ lines describe the edges of the tree. Each of them contains two integers $x$ and $y$ ($1 \\le x, y \\le n$) — the endpoints of the corresponding edge of the tree. It is guaranteed that the given graph is a tree.\n\nThe last line contains $n$ distinct integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) — the sequence to check.\n\n\n-----Output-----\n\nPrint \"Yes\" (quotes for clarity) if the sequence corresponds to some valid BFS traversal of the given tree and \"No\" (quotes for clarity) otherwise.\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n4\n1 2\n1 3\n2 4\n1 2 3 4\n\nOutput\nYes\nInput\n4\n1 2\n1 3\n2 4\n1 2 4 3\n\nOutput\nNo\n\n\n-----Note-----\n\nBoth sample tests have the same tree in them.\n\nIn this tree, there are two valid BFS orderings:   $1, 2, 3, 4$,  $1, 3, 2, 4$. \n\nThe ordering $1, 2, 4, 3$ doesn't correspond to any valid BFS order.\n    \"\"\"\n",
        "canonical_solution": "\ndef gJpyw():\n    n = int(input())\n    graph = [set() for tr in range(n+2)]\n    i = 1\n    while i < n:\n    \tx, y = list(map(int, input().split()))\n    \tgraph[x].add(y)\n    \tgraph[y].add(x)\n    \ti += 1\n    a = iter(map(int, input().split()))\n    try:\n    \tassert next(a) == 1\n    \tq = [1]\n    \tfor v in q:\n    \t\tgv = graph[v]\n    \t\tgv1 = tuple(gv)\n    \t\tfor tr2 in gv1:\n    \t\t\tu = next(a)\n    \t\t\tassert u in gv\n    \t\t\tgv.remove(u)\n    \t\t\tgraph[u].remove(v)\n    \t\t\tq.append(u)\n    \tprint(\"Yes\")\n    except AssertionError:\n    \tprint(\"No\")\n    ",
        "inputs": [
            "4\n1 2\n1 3\n2 4\n1 2 3 4\n",
            "4\n1 2\n1 3\n2 4\n1 2 4 3\n",
            "6\n1 2\n1 5\n2 3\n2 4\n5 6\n1 2 5 3 4 6\n"
        ],
        "outputs": [
            "Yes",
            "No",
            "Yes"
        ],
        "starter_code": "\ndef gJpyw():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "While Loop Body",
                6,
                10
            ],
            [
                "Try Block",
                12,
                26
            ],
            [
                "Except Block",
                25,
                26
            ],
            [
                "For Loop Body",
                15,
                23
            ],
            [
                "For Loop Body",
                18,
                23
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef zamLu():\n    \"\"\"This is a simplified version of the task Toy Train. These two versions differ only in the constraints. Hacks for this version are disabled.\n\nAlice received a set of Toy Train™ from Bob. It consists of one train and a connected railway network of $n$ stations, enumerated from $1$ through $n$. The train occupies one station at a time and travels around the network of stations in a circular manner. More precisely, the immediate station that the train will visit after station $i$ is station $i+1$ if $1 \\leq i < n$ or station $1$ if $i = n$. It takes the train $1$ second to travel to its next station as described.\n\nBob gave Alice a fun task before he left: to deliver $m$ candies that are initially at some stations to their independent destinations using the train. The candies are enumerated from $1$ through $m$. Candy $i$ ($1 \\leq i \\leq m$), now at station $a_i$, should be delivered to station $b_i$ ($a_i \\neq b_i$). [Image] The blue numbers on the candies correspond to $b_i$ values. The image corresponds to the $1$-st example. \n\nThe train has infinite capacity, and it is possible to load off any number of candies at a station. However, only at most one candy can be loaded from a station onto the train before it leaves the station. You can choose any candy at this station. The time it takes to move the candies is negligible.\n\nNow, Alice wonders how much time is needed for the train to deliver all candies. Your task is to find, for each station, the minimum time the train would need to deliver all the candies were it to start from there.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers $n$ and $m$ ($2 \\leq n \\leq 100$; $1 \\leq m \\leq 200$) — the number of stations and the number of candies, respectively.\n\nThe $i$-th of the following $m$ lines contains two space-separated integers $a_i$ and $b_i$ ($1 \\leq a_i, b_i \\leq n$; $a_i \\neq b_i$) — the station that initially contains candy $i$ and the destination station of the candy, respectively.\n\n\n-----Output-----\n\nIn the first and only line, print $n$ space-separated integers, the $i$-th of which is the minimum time, in seconds, the train would need to deliver all the candies were it to start from station $i$.\n\n\n-----Examples-----\nInput\n5 7\n2 4\n5 1\n2 3\n3 4\n4 1\n5 3\n3 5\n\nOutput\n10 9 10 10 9 \n\nInput\n2 3\n1 2\n1 2\n1 2\n\nOutput\n5 6 \n\n\n\n-----Note-----\n\nConsider the second sample.\n\nIf the train started at station $1$, the optimal strategy is as follows.  Load the first candy onto the train.  Proceed to station $2$. This step takes $1$ second.  Deliver the first candy.  Proceed to station $1$. This step takes $1$ second.  Load the second candy onto the train.  Proceed to station $2$. This step takes $1$ second.  Deliver the second candy.  Proceed to station $1$. This step takes $1$ second.  Load the third candy onto the train.  Proceed to station $2$. This step takes $1$ second.  Deliver the third candy. \n\nHence, the train needs $5$ seconds to complete the tasks.\n\nIf the train were to start at station $2$, however, it would need to move to station $1$ before it could load the first candy, which would take one additional second. Thus, the answer in this scenario is $5+1 = 6$ seconds.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef zamLu():\n    #sys.stdin=open(\"data.txt\")\n    input=sys.stdin.readline\n    mii=lambda:list(map(int,input().split()))\n    n,m=mii()\n    a=[[] for _ in range(n)]\n    c=[123456 for _ in range(n)]\n    for _ in range(m):\n        u,v=mii()\n        u%=n\n        v%=n\n        if v<u: v+=n\n        a[u].append(v)\n        if c[u]>v: c[u]=v\n    ans=[]\n    for i in list(range(1,n))+[0]:\n        out=0\n        for j in range(i,n):\n            if not a[j]: continue\n            tmp=(j-i)+(len(a[j])-1)*n+(c[j]-j)\n            out=max(out,tmp)\n            #print(1,i,j,tmp)\n        for j in range(i):\n            if not a[j]: continue\n            tmp=(j+n-i)+(len(a[j])-1)*n+(c[j]-j)\n            out=max(out,tmp)\n            #print(2,i,j,tmp)\n        ans.append(out)\n    print(\" \".join(map(str,ans)))",
        "inputs": [
            "5 7\n2 4\n5 1\n2 3\n3 4\n4 1\n5 3\n3 5\n",
            "2 3\n1 2\n1 2\n1 2\n",
            "5 1\n3 2\n"
        ],
        "outputs": [
            "10 9 10 10 9 \n",
            "5 6 \n",
            "6 5 4 8 7 \n"
        ],
        "starter_code": "\ndef zamLu():\n",
        "scope": [
            [
                "Function Body",
                2,
                30
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "For Loop Body",
                9,
                15
            ],
            [
                "If Statement Body",
                13,
                13
            ],
            [
                "If Statement Body",
                15,
                15
            ],
            [
                "For Loop Body",
                17,
                29
            ],
            [
                "For Loop Body",
                19,
                22
            ],
            [
                "If Statement Body",
                20,
                20
            ],
            [
                "For Loop Body",
                24,
                27
            ],
            [
                "If Statement Body",
                25,
                25
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef ZVHsq():\n    \"\"\"Sometimes Mister B has free evenings when he doesn't know what to do. Fortunately, Mister B found a new game, where the player can play against aliens.\n\nAll characters in this game are lowercase English letters. There are two players: Mister B and his competitor.\n\nInitially the players have a string s consisting of the first a English letters in alphabetical order (for example, if a = 5, then s equals to \"abcde\").\n\nThe players take turns appending letters to string s. Mister B moves first.\n\nMister B must append exactly b letters on each his move. He can arbitrary choose these letters. His opponent adds exactly a letters on each move.\n\nMister B quickly understood that his opponent was just a computer that used a simple algorithm. The computer on each turn considers the suffix of string s of length a and generates a string t of length a such that all letters in the string t are distinct and don't appear in the considered suffix. From multiple variants of t lexicographically minimal is chosen (if a = 4 and the suffix is \"bfdd\", the computer chooses string t equal to \"aceg\"). After that the chosen string t is appended to the end of s.\n\nMister B soon found the game boring and came up with the following question: what can be the minimum possible number of different letters in string s on the segment between positions l and r, inclusive. Letters of string s are numerated starting from 1.\n\n\n-----Input-----\n\nFirst and only line contains four space-separated integers: a, b, l and r (1 ≤ a, b ≤ 12, 1 ≤ l ≤ r ≤ 10^9) — the numbers of letters each player appends and the bounds of the segment.\n\n\n-----Output-----\n\nPrint one integer — the minimum possible number of different letters in the segment from position l to position r, inclusive, in string s.\n\n\n-----Examples-----\nInput\n1 1 1 8\n\nOutput\n2\nInput\n4 2 2 6\n\nOutput\n3\nInput\n3 7 4 6\n\nOutput\n1\n\n\n-----Note-----\n\nIn the first sample test one of optimal strategies generate string s = \"abababab...\", that's why answer is 2.\n\nIn the second sample test string s = \"abcdbcaefg...\" can be obtained, chosen segment will look like \"bcdbc\", that's why answer is 3.\n\nIn the third sample test string s = \"abczzzacad...\" can be obtained, chosen, segment will look like \"zzz\", that's why answer is 1.\n    \"\"\"\n",
        "canonical_solution": "\ndef ZVHsq():\n    a,b,l,r=list(map(int, input().split()))\n    length=int(l/(a+b))\n    if a==3 and b==1 and l==4 and r==10:\n        print(4)\n        return\n    l-=length*(a+b)\n    r-=length*(a+b)\n    if r>=4*a+4*b:\n        r=4*a+4*b\n    if b>=a:\n        _A=[]\n        for i in range(a):\n            _A.append(i+1)\n        for i in range(b):\n            _A.append(a)\n        for i in range(a):\n            _A.append(i+1)\n        _A[2*a+b-1]+=1\n        for i in range(b):\n            _A.append(_A[2*a+b-1])\n        for i in range(2*a+2*b):\n            _A.append(_A[i])\n        _B=[]\n        for i in range(25):\n            _B.append(0)\n        cnt=0\n        for i in range(r-l+1):\n            if _B[_A[l+i-1]]==0:\n                cnt+=1\n                _B[_A[l+i-1]]=1\n    else:\n        _A=[]\n        for i in range(a):\n            _A.append(i+1)\n        for i in range(b):\n            _A.append(a)\n        for i in range(a):\n            if i+1<=b:\n                _A.append(i+1)\n            else:\n                _A.append(a+i-b+2)\n        for i in range(b):\n            _A.append(_A[2*a+b-1])\n        for i in range(2*a+2*b):\n            _A.append(_A[i])\n        _B=[]\n        for i in range(25):\n            _B.append(0)\n        cnt=0\n        for i in range(r-l+1):\n            if _B[_A[l+i-1]]==0:\n                cnt+=1\n                _B[_A[l+i-1]]=1\n    # print(_A)\n    print(cnt)\n    ",
        "inputs": [
            "1 1 1 8\n",
            "4 2 2 6\n",
            "3 7 4 6\n"
        ],
        "outputs": [
            "2",
            "3",
            "1"
        ],
        "starter_code": "\ndef ZVHsq():\n",
        "scope": [
            [
                "Function Body",
                2,
                57
            ],
            [
                "If Statement Body",
                5,
                7
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "If Statement Body",
                12,
                55
            ],
            [
                "For Loop Body",
                14,
                15
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                18,
                19
            ],
            [
                "For Loop Body",
                21,
                22
            ],
            [
                "For Loop Body",
                23,
                24
            ],
            [
                "For Loop Body",
                26,
                27
            ],
            [
                "For Loop Body",
                29,
                32
            ],
            [
                "If Statement Body",
                30,
                32
            ],
            [
                "For Loop Body",
                35,
                36
            ],
            [
                "For Loop Body",
                37,
                38
            ],
            [
                "For Loop Body",
                39,
                43
            ],
            [
                "If Statement Body",
                40,
                43
            ],
            [
                "For Loop Body",
                44,
                45
            ],
            [
                "For Loop Body",
                46,
                47
            ],
            [
                "For Loop Body",
                49,
                50
            ],
            [
                "For Loop Body",
                52,
                55
            ],
            [
                "If Statement Body",
                53,
                55
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef KIDzN():\n    \"\"\"You are given a table consisting of n rows and m columns.\n\nNumbers in each row form a permutation of integers from 1 to m.\n\nYou are allowed to pick two elements in one row and swap them, but no more than once for each row. Also, no more than once you are allowed to pick two columns and swap them. Thus, you are allowed to perform from 0 to n + 1 actions in total. Operations can be performed in any order.\n\nYou have to check whether it's possible to obtain the identity permutation 1, 2, ..., m in each row. In other words, check if one can perform some of the operation following the given rules and make each row sorted in increasing order.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (1 ≤ n, m ≤ 20) — the number of rows and the number of columns in the given table. \n\nEach of next n lines contains m integers — elements of the table. It's guaranteed that numbers in each line form a permutation of integers from 1 to m.\n\n\n-----Output-----\n\nIf there is a way to obtain the identity permutation in each row by following the given rules, print \"YES\" (without quotes) in the only line of the output. Otherwise, print \"NO\" (without quotes).\n\n\n-----Examples-----\nInput\n2 4\n1 3 2 4\n1 3 4 2\n\nOutput\nYES\n\nInput\n4 4\n1 2 3 4\n2 3 4 1\n3 4 1 2\n4 1 2 3\n\nOutput\nNO\n\nInput\n3 6\n2 1 3 4 5 6\n1 2 4 3 5 6\n1 2 3 4 6 5\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first sample, one can act in the following way:   Swap second and third columns. Now the table is 1 2 3 4 1 4 3 2  In the second row, swap the second and the fourth elements. Now the table is 1 2 3 4 1 2 3 4\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef KIDzN():\n    n, m = list(map(int,input().split()))\n    g = [list(map(int,input().split())) for _ in range(n)]\n    for c1 in range(m):\n        for c2 in range(c1, m):\n            ok = True\n            for row in g:\n                row[c1], row[c2] = row[c2], row[c1]\n                cnt = 0\n                for i in range(m):\n                    if row[i] != i + 1:\n                        cnt += 1\n                    if cnt > 2:\n                        break\n                row[c1], row[c2] = row[c2], row[c1]\n                if cnt > 2:\n                    ok = False\n                    break\n            if ok:\n                print('YES')\n                return\n    print('NO')",
        "inputs": [
            "2 4\n1 3 2 4\n1 3 4 2\n",
            "4 4\n1 2 3 4\n2 3 4 1\n3 4 1 2\n4 1 2 3\n",
            "3 6\n2 1 3 4 5 6\n1 2 4 3 5 6\n1 2 3 4 6 5\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "YES\n"
        ],
        "starter_code": "\ndef KIDzN():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                5,
                22
            ],
            [
                "For Loop Body",
                6,
                22
            ],
            [
                "For Loop Body",
                8,
                19
            ],
            [
                "For Loop Body",
                11,
                15
            ],
            [
                "If Statement Body",
                12,
                13
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "If Statement Body",
                17,
                19
            ],
            [
                "If Statement Body",
                20,
                22
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef TqlRX():\n    \"\"\"A group of n cities is connected by a network of roads. There is an undirected road between every pair of cities, so there are $\\frac{n \\cdot(n - 1)}{2}$ roads in total. It takes exactly y seconds to traverse any single road.\n\nA spanning tree is a set of roads containing exactly n - 1 roads such that it's possible to travel between any two cities using only these roads.\n\nSome spanning tree of the initial network was chosen. For every road in this tree the time one needs to traverse this road was changed from y to x seconds. Note that it's not guaranteed that x is smaller than y.\n\nYou would like to travel through all the cities using the shortest path possible. Given n, x, y and a description of the spanning tree that was chosen, find the cost of the shortest path that starts in any city, ends in any city and visits all cities exactly once.\n\n\n-----Input-----\n\nThe first line of the input contains three integers n, x and y (2 ≤ n ≤ 200 000, 1 ≤ x, y ≤ 10^9).\n\nEach of the next n - 1 lines contains a description of a road in the spanning tree. The i-th of these lines contains two integers u_{i} and v_{i} (1 ≤ u_{i}, v_{i} ≤ n) — indices of the cities connected by the i-th road. It is guaranteed that these roads form a spanning tree.\n\n\n-----Output-----\n\nPrint a single integer — the minimum number of seconds one needs to spend in order to visit all the cities exactly once.\n\n\n-----Examples-----\nInput\n5 2 3\n1 2\n1 3\n3 4\n5 3\n\nOutput\n9\n\nInput\n5 3 2\n1 2\n1 3\n3 4\n5 3\n\nOutput\n8\n\n\n\n-----Note-----\n\nIn the first sample, roads of the spanning tree have cost 2, while other roads have cost 3. One example of an optimal path is $5 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 2$.\n\nIn the second sample, we have the same spanning tree, but roads in the spanning tree cost 3, while other roads cost 2. One example of an optimal path is $1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2 \\rightarrow 3$.\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\nfrom collections import deque\nfrom functools import reduce\ndef TqlRX():\n    n, x, y = [int(x) for x in input().split()]\n    E = defaultdict(set)\n    for i in range(n-1):\n        u, v = [int(x) for x in input().split()]\n        E[u].add(v)\n        E[v].add(u)\n    if x > y:\n        for v in E:\n            if len(E[v]) == n-1:\n                print((n-2)*y + x)\n                break\n            elif len(E[v]) > 1:\n                print((n-1)*y)\n                break\n    else:\n        visited = {v : False for v in E}\n        stack = [1]\n        topsorted = deque()\n        while stack:\n            v = stack.pop()\n            if visited[v]: continue\n            visited[v] = True\n            topsorted.appendleft(v)\n            stack.extend(E[v])\n        chopped = set()\n        ans = 0\n        for v in topsorted:\n            ans += max(0, len(E[v])-2)\n            if len(E[v]) > 2:\n                S = E[v].intersection(chopped)\n                S1 = {S.pop(), S.pop()}\n                for u in E[v]:\n                    if not u in S1:\n                        E[u].remove(v)\n                E[v].clear()\n                E[v].update(S1)\n            chopped.add(v)\n        print(ans*y + (n-1-ans)*x)\n            ",
        "inputs": [
            "5 2 3\n1 2\n1 3\n3 4\n5 3\n",
            "5 3 2\n1 2\n1 3\n3 4\n5 3\n",
            "50 23129 410924\n18 28\n17 23\n21 15\n18 50\n50 11\n32 3\n44 41\n50 31\n50 34\n5 14\n36 13\n22 40\n20 9\n9 43\n19 47\n48 40\n20 22\n33 45\n35 22\n33 24\n9 6\n13 1\n13 24\n49 20\n1 20\n29 38\n10 35\n25 23\n49 30\n42 8\n20 18\n32 15\n32 1\n27 10\n20 47\n41 7\n20 14\n18 26\n4 20\n20 2\n46 37\n41 16\n46 41\n12 20\n8 40\n18 37\n29 3\n32 39\n23 37\n"
        ],
        "outputs": [
            "9\n",
            "8\n",
            "8113631\n"
        ],
        "starter_code": "\ndef TqlRX():\n",
        "scope": [
            [
                "Function Body",
                4,
                42
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                7,
                10
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "If Statement Body",
                11,
                42
            ],
            [
                "For Loop Body",
                12,
                18
            ],
            [
                "If Statement Body",
                13,
                18
            ],
            [
                "If Statement Body",
                16,
                18
            ],
            [
                "Dict Comprehension",
                20,
                20
            ],
            [
                "While Loop Body",
                23,
                28
            ],
            [
                "If Statement Body",
                25,
                25
            ],
            [
                "For Loop Body",
                31,
                41
            ],
            [
                "If Statement Body",
                33,
                40
            ],
            [
                "For Loop Body",
                36,
                38
            ],
            [
                "If Statement Body",
                37,
                38
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef xUrZX():\n    \"\"\"Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  ≤  u_{i},  v_{i}  ≤  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers — the indices of vertices. Note that because of m ≥ 1, vertex cover cannot be empty.\n\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.\n    \"\"\"\n",
        "canonical_solution": "\ndef xUrZX():\n    def main():\n        n, m = list(map(int, input().split()))\n        l = [[] for _ in range(n + 1)]\n        for _ in range(m):\n            u, v = list(map(int, input().split()))\n            l[u].append(v)\n            l[v].append(u)\n        res = [0] * (n + 1)\n        for u, x in enumerate(res):\n            if not x:\n                x, nxt = -1, [u]\n                while nxt:\n                    x, cur, nxt = -x, nxt, []\n                    for u in cur:\n                        if l[u]:\n                            res[u] = x\n                            for v in l[u]:\n                                if not res[v]:\n                                    nxt.append(v)\n                                elif res[v] == x:\n                                    print(-1)\n                                    return\n        for x in -1, 1:\n            l = [u for u in range(1, n + 1) if res[u] == x]\n            print(len(l))\n            print(' '.join(map(str, l)))\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "4 2\n1 2\n2 3\n",
            "3 3\n1 2\n2 3\n1 3\n",
            "5 7\n3 2\n5 4\n3 4\n1 3\n1 5\n1 4\n2 5\n"
        ],
        "outputs": [
            "1\n2 \n2\n1 3 \n",
            "-1\n",
            "-1\n"
        ],
        "starter_code": "\ndef xUrZX():\n",
        "scope": [
            [
                "Function Body",
                2,
                34
            ],
            [
                "Function Body",
                3,
                28
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "For Loop Body",
                11,
                24
            ],
            [
                "If Statement Body",
                12,
                24
            ],
            [
                "While Loop Body",
                14,
                24
            ],
            [
                "For Loop Body",
                16,
                24
            ],
            [
                "If Statement Body",
                17,
                24
            ],
            [
                "For Loop Body",
                19,
                24
            ],
            [
                "If Statement Body",
                20,
                24
            ],
            [
                "If Statement Body",
                22,
                24
            ],
            [
                "For Loop Body",
                25,
                28
            ],
            [
                "List Comprehension",
                26,
                26
            ],
            [
                "Function Body",
                31,
                32
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef BpiLj():\n    \"\"\"There are $b$ boys and $g$ girls participating in Olympiad of Metropolises. There will be a board games tournament in the evening and $n$ participants have accepted the invitation. The organizers do not know how many boys and girls are among them.\n\nOrganizers are preparing red badges for girls and blue ones for boys.\n\nVasya prepared $n+1$ decks of badges. The $i$-th (where $i$ is from $0$ to $n$, inclusive) deck contains $i$ blue badges and $n-i$ red ones. The total number of badges in any deck is exactly $n$.\n\nDetermine the minimum number of decks among these $n+1$ that Vasya should take, so that there will be a suitable deck no matter how many girls and boys there will be among the participants of the tournament.\n\n\n-----Input-----\n\nThe first line contains an integer $b$ ($1 \\le b \\le 300$), the number of boys. \n\nThe second line contains an integer $g$ ($1 \\le g \\le 300$), the number of girls. \n\nThe third line contains an integer $n$ ($1 \\le n \\le b + g$), the number of the board games tournament participants.\n\n\n-----Output-----\n\nOutput the only integer, the minimum number of badge decks that Vasya could take.\n\n\n-----Examples-----\nInput\n5\n6\n3\n\nOutput\n4\n\nInput\n5\n3\n5\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example, each of 4 decks should be taken: (0 blue, 3 red), (1 blue, 2 red), (2 blue, 1 red), (3 blue, 0 red).\n\nIn the second example, 4 decks should be taken: (2 blue, 3 red), (3 blue, 2 red), (4 blue, 1 red), (5 blue, 0 red). Piles (0 blue, 5 red) and (1 blue, 4 red) can not be used.\n    \"\"\"\n",
        "canonical_solution": "\ndef BpiLj():\n    def main():\n        import sys\n        input = sys.stdin.readline\n        \n        b = int(input())\n        g = int(input())\n        n = int(input())\n        \n        ans = n + 1\n        if b < n:\n            ans -= n - b\n        if g < n:\n            ans -= n - g\n        \n        print(ans)\n        \n        return 0\n    \n    main()\n    ",
        "inputs": [
            "5\n6\n3\n",
            "5\n3\n5\n",
            "1\n200\n33\n"
        ],
        "outputs": [
            "4\n",
            "4\n",
            "2\n"
        ],
        "starter_code": "\ndef BpiLj():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "Function Body",
                3,
                19
            ],
            [
                "If Statement Body",
                12,
                13
            ],
            [
                "If Statement Body",
                14,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef OerFc():\n    \"\"\"Levko loves array a_1, a_2, ... , a_{n}, consisting of integers, very much. That is why Levko is playing with array a, performing all sorts of operations with it. Each operation Levko performs is of one of two types:\n\n  Increase all elements from l_{i} to r_{i} by d_{i}. In other words, perform assignments a_{j} = a_{j} + d_{i} for all j that meet the inequation l_{i} ≤ j ≤ r_{i}.  Find the maximum of elements from l_{i} to r_{i}. That is, calculate the value $m_{i} = \\operatorname{max}_{j = l_{i}}^{r_{i}} a_{j}$. \n\nSadly, Levko has recently lost his array. Fortunately, Levko has records of all operations he has performed on array a. Help Levko, given the operation records, find at least one suitable array. The results of all operations for the given array must coincide with the record results. Levko clearly remembers that all numbers in his array didn't exceed 10^9 in their absolute value, so he asks you to find such an array.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 5000) — the size of the array and the number of operations in Levko's records, correspondingly.\n\nNext m lines describe the operations, the i-th line describes the i-th operation. The first integer in the i-th line is integer t_{i} (1 ≤ t_{i} ≤ 2) that describes the operation type. If t_{i} = 1, then it is followed by three integers l_{i}, r_{i} and d_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n,  - 10^4 ≤ d_{i} ≤ 10^4) — the description of the operation of the first type. If t_{i} = 2, then it is followed by three integers l_{i}, r_{i} and m_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n,  - 5·10^7 ≤ m_{i} ≤ 5·10^7) — the description of the operation of the second type.\n\nThe operations are given in the order Levko performed them on his array.\n\n\n-----Output-----\n\nIn the first line print \"YES\" (without the quotes), if the solution exists and \"NO\" (without the quotes) otherwise.\n\nIf the solution exists, then on the second line print n integers a_1, a_2, ... , a_{n} (|a_{i}| ≤ 10^9) — the recovered array.\n\n\n-----Examples-----\nInput\n4 5\n1 2 3 1\n2 1 2 8\n2 3 4 7\n1 1 3 3\n2 3 4 8\n\nOutput\nYES\n4 7 4 7\nInput\n4 5\n1 2 3 1\n2 1 2 8\n2 3 4 7\n1 1 3 3\n2 3 4 13\n\nOutput\nNO\n    \"\"\"\n",
        "canonical_solution": "\ndef OerFc():\n    n, m = map(int, input().split())\n    a = [10**9 for _ in range(n)]\n    extra = [0 for _ in range(n)]\n    query = list()\n    for _ in range(m):\n         t, l, r, x = map(int, input().split())\n         l -= 1\n         r -= 1\n         query.append((t, l, r, x))\n         if t == 1:\n              for j in range(l, r + 1):\n                   extra[j] += x\n         else:\n              for j in range(l, r + 1):\n                   a[j] = min(a[j], x - extra[j])\n    extra = a.copy()\n    for t, l, r, x in query:\n         if t == 1:\n              for j in range(l, r + 1):\n                   a[j] += x\n         else:\n              val = -10**9\n              for j in range(l, r + 1):\n                   val = max(val, a[j])\n              if not val == x:\n                   print('NO')\n                   return\n    \n    print('YES')\n    for x in extra:\n         print(x, end=' ')\n              ",
        "inputs": [
            "4 5\n1 2 3 1\n2 1 2 8\n2 3 4 7\n1 1 3 3\n2 3 4 8\n",
            "4 5\n1 2 3 1\n2 1 2 8\n2 3 4 7\n1 1 3 3\n2 3 4 13\n",
            "1 4\n1 1 1 2\n2 1 1 6\n1 1 1 1\n2 1 1 7\n"
        ],
        "outputs": [
            "YES\n8 7 4 7 \n",
            "NO\n",
            "YES\n4 \n"
        ],
        "starter_code": "\ndef OerFc():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                7,
                17
            ],
            [
                "If Statement Body",
                12,
                17
            ],
            [
                "For Loop Body",
                13,
                14
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                19,
                29
            ],
            [
                "If Statement Body",
                20,
                29
            ],
            [
                "For Loop Body",
                21,
                22
            ],
            [
                "For Loop Body",
                25,
                26
            ],
            [
                "If Statement Body",
                27,
                29
            ],
            [
                "For Loop Body",
                32,
                33
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef nUEBz():\n    \"\"\"A subsequence of a string S is a string that can be obtained by deleting zero or more characters from S without changing the order of the remaining characters.\nFor example, arc, artistic and (an empty string) are all subsequences of artistic; abc and ci are not.\nYou are given a string A consisting of lowercase English letters.\nFind the shortest string among the strings consisting of lowercase English letters that are not subsequences of A.\nIf there are more than one such string, find the lexicographically smallest one among them.\n\n-----Constraints-----\n - 1 \\leq |A| \\leq 2 \\times 10^5\n - A consists of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nA\n\n-----Output-----\nPrint the lexicographically smallest string among the shortest strings consisting of lowercase English letters that are not subsequences of A.\n\n-----Sample Input-----\natcoderregularcontest\n\n-----Sample Output-----\nb\n\nThe string atcoderregularcontest contains a as a subsequence, but not b.\n    \"\"\"\n",
        "canonical_solution": "\ndef nUEBz():\n    A = [ord(a)-97 for a in input()]\n    N = len(A)\n    X = [0] * 26\n    Y = [0] * (N + 2)\n    NE = [0] * N\n    R = [N] * 26\n    s = 0\n    t = 1\n    for i in range(N)[::-1]:\n        a = A[i]\n        if X[a] == 0:\n            X[a] = 1\n            s += 1\n            if s == 26:\n                s = 0\n                X = [0] * 26\n                t += 1\n        Y[i] = t\n        NE[i] = R[a]\n        R[a] = i\n    \n    ANS = []\n    ii = 0\n    for i, a in enumerate(A):\n        if i == ii:\n            for j in range(26):\n                if Y[R[j]+1] < Y[i]:\n                    ANS.append(j)\n                    ii = R[j]+1\n                    break\n        R[a] = NE[i]\n    \n    print(\"\".join([chr(a+97) for a in ANS]))",
        "inputs": [
            "atcoderregularcontest\n",
            "abcdefghijklmnopqrstuvwxyz\n",
            "frqnvhydscshfcgdemurlfrutcpzhopfotpifgepnqjxupnskapziurswqazdwnwbgdhyktfyhqqxpoidfhjdakoxraiedxskywuepzfniuyskxiyjpjlxuqnfgmnjcvtlpnclfkpervxmdbvrbrdn\n"
        ],
        "outputs": [
            "b\n",
            "aa\n",
            "aca\n"
        ],
        "starter_code": "\ndef nUEBz():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "List Comprehension",
                3,
                3
            ],
            [
                "For Loop Body",
                11,
                22
            ],
            [
                "If Statement Body",
                13,
                19
            ],
            [
                "If Statement Body",
                16,
                19
            ],
            [
                "For Loop Body",
                26,
                33
            ],
            [
                "If Statement Body",
                27,
                32
            ],
            [
                "For Loop Body",
                28,
                32
            ],
            [
                "If Statement Body",
                29,
                32
            ],
            [
                "List Comprehension",
                35,
                35
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef HVFOS():\n    \"\"\"You are given an array $a_{1}, a_{2}, \\ldots, a_{n}$. You can remove at most one subsegment from it. The remaining elements should be pairwise distinct.\n\nIn other words, at most one time you can choose two integers $l$ and $r$ ($1 \\leq l \\leq r \\leq n$) and delete integers $a_l, a_{l+1}, \\ldots, a_r$ from the array. Remaining elements should be pairwise distinct. \n\nFind the minimum size of the subsegment you need to remove to make all remaining elements distinct.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer $n$ ($1 \\le n \\le 2000$) — the number of elements in the given array.\n\nThe next line contains $n$ spaced integers $a_{1}, a_{2}, \\ldots, a_{n}$ ($1 \\le a_{i} \\le 10^{9}$) — the elements of the array. \n\n\n-----Output-----\n\nPrint a single integer — the minimum size of the subsegment you need to remove to make all elements of the array pairwise distinct. If no subsegment needs to be removed, print $0$.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n0\n\nInput\n4\n1 1 2 2\n\nOutput\n2\n\nInput\n5\n1 4 1 4 9\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example all the elements are already distinct, therefore no subsegment needs to be removed.\n\nIn the second example you can remove the subsegment from index $2$ to $3$.\n\nIn the third example you can remove the subsegments from index $1$ to $2$, or from index $2$ to $3$, or from index $3$ to $4$.\n    \"\"\"\n",
        "canonical_solution": "\ndef HVFOS():\n    def main():\n        import sys\n        input = sys.stdin.readline\n        \n        n = int(input())\n        arr = list(map(int, input().split()))\n        \n        dct = {}\n        for x in arr:\n            dct[x] = 0\n        \n        i = 0\n        while i != n and dct[arr[i]] == 0:\n            dct[arr[i]] = 1\n            i += 1\n        \n        if i == n:\n            print(0)\n            return 0\n        \n        j = n - 1\n        while dct[arr[j]] == 0:\n            dct[arr[j]] = 1\n            j -= 1\n        \n        ans = j - i + 1\n        \n        for k in range(i - 1, -1, -1):\n            dct[arr[k]] -= 1\n            while dct[arr[j]] == 0:\n                dct[arr[j]] = 1\n                j -= 1\n            ans = min(ans, j - (k - 1))\n        \n        print(ans)\n        \n        return 0\n    \n    main()",
        "inputs": [
            "3\n1 2 3\n",
            "4\n1 1 2 2\n",
            "5\n1 4 1 4 9\n"
        ],
        "outputs": [
            "0\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef HVFOS():\n",
        "scope": [
            [
                "Function Body",
                2,
                41
            ],
            [
                "Function Body",
                3,
                39
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "While Loop Body",
                15,
                17
            ],
            [
                "If Statement Body",
                19,
                21
            ],
            [
                "While Loop Body",
                24,
                26
            ],
            [
                "For Loop Body",
                30,
                35
            ],
            [
                "While Loop Body",
                32,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef rEzjn():\n    \"\"\"On vacations n pupils decided to go on excursion and gather all together. They need to overcome the path with the length l meters. Each of the pupils will go with the speed equal to v_1. To get to the excursion quickly, it was decided to rent a bus, which has seats for k people (it means that it can't fit more than k people at the same time) and the speed equal to v_2. In order to avoid seasick, each of the pupils want to get into the bus no more than once.\n\nDetermine the minimum time required for all n pupils to reach the place of excursion. Consider that the embarkation and disembarkation of passengers, as well as the reversal of the bus, take place immediately and this time can be neglected. \n\n\n-----Input-----\n\nThe first line of the input contains five positive integers n, l, v_1, v_2 and k (1 ≤ n ≤ 10 000, 1 ≤ l ≤ 10^9, 1 ≤ v_1 < v_2 ≤ 10^9, 1 ≤ k ≤ n) — the number of pupils, the distance from meeting to the place of excursion, the speed of each pupil, the speed of bus and the number of seats in the bus. \n\n\n-----Output-----\n\nPrint the real number — the minimum time in which all pupils can reach the place of excursion. Your answer will be considered correct if its absolute or relative error won't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n5 10 1 2 5\n\nOutput\n5.0000000000\n\nInput\n3 6 1 2 1\n\nOutput\n4.7142857143\n\n\n\n-----Note-----\n\nIn the first sample we should immediately put all five pupils to the bus. The speed of the bus equals 2 and the distance is equal to 10, so the pupils will reach the place of excursion in time 10 / 2 = 5.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef rEzjn():\n    n, l, v1, v2, k = list(map(int, input().split()))\n    n = (n + k - 1) // k\n    if n == 1:\n    \tprint(l / v2)\n    \treturn\n    L, R = 0, l\n    for i in range(100):\n    \tM = (L + R) / 2\n    \tS = l - M\n    \tT = M * (n * 2 - 1)- l\n    \tif T * v1 > S * v2:\n    \t\tR = M\n    \telse:\n    \t\tL = M\n    print(M / v2 + S / v1)",
        "inputs": [
            "5 10 1 2 5\n",
            "3 6 1 2 1\n",
            "39 252 51 98 26\n"
        ],
        "outputs": [
            "5.0\n",
            "4.714285714285714\n",
            "3.534433693796244\n"
        ],
        "starter_code": "\ndef rEzjn():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "If Statement Body",
                5,
                7
            ],
            [
                "For Loop Body",
                9,
                16
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef DyVgX():\n    \"\"\"Let's denote as $\\text{popcount}(x)$ the number of bits set ('1' bits) in the binary representation of the non-negative integer x.\n\nYou are given multiple queries consisting of pairs of integers l and r. For each query, find the x, such that l ≤ x ≤ r, and $\\text{popcount}(x)$ is maximum possible. If there are multiple such numbers find the smallest of them.\n\n\n-----Input-----\n\nThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).\n\nEach of the following n lines contain two integers l_{i}, r_{i} — the arguments for the corresponding query (0 ≤ l_{i} ≤ r_{i} ≤ 10^18).\n\n\n-----Output-----\n\nFor each query print the answer in a separate line.\n\n\n-----Examples-----\nInput\n3\n1 2\n2 4\n1 10\n\nOutput\n1\n3\n7\n\n\n\n-----Note-----\n\nThe binary representations of numbers from 1 to 10 are listed below:\n\n1_10 = 1_2\n\n2_10 = 10_2\n\n3_10 = 11_2\n\n4_10 = 100_2\n\n5_10 = 101_2\n\n6_10 = 110_2\n\n7_10 = 111_2\n\n8_10 = 1000_2\n\n9_10 = 1001_2\n\n10_10 = 1010_2\n    \"\"\"\n",
        "canonical_solution": "\ndef DyVgX():\n    def popcount(n):\n    \tres = 0\n    \twhile n > 0:\n    \t\tres += n & 1\n    \t\tn >>= 2\n    \n    def A(l, r):\n    \tr += 1\n    \tt = 1 << 64\n    \twhile t & (l ^ r) == 0:\n    \t\tt >>= 1\n    \tres = l | (t - 1)\n    \t#print(t, res)\n    \treturn res\n    \n    def __starting_point():\n    \t\"\"\"assert(A(1, 2) == 1)\n    \tassert(A(2, 4) == 3)\n    \tassert(A(1, 10) == 7)\n    \tassert(A(13, 13) == 13)\n    \tassert(A(1, 7) == 7)\"\"\"\n    \n    \tn = int(input())\n    \tfor _ in range(n):\n    \t\tl, r = list(map(int, input().split()))\n    \t\tres = A(l, r)\n    \t\tprint(res)\n    \n    __starting_point()",
        "inputs": [
            "3\n1 2\n2 4\n1 10\n",
            "55\n1 1\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n2 2\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n3 3\n3 4\n3 5\n3 6\n3 7\n3 8\n3 9\n3 10\n4 4\n4 5\n4 6\n4 7\n4 8\n4 9\n4 10\n5 5\n5 6\n5 7\n5 8\n5 9\n5 10\n6 6\n6 7\n6 8\n6 9\n6 10\n7 7\n7 8\n7 9\n7 10\n8 8\n8 9\n8 10\n9 9\n9 10\n10 10\n",
            "18\n1 10\n1 100\n1 1000\n1 10000\n1 100000\n1 1000000\n1 10000000\n1 100000000\n1 1000000000\n1 10000000000\n1 100000000000\n1 1000000000000\n1 10000000000000\n1 100000000000000\n1 1000000000000000\n1 10000000000000000\n1 100000000000000000\n1 1000000000000000000\n"
        ],
        "outputs": [
            "1\n3\n7\n",
            "1\n1\n3\n3\n3\n3\n7\n7\n7\n7\n2\n3\n3\n3\n3\n7\n7\n7\n7\n3\n3\n3\n3\n7\n7\n7\n7\n4\n5\n5\n7\n7\n7\n7\n5\n5\n7\n7\n7\n7\n6\n7\n7\n7\n7\n7\n7\n7\n7\n8\n9\n9\n9\n9\n10\n",
            "7\n63\n511\n8191\n65535\n524287\n8388607\n67108863\n536870911\n8589934591\n68719476735\n549755813887\n8796093022207\n70368744177663\n562949953421311\n9007199254740991\n72057594037927935\n576460752303423487\n"
        ],
        "starter_code": "\ndef DyVgX():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "While Loop Body",
                5,
                7
            ],
            [
                "Function Body",
                9,
                16
            ],
            [
                "While Loop Body",
                12,
                13
            ],
            [
                "Function Body",
                18,
                29
            ],
            [
                "For Loop Body",
                26,
                29
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef VPDpJ():\n    \"\"\"Let's call two strings $s$ and $t$ anagrams of each other if it is possible to rearrange symbols in the string $s$ to get a string, equal to $t$.\n\nLet's consider two strings $s$ and $t$ which are anagrams of each other. We say that $t$ is a reducible anagram of $s$ if there exists an integer $k \\ge 2$ and $2k$ non-empty strings $s_1, t_1, s_2, t_2, \\dots, s_k, t_k$ that satisfy the following conditions:\n\n  If we write the strings $s_1, s_2, \\dots, s_k$ in order, the resulting string will be equal to $s$;  If we write the strings $t_1, t_2, \\dots, t_k$ in order, the resulting string will be equal to $t$;  For all integers $i$ between $1$ and $k$ inclusive, $s_i$ and $t_i$ are anagrams of each other. \n\nIf such strings don't exist, then $t$ is said to be an irreducible anagram of $s$. Note that these notions are only defined when $s$ and $t$ are anagrams of each other.\n\nFor example, consider the string $s = $ \"gamegame\". Then the string $t = $ \"megamage\" is a reducible anagram of $s$, we may choose for example $s_1 = $ \"game\", $s_2 = $ \"gam\", $s_3 = $ \"e\" and $t_1 = $ \"mega\", $t_2 = $ \"mag\", $t_3 = $ \"e\":\n\n [Image] \n\nOn the other hand, we can prove that $t = $ \"memegaga\" is an irreducible anagram of $s$.\n\nYou will be given a string $s$ and $q$ queries, represented by two integers $1 \\le l \\le r \\le |s|$ (where $|s|$ is equal to the length of the string $s$). For each query, you should find if the substring of $s$ formed by characters from the $l$-th to the $r$-th has at least one irreducible anagram.\n\n\n-----Input-----\n\nThe first line contains a string $s$, consisting of lowercase English characters ($1 \\le |s| \\le 2 \\cdot 10^5$).\n\nThe second line contains a single integer $q$ ($1 \\le q \\le 10^5$)  — the number of queries.\n\nEach of the following $q$ lines contain two integers $l$ and $r$ ($1 \\le l \\le r \\le |s|$), representing a query for the substring of $s$ formed by characters from the $l$-th to the $r$-th.\n\n\n-----Output-----\n\nFor each query, print a single line containing \"Yes\" (without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing \"No\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\naaaaa\n3\n1 1\n2 4\n5 5\n\nOutput\nYes\nNo\nYes\n\nInput\naabbbbbbc\n6\n1 2\n2 4\n2 2\n1 9\n5 7\n3 5\n\nOutput\nNo\nYes\nYes\nYes\nNo\nNo\n\n\n\n-----Note-----\n\nIn the first sample, in the first and third queries, the substring is \"a\", which has itself as an irreducible anagram since two or more non-empty strings cannot be put together to obtain \"a\". On the other hand, in the second query, the substring is \"aaa\", which has no irreducible anagrams: its only anagram is itself, and we may choose $s_1 = $ \"a\", $s_2 = $ \"aa\", $t_1 = $ \"a\", $t_2 = $ \"aa\" to show that it is a reducible anagram.\n\nIn the second query of the second sample, the substring is \"abb\", which has, for example, \"bba\" as an irreducible anagram.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef VPDpJ():\n    readline = sys.stdin.readline\n    S = list([ord(x)-97 for x in readline().strip()])\n    N = len(S)\n    table = [[0]*26 for _ in range(N)]\n    for i in range(N):\n        table[i][S[i]] = 1\n    for i in range(1, N):\n        for j in range(26):\n            table[i][j] += table[i-1][j]\n    Q = int(readline())\n    Ans = [None]*Q\n    for qu in range(Q):\n        l, r = list(map(int, readline().split()))\n        l -= 1\n        r -= 1 \n        if l == r or S[l] != S[r]:\n            Ans[qu] = True\n            continue\n        K = [table[r][j] - table[l][j] for j in range(26)]\n        if len([k for k in K if k]) <= 2:\n            Ans[qu] = False\n        else:\n            Ans[qu] = True\n    print('\\n'.join(['Yes' if s else 'No' for s in Ans]))",
        "inputs": [
            "aaaaa\n3\n1 1\n2 4\n5 5\n",
            "aabbbbbbc\n6\n1 2\n2 4\n2 2\n1 9\n5 7\n3 5\n",
            "f\n1\n1 1\n"
        ],
        "outputs": [
            "Yes\nNo\nYes\n",
            "No\nYes\nYes\nYes\nNo\nNo\n",
            "Yes\n"
        ],
        "starter_code": "\ndef VPDpJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                9,
                11
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                14,
                25
            ],
            [
                "If Statement Body",
                18,
                20
            ],
            [
                "List Comprehension",
                21,
                21
            ],
            [
                "If Statement Body",
                22,
                25
            ],
            [
                "List Comprehension",
                22,
                22
            ],
            [
                "List Comprehension",
                26,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef tBCuz():\n    \"\"\"There is a country with $n$ citizens. The $i$-th of them initially has $a_{i}$ money. The government strictly controls the wealth of its citizens. Whenever a citizen makes a purchase or earns some money, they must send a receipt to the social services mentioning the amount of money they currently have.\n\nSometimes the government makes payouts to the poor: all citizens who have strictly less money than $x$ are paid accordingly so that after the payout they have exactly $x$ money. In this case the citizens don't send a receipt.\n\nYou know the initial wealth of every citizen and the log of all events: receipts and payouts. Restore the amount of money each citizen has after all events.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^{5}$) — the numer of citizens.\n\nThe next line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($0 \\le a_{i} \\le 10^{9}$) — the initial balances of citizens.\n\nThe next line contains a single integer $q$ ($1 \\le q \\le 2 \\cdot 10^{5}$) — the number of events.\n\nEach of the next $q$ lines contains a single event. The events are given in chronological order.\n\nEach event is described as either 1 p x ($1 \\le p \\le n$, $0 \\le x \\le 10^{9}$), or 2 x ($0 \\le x \\le 10^{9}$). In the first case we have a receipt that the balance of the $p$-th person becomes equal to $x$. In the second case we have a payoff with parameter $x$.\n\n\n-----Output-----\n\nPrint $n$ integers — the balances of all citizens after all events.\n\n\n-----Examples-----\nInput\n4\n1 2 3 4\n3\n2 3\n1 2 2\n2 1\n\nOutput\n3 2 3 4 \n\nInput\n5\n3 50 2 1 10\n3\n1 2 0\n2 8\n1 3 20\n\nOutput\n8 8 20 8 10 \n\n\n\n-----Note-----\n\nIn the first example the balances change as follows: 1 2 3 4 $\\rightarrow$ 3 3 3 4 $\\rightarrow$ 3 2 3 4 $\\rightarrow$ 3 2 3 4\n\nIn the second example the balances change as follows: 3 50 2 1 10 $\\rightarrow$ 3 0 2 1 10 $\\rightarrow$ 8 8 8 8 10 $\\rightarrow$ 8 8 20 8 10\n    \"\"\"\n",
        "canonical_solution": "\ndef tBCuz():\n    n=int(input())\n    a=list(map(int,input().split()))\n    q=int(input())\n    changes=[0]*q\n    for i in range(q):\n        changes[-i-1]=tuple(map(int,input().split()))\n    final=[-1]*n\n    curr=0\n    for guy in changes:\n        if guy[0]==1:\n            if final[guy[1]-1]==-1:\n                final[guy[1]-1]=max(guy[2],curr)\n        else:\n            curr=max(curr,guy[1])\n    for i in range(n):\n        if final[i]==-1:\n            final[i]=max(curr,a[i])\n    final=[str(guy) for guy in final]\n    print(\" \".join(final))",
        "inputs": [
            "4\n1 2 3 4\n3\n2 3\n1 2 2\n2 1\n",
            "5\n3 50 2 1 10\n3\n1 2 0\n2 8\n1 3 20\n",
            "10\n1 2 3 4 5 6 7 8 9 10\n10\n2 1\n2 2\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n"
        ],
        "outputs": [
            "3 2 3 4 \n",
            "8 8 20 8 10 \n",
            "10 10 10 10 10 10 10 10 10 10 \n"
        ],
        "starter_code": "\ndef tBCuz():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                11,
                16
            ],
            [
                "If Statement Body",
                12,
                16
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "List Comprehension",
                20,
                20
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef lfRgZ():\n    \"\"\"Moriarty has trapped n people in n distinct rooms in a hotel. Some rooms are locked, others are unlocked. But, there is a condition that the people in the hotel can only escape when all the doors are unlocked at the same time. There are m switches. Each switch control doors of some rooms, but each door is controlled by exactly two switches.\n\nYou are given the initial configuration of the doors. Toggling any switch, that is, turning it ON when it is OFF, or turning it OFF when it is ON, toggles the condition of the doors that this switch controls. Say, we toggled switch 1, which was connected to room 1, 2 and 3 which were respectively locked, unlocked and unlocked. Then, after toggling the switch, they become unlocked, locked and locked.\n\nYou need to tell Sherlock, if there exists a way to unlock all doors at the same time.\n\n\n-----Input-----\n\nFirst line of input contains two integers n and m (2 ≤ n ≤ 10^5, 2 ≤ m ≤ 10^5) — the number of rooms and the number of switches.\n\nNext line contains n space-separated integers r_1, r_2, ..., r_{n} (0 ≤ r_{i} ≤ 1) which tell the status of room doors. The i-th room is locked if r_{i} = 0, otherwise it is unlocked.\n\nThe i-th of next m lines contains an integer x_{i} (0 ≤ x_{i} ≤ n) followed by x_{i} distinct integers separated by space, denoting the number of rooms controlled by the i-th switch followed by the room numbers that this switch controls. It is guaranteed that the room numbers are in the range from 1 to n. It is guaranteed that each door is controlled by exactly two switches.\n\n\n-----Output-----\n\nOutput \"YES\" without quotes, if it is possible to open all doors at the same time, otherwise output \"NO\" without quotes.\n\n\n-----Examples-----\nInput\n3 3\n1 0 1\n2 1 3\n2 1 2\n2 2 3\n\nOutput\nNO\nInput\n3 3\n1 0 1\n3 1 2 3\n1 2\n2 1 3\n\nOutput\nYES\nInput\n3 3\n1 0 1\n3 1 2 3\n2 1 2\n1 3\n\nOutput\nNO\n\n\n-----Note-----\n\nIn the second example input, the initial statuses of the doors are [1, 0, 1] (0 means locked, 1 — unlocked).\n\nAfter toggling switch 3, we get [0, 0, 0] that means all doors are locked.\n\nThen, after toggling switch 1, we get [1, 1, 1] that means all doors are unlocked.\n\nIt can be seen that for the first and for the third example inputs it is not possible to make all doors unlocked.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport collections\ndef lfRgZ():\n    n, m = list(map(int, input().split()))\n    r = tuple(map(int, input().split()))\n    controls = [tuple(map(int, input().split()))[1:] for i in range(m)]\n    class DSU:\n        def __init__(self):\n            self.parent = None\n            self.has_zero = False\n            self.has_one = False\n            self.size = 1\n            self.doors = []\n        def get_root(self):\n            if self.parent is None:\n                return self\n            self.parent = self.parent.get_root()\n            return self.parent\n        def unite(self, s):\n            r1 = self.get_root()\n            r2 = s.get_root()\n            if r1 is r2:\n                return r1\n            if r1.size < r2.size:\n                r1, r2 = r2, r1\n            r2.parent = r1\n            r1.size += r2.size\n            r1.has_zero = r1.has_zero or r2.has_zero\n            r1.has_one = r1.has_one or r2.has_one\n            return r1\n    door_dsus = [[] for i in range(n)]\n    for doors in controls:\n        n = DSU()\n        for door in doors:\n            n.doors.append(door - 1)\n            door_dsus[door - 1].append(n)\n            if r[door - 1]:\n                n.has_one = True\n            if not r[door - 1]:\n                n.has_zero = True\n    for door, is_open in enumerate(r):\n        n1, n2 = door_dsus[door]\n        if is_open:\n             n1.unite(n2)\n    G = {}\n    for door, is_open in enumerate(r):\n        if is_open:\n            continue\n        n1, n2 = door_dsus[door]\n        if n1.get_root() is n2.get_root():\n            print(\"NO\")\n            return\n        G.setdefault(n1.get_root(), set()).add(n2.get_root())\n        G.setdefault(n2.get_root(), set()).add(n1.get_root())\n    color = {}\n    for v in list(G.keys()):\n        if v in color:\n            continue\n        color[v] = False\n        q = collections.deque([v])\n        while q:\n            v = q.popleft()\n            c = color[v]\n            for adj_v in G[v]:\n                if adj_v in color:\n                    if color[adj_v] != (not c):\n                        print(\"NO\")\n                        return\n                else:\n                    color[adj_v] = not c\n                    q.append(adj_v)\n    print(\"YES\")",
        "inputs": [
            "3 3\n1 0 1\n2 1 3\n2 1 2\n2 2 3\n",
            "3 3\n1 0 1\n3 1 2 3\n1 2\n2 1 3\n",
            "3 3\n1 0 1\n3 1 2 3\n2 1 2\n1 3\n"
        ],
        "outputs": [
            "NO",
            "YES",
            "NO"
        ],
        "starter_code": "\ndef lfRgZ():\n",
        "scope": [
            [
                "Function Body",
                3,
                72
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "Class Body",
                7,
                30
            ],
            [
                "Function Body",
                8,
                13
            ],
            [
                "Function Body",
                14,
                18
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "Function Body",
                19,
                30
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "List Comprehension",
                31,
                31
            ],
            [
                "For Loop Body",
                32,
                40
            ],
            [
                "For Loop Body",
                34,
                40
            ],
            [
                "If Statement Body",
                37,
                38
            ],
            [
                "If Statement Body",
                39,
                40
            ],
            [
                "For Loop Body",
                41,
                44
            ],
            [
                "If Statement Body",
                43,
                44
            ],
            [
                "For Loop Body",
                46,
                54
            ],
            [
                "If Statement Body",
                47,
                48
            ],
            [
                "If Statement Body",
                50,
                52
            ],
            [
                "For Loop Body",
                56,
                71
            ],
            [
                "If Statement Body",
                57,
                58
            ],
            [
                "While Loop Body",
                61,
                71
            ],
            [
                "For Loop Body",
                64,
                71
            ],
            [
                "If Statement Body",
                65,
                71
            ],
            [
                "If Statement Body",
                66,
                68
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef jQdAD():\n    \"\"\"Iahub and Iahubina went to a picnic in a forest full of trees. Less than 5 minutes passed before Iahub remembered of trees from programming. Moreover, he invented a new problem and Iahubina has to solve it, otherwise Iahub won't give her the food. \n\nIahub asks Iahubina: can you build a rooted tree, such that\n\n  each internal node (a node with at least one son) has at least two sons;  node i has c_{i} nodes in its subtree? \n\nIahubina has to guess the tree. Being a smart girl, she realized that it's possible no tree can follow Iahub's restrictions. In this way, Iahub will eat all the food. You need to help Iahubina: determine if there's at least one tree following Iahub's restrictions. The required tree must contain n nodes.\n\n\n-----Input-----\n\nThe first line of the input contains integer n (1 ≤ n ≤ 24). Next line contains n positive integers: the i-th number represents c_{i} (1 ≤ c_{i} ≤ n).\n\n\n-----Output-----\n\nOutput on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes). \n\n\n-----Examples-----\nInput\n4\n1 1 1 4\n\nOutput\nYES\nInput\n5\n1 1 5 2 1\n\nOutput\nNO\n    \"\"\"\n",
        "canonical_solution": "\ndef jQdAD():\n    def DFS(x):\n        for i in range(x):\n            if(Seen[i][x]):\n                continue\n            if(Rem[i]>=C[x]):\n                if(Rem[i]==C[x] and len(Children[i])==0):\n                    continue\n                Rem[i]-=C[x]\n                Parent[x]=i\n                Children[i].append(x)\n                return True\n        for i in range(x):\n            if(Seen[i][x]):\n                continue\n            Y=[]\n            for j in range(len(Children[i])):\n                child=Children[i][j]\n                Parent[child]=-1\n                Rem[i]+=C[child]\n                Seen[i][child]=True\n                Seen[child][i]=True\n                if(DFS(child)):\n                    Seen[i][child]=False\n                    Seen[child][i]=False\n                    continue\n                Seen[i][child]=False\n                Seen[child][i]=False\n                Parent[child]=i\n                Rem[i]-=C[child]\n                Y.append(child)\n            Children[i]=list(Y)\n            if(Rem[i]>=C[x]):\n                if(Rem[i]==C[x] and len(Children[i])==0):\n                    continue\n                Rem[i]-=C[x]\n                Children[i].append(x)\n                Parent[x]=i\n                return True\n        return False\n                    \n            \n    \n    \n    \n    \n    n=int(input())\n    \n    C=list(map(int,input().split()))\n    Rem=[-1]*n\n    Parent=[-1]*n\n    Children=[]\n    Seen=[]\n    for i in range(n):\n        Seen.append([False]*n)\n    C.sort(reverse=True)\n    \n    if(C[0]!=n or C.count(2)>0):\n        print(\"NO\")\n    \n    else:\n        for i in range(n):\n            Rem[i]=C[i]-1\n            Children.append([])\n        Parent[0]=0\n        Ans=\"YES\"\n        for i in range(1,n):\n            if(DFS(i)==False):\n                Ans=\"NO\"\n                break\n        for i in range(n):\n            if(Rem[i]!=0 and C[i]!=1):\n                Ans=\"NO\"\n                break\n        print(Ans)\n                \n    ",
        "inputs": [
            "4\n1 1 1 4\n",
            "5\n1 1 5 2 1\n",
            "13\n1 1 1 1 1 1 1 1 1 4 4 4 13\n"
        ],
        "outputs": [
            "YES",
            "NO",
            "YES"
        ],
        "starter_code": "\ndef jQdAD():\n",
        "scope": [
            [
                "Function Body",
                2,
                76
            ],
            [
                "Function Body",
                3,
                41
            ],
            [
                "For Loop Body",
                4,
                13
            ],
            [
                "If Statement Body",
                5,
                6
            ],
            [
                "If Statement Body",
                7,
                13
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "For Loop Body",
                14,
                40
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "For Loop Body",
                18,
                32
            ],
            [
                "If Statement Body",
                24,
                27
            ],
            [
                "If Statement Body",
                34,
                40
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "For Loop Body",
                55,
                56
            ],
            [
                "If Statement Body",
                59,
                76
            ],
            [
                "For Loop Body",
                63,
                65
            ],
            [
                "For Loop Body",
                68,
                71
            ],
            [
                "If Statement Body",
                69,
                71
            ],
            [
                "For Loop Body",
                72,
                75
            ],
            [
                "If Statement Body",
                73,
                75
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef ISRKo():\n    \"\"\"Konrad is a Human Relations consultant working for VoltModder, a large electrical equipment producer. Today, he has been tasked with evaluating the level of happiness in the company.\n\nThere are $n$ people working for VoltModder, numbered from $1$ to $n$. Each employee earns a different amount of money in the company — initially, the $i$-th person earns $i$ rubles per day.\n\nOn each of $q$ following days, the salaries will be revised. At the end of the $i$-th day, employee $v_i$ will start earning $n+i$ rubles per day and will become the best-paid person in the company. The employee will keep his new salary until it gets revised again.\n\nSome pairs of people don't like each other. This creates a great psychological danger in the company. Formally, if two people $a$ and $b$ dislike each other and $a$ earns more money than $b$, employee $a$ will brag about this to $b$. A dangerous triple is a triple of three employees $a$, $b$ and $c$, such that $a$ brags to $b$, who in turn brags to $c$. If $a$ dislikes $b$, then $b$ dislikes $a$.\n\nAt the beginning of each day, Konrad needs to evaluate the number of dangerous triples in the company. Can you help him do it?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 100\\,000$, $0 \\le m \\le 100\\,000$) — the number of employees in the company and the number of pairs of people who don't like each other. Each of the following $m$ lines contains two integers $a_i$, $b_i$ ($1 \\le a_i, b_i \\le n$, $a_i \\neq b_i$) denoting that employees $a_i$ and $b_i$ hate each other (that is, $a_i$ dislikes $b_i$ and $b_i$ dislikes $a_i$). Each such relationship will be mentioned exactly once.\n\nThe next line contains an integer $q$ ($0 \\le q \\le 100\\,000$) — the number of salary revisions. The $i$-th of the following $q$ lines contains a single integer $v_i$ ($1 \\le v_i \\le n$) denoting that at the end of the $i$-th day, employee $v_i$ will earn the most.\n\n\n-----Output-----\n\nOutput $q + 1$ integers. The $i$-th of them should contain the number of dangerous triples in the company at the beginning of the $i$-th day.\n\n\n-----Examples-----\nInput\n4 5\n1 2\n2 4\n1 3\n3 4\n2 3\n2\n2\n3\n\nOutput\n4\n3\n2\n\nInput\n3 3\n1 2\n2 3\n1 3\n5\n1\n2\n2\n1\n3\n\nOutput\n1\n1\n1\n1\n1\n1\n\n\n\n-----Note-----\n\nConsider the first sample test. The $i$-th row in the following image shows the structure of the company at the beginning of the $i$-th day. A directed edge from $a$ to $b$ denotes that employee $a$ brags to employee $b$. The dangerous triples are marked by highlighted edges. [Image]\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef ISRKo():\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\n    L = [0 for i in range (0, n)]\n    H = [[] for i in range (0, n)]\n    for i in range (0, m):\n        x, y = list(map(int, sys.stdin.readline().strip().split()))\n        x = x - 1\n        y = y - 1\n        if x > y:\n            x, y = y, x\n        L[y] = L[y] + 1\n        H[x].append(y)\n    ans = 0\n    for i in range (0, n):\n        ans = ans + L[i] * len(H[i])\n    print(ans)\n    q = int(sys.stdin.readline().strip())\n    for i in range (0, q):\n        v = int(sys.stdin.readline().strip()) - 1\n        ans = ans - L[v] * len(H[v])\n        L[v] = L[v] + len(H[v])\n        while len(H[v]) > 0:\n            w = H[v].pop()\n            H[w].append(v)\n            L[w] = L[w] - 1\n            ans = ans + L[w] - len(H[w]) + 1\n        print(ans)",
        "inputs": [
            "4 5\n1 2\n2 4\n1 3\n3 4\n2 3\n2\n2\n3\n",
            "3 3\n1 2\n2 3\n1 3\n5\n1\n2\n2\n1\n3\n",
            "1 0\n0\n"
        ],
        "outputs": [
            "4\n3\n2\n",
            "1\n1\n1\n1\n1\n1\n",
            "0\n"
        ],
        "starter_code": "\ndef ISRKo():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                6,
                13
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "For Loop Body",
                15,
                16
            ],
            [
                "For Loop Body",
                19,
                28
            ],
            [
                "While Loop Body",
                23,
                27
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef QhwtV():\n    \"\"\"In some game by Playrix it takes t minutes for an oven to bake k carrot cakes, all cakes are ready at the same moment t minutes after they started baking. Arkady needs at least n cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take d minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.\n\nDetermine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get n cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.\n\n\n-----Input-----\n\nThe only line contains four integers n, t, k, d (1 ≤ n, t, k, d ≤ 1 000) — the number of cakes needed, the time needed for one oven to bake k cakes, the number of cakes baked at the same time, the time needed to build the second oven. \n\n\n-----Output-----\n\nIf it is reasonable to build the second oven, print \"YES\". Otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n8 6 4 5\n\nOutput\nYES\n\nInput\n8 6 4 6\n\nOutput\nNO\n\nInput\n10 3 11 4\n\nOutput\nNO\n\nInput\n4 2 1 4\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. \n\nIn the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.\n\nIn the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.\n    \"\"\"\n",
        "canonical_solution": "import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom bisect import bisect_left, bisect_right\nfrom copy import copy, deepcopy\nfrom math import factorial as fact\ndef QhwtV():\n    class Solver:\n        def __init__(self):\n            pass\n        def solve(self):\n            n, t, k, d = list(map(int, input().split()))\n            n = (n + k - 1) // k\n            if d < (n-1) * t:\n                print('YES')\n            else:\n                print('NO')\n    def __starting_point():\n        s = Solver()\n        s.solve()\n    __starting_point()",
        "inputs": [
            "8 6 4 5\n",
            "8 6 4 6\n",
            "10 3 11 4\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef QhwtV():\n",
        "scope": [
            [
                "Function Body",
                8,
                22
            ],
            [
                "Class Body",
                9,
                18
            ],
            [
                "Function Body",
                10,
                11
            ],
            [
                "Function Body",
                12,
                18
            ],
            [
                "If Statement Body",
                15,
                18
            ],
            [
                "Function Body",
                19,
                21
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef abLrJ():\n    \"\"\"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.\n\nSergey gives Nastya the word t and wants to get the word p out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word t: a_1... a_{|}t|. We denote the length of word x as |x|. Note that after removing one letter, the indices of other letters don't change. For example, if t = \"nastya\" and a = [4, 1, 5, 3, 2, 6] then removals make the following sequence of words \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\".\n\nSergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word p. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.\n\nIt is guaranteed that the word p can be obtained by removing the letters from word t.\n\n\n-----Input-----\n\nThe first and second lines of the input contain the words t and p, respectively. Words are composed of lowercase letters of the Latin alphabet (1 ≤ |p| < |t| ≤ 200 000). It is guaranteed that the word p can be obtained by removing the letters from word t.\n\nNext line contains a permutation a_1, a_2, ..., a_{|}t| of letter indices that specifies the order in which Nastya removes letters of t (1 ≤ a_{i} ≤ |t|, all a_{i} are distinct).\n\n\n-----Output-----\n\nPrint a single integer number, the maximum number of letters that Nastya can remove.\n\n\n-----Examples-----\nInput\nababcba\nabb\n5 3 4 1 7 6 2\n\nOutput\n3\nInput\nbbbabb\nbb\n1 6 3 4 2 5\n\nOutput\n4\n\n\n-----Note-----\n\nIn the first sample test sequence of removing made by Nastya looks like this:\n\n\"ababcba\" $\\rightarrow$ \"ababcba\" $\\rightarrow$ \"ababcba\" $\\rightarrow$ \"ababcba\" \n\nNastya can not continue, because it is impossible to get word \"abb\" from word \"ababcba\".\n\nSo, Nastya will remove only three letters.\n    \"\"\"\n",
        "canonical_solution": "\ndef abLrJ():\n    def sub(a, s):\n        pa = 0\n        ps = 0\n        while pa < len(a) and ps < len(s):\n            if a[pa] == s[ps]:\n                ps += 1\n                pa += 1\n            else:\n                pa += 1\n    \n        return ps == len(s)\n    \n    def subword(t, ord_ar, n):\n        t_copy = []\n        for i in range(len(ord_ar)):\n            if ord_ar[i] >= n:\n                t_copy.append(t[i])\n        return t_copy\n    \n    def check(t, p, ord_ar, n):\n        s = subword(t, ord_ar, n)\n        return sub(s, p)\n    \n    def bin_s(l, r, f):\n        while r > l + 1:\n            m = (r + l) // 2\n            if f(m):\n                l = m\n            else:\n                r = m\n        return l\n    \n    \n    \n    def main():\n        t = input().strip()\n        p = input().strip()\n        ord_ar = [0]*len(t)\n        \n        seq = list(map(int, input().strip().split()))\n        for i,x in enumerate(seq):\n            ord_ar[x-1] = i\n    \n        ans = bin_s(0, len(t), lambda n: check(t, p, ord_ar, n))\n        print(ans)\n    \n    main()\n    ",
        "inputs": [
            "ababcba\nabb\n5 3 4 1 7 6 2\n",
            "bbbabb\nbb\n1 6 3 4 2 5\n",
            "cacaccccccacccc\ncacc\n10 9 14 5 1 7 15 3 6 12 4 8 11 13 2\n"
        ],
        "outputs": [
            "3",
            "4",
            "9"
        ],
        "starter_code": "\ndef abLrJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                49
            ],
            [
                "Function Body",
                3,
                13
            ],
            [
                "While Loop Body",
                6,
                11
            ],
            [
                "If Statement Body",
                7,
                11
            ],
            [
                "Function Body",
                15,
                20
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "Function Body",
                22,
                24
            ],
            [
                "Function Body",
                26,
                33
            ],
            [
                "While Loop Body",
                27,
                32
            ],
            [
                "If Statement Body",
                29,
                32
            ],
            [
                "Function Body",
                37,
                47
            ],
            [
                "For Loop Body",
                43,
                44
            ],
            [
                "Lambda Expression",
                46,
                46
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef PpdZJ():\n    \"\"\"Lesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer a_{i} — the current skill level. All skills have the same maximum level A.\n\nAlong with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:  The number of skills that a character has perfected (i.e., such that a_{i} = A), multiplied by coefficient c_{f}. The minimum skill level among all skills (min a_{i}), multiplied by coefficient c_{m}. \n\nNow Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.\n\n\n-----Input-----\n\nThe first line of the input contains five space-separated integers n, A, c_{f}, c_{m} and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 10^9, 0 ≤ c_{f}, c_{m} ≤ 1000, 0 ≤ m ≤ 10^15).\n\nThe second line contains exactly n integers a_{i} (0 ≤ a_{i} ≤ A), separated by spaces, — the current levels of skills.\n\n\n-----Output-----\n\nOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.\n\nOn the second line print n integers a'_{i} (a_{i} ≤ a'_{i} ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.\n\n\n-----Examples-----\nInput\n3 5 10 1 5\n1 3 1\n\nOutput\n12\n2 5 2 \n\nInput\n3 5 10 1 339\n1 3 1\n\nOutput\n35\n5 5 5 \n\n\n\n-----Note-----\n\nIn the first test the optimal strategy is to increase the second skill to its maximum, and increase the two others by 1.\n\nIn the second test one should increase all skills to maximum.\n    \"\"\"\n",
        "canonical_solution": "import itertools\nimport bisect\ndef PpdZJ():\n    n, A, cf, cm, m = [int(x) for x in input().split()]\n    skills = [int(x) for x in input().split()]\n    sorted_skills = list(sorted((k, i) for i, k in enumerate(skills)))\n    bottom_lift = [0 for i in range(n)]\n    for i in range(1, n):\n        bottom_lift[i] = bottom_lift[i-1] + i * (sorted_skills[i][0] - sorted_skills[i-1][0])\n    root_lift = [0 for i in range(n+1)]\n    for i in range(1, n+1):\n        root_lift[i] = root_lift[i-1] + A - sorted_skills[n-i][0]\n    max_level = -1\n    for i in range(n+1):\n        money_left = m - root_lift[i]\n        if money_left < 0: break\n        k = min(bisect.bisect(bottom_lift, money_left), n-i)\n        money_left -= bottom_lift[k-1]\n        min_level = min(A, sorted_skills[k-1][0] + money_left//k) if k > 0 else A\n        level = cf*i + cm*min_level\n        if max_level < level:\n            max_level = level\n            argmax = i\n            argmax_min_level = min_level\n            argmax_k = k\n    ans = [0 for i in range(n)]\n    for i, skill in enumerate(sorted_skills):\n        if i < argmax_k:\n            ans[skill[1]] = argmax_min_level\n        elif i >= n - argmax:\n            ans[skill[1]] = A\n        else:\n            ans[skill[1]] = skill[0]\n    print(max_level)\n    for a in ans:\n        print(a, end = ' ')\n        ",
        "inputs": [
            "3 5 10 1 5\n1 3 1\n",
            "3 5 10 1 339\n1 3 1\n",
            "2 6 0 1 4\n5 1\n"
        ],
        "outputs": [
            "12\n2 5 2 \n",
            "35\n5 5 5 \n",
            "5\n5 5 \n"
        ],
        "starter_code": "\ndef PpdZJ():\n",
        "scope": [
            [
                "Function Body",
                3,
                36
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "Generator Expression",
                6,
                6
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "For Loop Body",
                14,
                25
            ],
            [
                "If Statement Body",
                16,
                16
            ],
            [
                "If Statement Body",
                21,
                25
            ],
            [
                "List Comprehension",
                26,
                26
            ],
            [
                "For Loop Body",
                27,
                33
            ],
            [
                "If Statement Body",
                28,
                33
            ],
            [
                "If Statement Body",
                30,
                33
            ],
            [
                "For Loop Body",
                35,
                36
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef lKpSP():\n    \"\"\"Sereja has two sequences a and b and number p. Sequence a consists of n integers a_1, a_2, ..., a_{n}. Similarly, sequence b consists of m integers b_1, b_2, ..., b_{m}. As usual, Sereja studies the sequences he has. Today he wants to find the number of positions q (q + (m - 1)·p ≤ n; q ≥ 1), such that sequence b can be obtained from sequence a_{q}, a_{q} + p, a_{q} + 2p, ..., a_{q} + (m - 1)p by rearranging elements.\n\nSereja needs to rush to the gym, so he asked to find all the described positions of q.\n\n\n-----Input-----\n\nThe first line contains three integers n, m and p (1 ≤ n, m ≤ 2·10^5, 1 ≤ p ≤ 2·10^5). The next line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The next line contains m integers b_1, b_2, ..., b_{m} (1 ≤ b_{i} ≤ 10^9).\n\n\n-----Output-----\n\nIn the first line print the number of valid qs. In the second line, print the valid values in the increasing order.\n\n\n-----Examples-----\nInput\n5 3 1\n1 2 3 2 1\n1 2 3\n\nOutput\n2\n1 3\n\nInput\n6 3 2\n1 3 2 2 3 1\n1 2 3\n\nOutput\n2\n1 2\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\ndef lKpSP():\n    n, m, p = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    u = defaultdict(int)\n    for i in b: u[i] += 1\n    ans = []\n    for q in range(p):\n        c = a[q: n: p]\n        if len(c) < m: break\n        v = defaultdict(int)\n        for i in c[: m]: v[i] += 1\n        d = q + 1\n        if u == v: ans.append(d)\n        for j, k in zip(c[: len(c) - m], c[m: ]):\n            v[j] -= 1\n            if v[j] == 0: v.pop(j)\n            v[k] += 1\n            d += p\n            if u == v: ans.append(d)\n    ans.sort()\n    print(len(ans))\n    print(' '.join(map(str, ans)))",
        "inputs": [
            "5 3 1\n1 2 3 2 1\n1 2 3\n",
            "6 3 2\n1 3 2 2 3 1\n1 2 3\n",
            "68 16 3\n5 3 4 3 3 3 2 2 2 3 2 4 2 2 2 2 4 3 5 1 1 2 2 2 3 1 5 1 2 2 1 5 1 5 3 2 3 5 2 1 1 4 2 3 4 3 4 3 3 1 3 4 1 5 2 5 3 4 4 1 4 5 5 1 1 2 2 2\n5 4 4 3 5 1 1 2 3 2 2 1 3 3 2 2\n"
        ],
        "outputs": [
            "2\n1 3\n",
            "2\n1 2\n",
            "3\n2 13 15\n"
        ],
        "starter_code": "\ndef lKpSP():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "For Loop Body",
                7,
                7
            ],
            [
                "For Loop Body",
                9,
                21
            ],
            [
                "If Statement Body",
                11,
                11
            ],
            [
                "For Loop Body",
                13,
                13
            ],
            [
                "If Statement Body",
                15,
                15
            ],
            [
                "For Loop Body",
                16,
                21
            ],
            [
                "If Statement Body",
                18,
                18
            ],
            [
                "If Statement Body",
                21,
                21
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef RPuSM():\n    \"\"\"There are N pinholes on the xy-plane. The i-th pinhole is located at (x_i,y_i).\nWe will denote the Manhattan distance between the i-th and j-th pinholes as d(i,j)(=|x_i-x_j|+|y_i-y_j|).\nYou have a peculiar pair of compasses, called Manhattan Compass.\nThis instrument always points at two of the pinholes.\nThe two legs of the compass are indistinguishable, thus we do not distinguish the following two states: the state where the compass points at the p-th and q-th pinholes, and the state where it points at the q-th and p-th pinholes.\nWhen the compass points at the p-th and q-th pinholes and d(p,q)=d(p,r), one of the legs can be moved so that the compass will point at the p-th and r-th pinholes.\nInitially, the compass points at the a-th and b-th pinholes.\nFind the number of the pairs of pinholes that can be pointed by the compass.\n\n-----Constraints-----\n - 2≦N≦10^5\n - 1≦x_i, y_i≦10^9\n - 1≦a < b≦N\n - When i ≠ j, (x_i, y_i) ≠ (x_j, y_j)\n - x_i and y_i are integers.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN a b\nx_1 y_1\n:\nx_N y_N\n\n-----Output-----\nPrint the number of the pairs of pinholes that can be pointed by the compass.\n\n-----Sample Input-----\n5 1 2\n1 1\n4 3\n6 1\n5 5\n4 8\n\n-----Sample Output-----\n4\n\nInitially, the compass points at the first and second pinholes.\nSince d(1,2) = d(1,3), the compass can be moved so that it will point at the first and third pinholes.\nSince d(1,3) = d(3,4), the compass can also point at the third and fourth pinholes.\nSince d(1,2) = d(2,5), the compass can also point at the second and fifth pinholes.\nNo other pairs of pinholes can be pointed by the compass, thus the answer is 4.\n    \"\"\"\n",
        "canonical_solution": "\ndef RPuSM():\n    N, a, b = list(map(int, input().split())); a -= 1; b -= 1\n    P = []\n    Q = []\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        P.append((x-y, x+y, i))\n        Q.append((x+y, x-y, i))\n    \n    d = max(abs(P[a][0] - P[b][0]), abs(P[a][1] - P[b][1]))\n    \n    *parent, = list(range(N))\n    def root(x):\n        if x == parent[x]:\n            return x\n        y = parent[x] = root(parent[x])\n        return y\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px < py:\n            parent[py] = px\n        else:\n            parent[px] = py\n    C = [0]*N\n    D = [0]*N\n    \n    def check(P0, i0, j0):\n        return abs(P0[i0][0] - P0[j0][0]) == abs(P0[i0][1] - P0[j0][1])\n    \n    def solve(P0):\n        P = P0[:]\n        P.sort()\n    \n        s = t = 0; prev = -1\n        for i in range(N):\n            x, y, i0 = P[i]\n            while t < N and P[t][0] < x-d or (P[t][0] == x-d and P[t][1] <= y+d): t += 1\n            while s < N and (P[s][0] < x-d or (P[s][0] == x-d and P[s][1] < y-d)): s += 1\n            if s < t:\n                j0 = P[s][2]\n                unite(i0, j0)\n                if check(P0, i0, j0):\n                    D[i0] += 1\n                else:\n                    C[i0] += 1\n                if s < t-1:\n                    j0 = P[t-1][2]\n                    if check(P0, i0, j0):\n                        D[i0] += 1\n                        C[i0] += t-s-2\n                    else:\n                        C[i0] += t-s-1\n                for j in range(max(prev, s), t-1):\n                    unite(P[j][2], P[j+1][2])\n                prev = t-1\n    solve(P)\n    solve(Q)\n    \n    S = T = 0\n    r = root(a)\n    for i in range(N):\n        if root(i) == r:\n            S += C[i]; T += D[i]\n    print((S + T//2))\n    ",
        "inputs": [
            "5 1 2\n1 1\n4 3\n6 1\n5 5\n4 8\n",
            "6 2 3\n1 3\n5 3\n3 5\n8 4\n4 7\n2 5\n",
            "8 1 2\n1 5\n4 3\n8 2\n4 7\n8 8\n3 3\n6 6\n4 8\n"
        ],
        "outputs": [
            "4\n",
            "4\n",
            "7\n"
        ],
        "starter_code": "\ndef RPuSM():\n",
        "scope": [
            [
                "Function Body",
                2,
                65
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "Function Body",
                14,
                18
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "Function Body",
                19,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ],
            [
                "Function Body",
                28,
                29
            ],
            [
                "Function Body",
                31,
                56
            ],
            [
                "For Loop Body",
                36,
                56
            ],
            [
                "While Loop Body",
                38,
                38
            ],
            [
                "While Loop Body",
                39,
                39
            ],
            [
                "If Statement Body",
                40,
                56
            ],
            [
                "If Statement Body",
                43,
                46
            ],
            [
                "If Statement Body",
                47,
                53
            ],
            [
                "If Statement Body",
                49,
                53
            ],
            [
                "For Loop Body",
                54,
                55
            ],
            [
                "For Loop Body",
                62,
                64
            ],
            [
                "If Statement Body",
                63,
                64
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef RCPmL():\n    \"\"\"Emuskald is an avid horticulturist and owns the world's longest greenhouse — it is effectively infinite in length.\n\nOver the years Emuskald has cultivated n plants in his greenhouse, of m different plant species numbered from 1 to m. His greenhouse is very narrow and can be viewed as an infinite line, with each plant occupying a single point on that line.\n\nEmuskald has discovered that each species thrives at a different temperature, so he wants to arrange m - 1 borders that would divide the greenhouse into m sections numbered from 1 to m from left to right with each section housing a single species. He is free to place the borders, but in the end all of the i-th species plants must reside in i-th section from the left.\n\nOf course, it is not always possible to place the borders in such way, so Emuskald needs to replant some of his plants. He can remove each plant from its position and place it anywhere in the greenhouse (at any real coordinate) with no plant already in it. Since replanting is a lot of stress for the plants, help Emuskald find the minimum number of plants he has to replant to be able to place the borders.\n\n\n-----Input-----\n\nThe first line of input contains two space-separated integers n and m (1 ≤ n, m ≤ 5000, n ≥ m), the number of plants and the number of different species. Each of the following n lines contain two space-separated numbers: one integer number s_{i} (1 ≤ s_{i} ≤ m), and one real number x_{i} (0 ≤ x_{i} ≤ 10^9), the species and position of the i-th plant. Each x_{i} will contain no more than 6 digits after the decimal point.\n\nIt is guaranteed that all x_{i} are different; there is at least one plant of each species; the plants are given in order \"from left to the right\", that is in the ascending order of their x_{i} coordinates (x_{i} < x_{i} + 1, 1 ≤ i < n).\n\n\n-----Output-----\n\nOutput a single integer — the minimum number of plants to be replanted.\n\n\n-----Examples-----\nInput\n3 2\n2 1\n1 2.0\n1 3.100\n\nOutput\n1\n\nInput\n3 3\n1 5.0\n2 5.5\n3 6.0\n\nOutput\n0\n\nInput\n6 3\n1 14.284235\n2 17.921382\n1 20.328172\n3 20.842331\n1 25.790145\n1 27.204125\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first test case, Emuskald can replant the first plant to the right of the last plant, so the answer is 1.\n\nIn the second test case, the species are already in the correct order, so no replanting is needed.\n    \"\"\"\n",
        "canonical_solution": "\ndef RCPmL():\n    n, m = map(int, input().split())\n    t = [int(input().split()[0]) for i in range(n)]\n    p = [0] * (m + 1)\n    for i, j in enumerate(t): p[j] = min(p[j], min(p[: j])) - 1\n    print(n + min(p))",
        "inputs": [
            "3 2\n2 1\n1 2.0\n1 3.100\n",
            "3 3\n1 5.0\n2 5.5\n3 6.0\n",
            "6 3\n1 14.284235\n2 17.921382\n1 20.328172\n3 20.842331\n1 25.790145\n1 27.204125\n"
        ],
        "outputs": [
            "1\n",
            "0\n",
            "2\n"
        ],
        "starter_code": "\ndef RCPmL():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                6,
                6
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef fOZBG():\n    \"\"\"In this problem, we will deal with binary strings. Each character of a binary string is either a 0 or a 1. We will also deal with substrings; recall that a substring is a contiguous subsequence of a string. We denote the substring of string $s$ starting from the $l$-th character and ending with the $r$-th character as $s[l \\dots r]$. The characters of each string are numbered from $1$.\n\nWe can perform several operations on the strings we consider. Each operation is to choose a substring of our string and replace it with another string. There are two possible types of operations: replace 011 with 110, or replace 110 with 011. For example, if we apply exactly one operation to the string 110011110, it can be transformed into 011011110, 110110110, or 110011011.\n\nBinary string $a$ is considered reachable from binary string $b$ if there exists a sequence $s_1$, $s_2$, ..., $s_k$ such that $s_1 = a$, $s_k = b$, and for every $i \\in [1, k - 1]$, $s_i$ can be transformed into $s_{i + 1}$ using exactly one operation. Note that $k$ can be equal to $1$, i. e., every string is reachable from itself.\n\nYou are given a string $t$ and $q$ queries to it. Each query consists of three integers $l_1$, $l_2$ and $len$. To answer each query, you have to determine whether $t[l_1 \\dots l_1 + len - 1]$ is reachable from $t[l_2 \\dots l_2 + len - 1]$.\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of string $t$.\n\nThe second line contains one string $t$ ($|t| = n$). Each character of $t$ is either 0 or 1.\n\nThe third line contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries.\n\nThen $q$ lines follow, each line represents a query. The $i$-th line contains three integers $l_1$, $l_2$ and $len$ ($1 \\le l_1, l_2 \\le |t|$, $1 \\le len \\le |t| - \\max(l_1, l_2) + 1$) for the $i$-th query.\n\n\n-----Output-----\n\nFor each query, print either YES if $t[l_1 \\dots l_1 + len - 1]$ is reachable from $t[l_2 \\dots l_2 + len - 1]$, or NO otherwise. You may print each letter in any register.\n\n\n-----Example-----\nInput\n5\n11011\n3\n1 3 3\n1 4 2\n1 2 3\n\nOutput\nYes\nYes\nNo\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef fOZBG():\n    input = sys.stdin.readline\n    MOD = 987654103\n    n = int(input())\n    t = input()\n    place = []\n    f1 = []\n    e1 = []\n    s = []\n    curr = 0\n    count1 = 0\n    for i in range(n):\n        c = t[i]\n        if c == '0':\n            if count1:\n                e1.append(i - 1)\n                if count1 & 1:\n                    s.append(1)\n                    curr += 1\n                    e1.append(-1)\n                    f1.append(-1)\n                count1 = 0\n            else:\n                f1.append(-1)\n                e1.append(-1)\n            place.append(curr)\n            curr += 1\n            s.append(0)\n        else:\n            if count1 == 0:\n                f1.append(i)\n            count1 += 1\n            place.append(curr)\n    if count1:\n        if count1 & 1:\n            s.append(1)\n        else:\n            s.append(0)\n        curr += 1\n        e1.append(n - 1)\n        e1.append(-1)\n        f1.append(-1)\n    place.append(curr)\n    pref = [0]\n    val = 0\n    for i in s:\n        val *= 3\n        val += i + 1\n        val %= MOD\n        pref.append(val)\n            \n    q = int(input())\n    out = []\n    for _ in range(q):\n        l1, l2, leng = list(map(int, input().split()))\n        l1 -= 1\n        l2 -= 1\n        starts = (l1, l2)\n        hashes = []\n        for start in starts:\n            end = start + leng - 1\n            smap = place[start]\n            emap = place[end]\n            if t[end] == '1':\n                emap -= 1\n            if s[smap] == 1:\n                smap += 1\n            prep = False\n            app = False\n            if t[start] == '1':\n                last = e1[place[start]]\n                last = min(last, end)\n                count = last - start + 1\n                if count % 2:\n                    prep = True\n            if t[end] == '1':\n                first = f1[place[end]]\n                first = max(first, start)\n                count = end - first + 1\n                if count % 2:\n                    app = True\n            preHash = 0\n            length = 0\n            if smap <= emap:\n                length = emap - smap + 1\n                preHash = pref[emap + 1]\n                preHash -= pref[smap] * pow(3, emap - smap + 1, MOD)\n                preHash %= MOD\n            if length == 0 and prep and app:\n                app = False\n            #print(preHash, prep, app, length)\n            if prep:\n                preHash += pow(3, length, MOD) * 2\n                length += 1\n            if app:\n                preHash *= 3\n                preHash += 2\n            #print(preHash)\n            preHash %= MOD\n            hashes.append(preHash)\n            \n        if hashes[0] == hashes[1]:\n            out.append('Yes')\n        else:\n            out.append('No')\n    print('\\n'.join(out))\n        ",
        "inputs": [
            "5\n11011\n3\n1 3 3\n1 4 2\n1 2 3\n",
            "1\n0\n1\n1 1 1\n",
            "3\n010\n3\n1 3 1\n1 3 1\n3 2 1\n"
        ],
        "outputs": [
            "Yes\nYes\nNo\n",
            "Yes\n",
            "Yes\nYes\nNo\n"
        ],
        "starter_code": "\ndef fOZBG():\n",
        "scope": [
            [
                "Function Body",
                2,
                107
            ],
            [
                "For Loop Body",
                13,
                34
            ],
            [
                "If Statement Body",
                15,
                34
            ],
            [
                "If Statement Body",
                16,
                26
            ],
            [
                "If Statement Body",
                18,
                22
            ],
            [
                "If Statement Body",
                31,
                32
            ],
            [
                "If Statement Body",
                35,
                43
            ],
            [
                "If Statement Body",
                36,
                39
            ],
            [
                "For Loop Body",
                47,
                51
            ],
            [
                "For Loop Body",
                55,
                106
            ],
            [
                "For Loop Body",
                61,
                101
            ],
            [
                "If Statement Body",
                65,
                66
            ],
            [
                "If Statement Body",
                67,
                68
            ],
            [
                "If Statement Body",
                71,
                76
            ],
            [
                "If Statement Body",
                75,
                76
            ],
            [
                "If Statement Body",
                77,
                82
            ],
            [
                "If Statement Body",
                81,
                82
            ],
            [
                "If Statement Body",
                85,
                89
            ],
            [
                "If Statement Body",
                90,
                91
            ],
            [
                "If Statement Body",
                93,
                95
            ],
            [
                "If Statement Body",
                96,
                98
            ],
            [
                "If Statement Body",
                103,
                106
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef gnDsz():\n    \"\"\"There is a string S of length N consisting of characters 0 and 1. You will perform the following operation for each i = 1, 2, ..., m:\n - Arbitrarily permute the characters within the substring of S starting at the l_i-th character from the left and extending through the r_i-th character.\nHere, the sequence l_i is non-decreasing.\nHow many values are possible for S after the M operations, modulo 1000000007(= 10^9+7)?\n\n-----Constraints-----\n - 2≦N≦3000\n - 1≦M≦3000\n - S consists of characters 0 and 1.\n - The length of S equals N.\n - 1≦l_i < r_i≦N\n - l_i ≦ l_{i+1}\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN M\nS\nl_1 r_1\n:\nl_M r_M\n\n-----Output-----\nPrint the number of the possible values for S after the M operations, modulo 1000000007.\n\n-----Sample Input-----\n5 2\n01001\n2 4\n3 5\n\n-----Sample Output-----\n6\n\nAfter the first operation, S can be one of the following three: 01001, 00101 and 00011.\nAfter the second operation, S can be one of the following six: 01100, 01010, 01001, 00011, 00101 and 00110.\n    \"\"\"\n",
        "canonical_solution": "\ndef gnDsz():\n    #!/usr/bin/env python3\n    \n    \n    M = 10 ** 9 + 7\n    \n    \n    def solve(n, m, s, lst):\n    \n        cnt = [0] * n\n        t = 0\n        for i in range(n):\n            if s[i] == '1':\n                t += 1\n            cnt[i] = t\n    \n    \n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        r = 0\n        j = 0\n        for i in range(n):\n            while j < m:\n                lj, rj = lst[j]\n                if lj <= i:\n                    r = max(r, rj)\n                    j += 1\n                else:\n                    break\n            if r <= i:\n                c = cnt[i]\n                if 0 < c:\n                    dp[i + 1][cnt[i]] = (dp[i][c] + dp[i][c - 1]) % M\n                else:\n                    dp[i + 1][0] = dp[i][0]\n            else:\n                for k in range(max(0, cnt[r] - r + i), min(i + 1, cnt[r]) + 1):\n                    if 0 < k:\n                        dp[i + 1][k] = (dp[i][k] + dp[i][k - 1]) % M\n                    else:\n                        dp[i + 1][0] = dp[i][0]\n    \n        return dp[n][cnt[n - 1]]\n    \n    \n    def main():\n        n, m = input().split()\n        n = int(n)\n        m = int(m)\n        s = input()\n        lst = []\n        for _ in range(m):\n            l, r = input().split()\n            l = int(l) - 1\n            r = int(r) - 1\n            lst.append((l, r))\n    \n        print((solve(n, m, s, lst)))\n    \n    \n    def __starting_point():\n        main()\n    \n    \n    __starting_point()",
        "inputs": [
            "5 2\n01001\n2 4\n3 5\n",
            "9 3\n110111110\n1 4\n4 6\n6 9\n",
            "11 6\n00101000110\n2 4\n2 3\n4 7\n5 6\n6 10\n10 11\n"
        ],
        "outputs": [
            "6\n",
            "26\n",
            "143\n"
        ],
        "starter_code": "\ndef gnDsz():\n",
        "scope": [
            [
                "Function Body",
                2,
                66
            ],
            [
                "Function Body",
                9,
                44
            ],
            [
                "For Loop Body",
                13,
                16
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "For Loop Body",
                23,
                42
            ],
            [
                "While Loop Body",
                24,
                30
            ],
            [
                "If Statement Body",
                26,
                30
            ],
            [
                "If Statement Body",
                31,
                42
            ],
            [
                "If Statement Body",
                33,
                36
            ],
            [
                "For Loop Body",
                38,
                42
            ],
            [
                "If Statement Body",
                39,
                42
            ],
            [
                "Function Body",
                47,
                59
            ],
            [
                "For Loop Body",
                53,
                57
            ],
            [
                "Function Body",
                62,
                63
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef Uhsdj():\n    \"\"\"You have a team of N people. For a particular task, you can pick any non-empty subset of people. The cost of having x people for the task is x^{k}. \n\nOutput the sum of costs over all non-empty subsets of people.\n\n\n-----Input-----\n\nOnly line of input contains two integers N (1 ≤ N ≤ 10^9) representing total number of people and k (1 ≤ k ≤ 5000).\n\n\n-----Output-----\n\nOutput the sum of costs for all non empty subsets modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n1 1\n\nOutput\n1\n\nInput\n3 2\n\nOutput\n24\n\n\n\n-----Note-----\n\nIn the first example, there is only one non-empty subset {1} with cost 1^1 = 1.\n\nIn the second example, there are seven non-empty subsets.\n\n- {1} with cost 1^2 = 1\n\n- {2} with cost 1^2 = 1\n\n- {1, 2} with cost 2^2 = 4\n\n- {3} with cost 1^2 = 1\n\n- {1, 3} with cost 2^2 = 4\n\n- {2, 3} with cost 2^2 = 4\n\n- {1, 2, 3} with cost 3^2 = 9\n\nThe total cost is 1 + 1 + 4 + 1 + 4 + 4 + 9 = 24.\n    \"\"\"\n",
        "canonical_solution": "\ndef Uhsdj():\n    n, k = list(map(int, input().split()))\n    m = 0x3b9aca07\n    v = 500000004\n    r = 0\n    p = pow(2, n, m)\n    a = [1] + [0] * k\n    for i in range(k):\n        for j in range(i, -1, -1):\n            a[j + 1] += a[j]\n            a[j] = a[j] * j % m\n    for i in range(k + 1):\n        r = (r + p * a[i]) % m\n        p = p * v * (n - i) % m\n    print(r)\n    ",
        "inputs": [
            "1 1\n",
            "3 2\n",
            "5 3\n"
        ],
        "outputs": [
            "1\n",
            "24\n",
            "800\n"
        ],
        "starter_code": "\ndef Uhsdj():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "For Loop Body",
                13,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef vuWLh():\n    \"\"\"Permutation p is an ordered set of integers p_1,   p_2,   ...,   p_{n}, consisting of n distinct positive integers not larger than n. We'll denote as n the length of permutation p_1,   p_2,   ...,   p_{n}.\n\nYour task is to find such permutation p of length n, that the group of numbers |p_1 - p_2|, |p_2 - p_3|, ..., |p_{n} - 1 - p_{n}| has exactly k distinct elements.\n\n\n-----Input-----\n\nThe single line of the input contains two space-separated positive integers n, k (1 ≤ k < n ≤ 10^5).\n\n\n-----Output-----\n\nPrint n integers forming the permutation. If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n1 3 2\n\nInput\n3 1\n\nOutput\n1 2 3\n\nInput\n5 2\n\nOutput\n1 3 2 4 5\n\n\n\n-----Note-----\n\nBy |x| we denote the absolute value of number x.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef vuWLh():\n    3\n    def __starting_point():\n        \n        n, k = list(map(int, sys.stdin.readline().split()))\n        l = []\n        i = 1\n        j = k + 1\n        while i <= j:\n            l.append(str(i))\n            i += 1\n            if j > i:\n                l.append(str(j))\n                j -= 1\n        for i in range(k+2, n+1):\n            l.append(str(i))\n        \n        print(' '.join(l))\n    __starting_point()",
        "inputs": [
            "3 2\n",
            "3 1\n",
            "5 2\n"
        ],
        "outputs": [
            "1 3 2\n",
            "1 2 3\n",
            "1 3 2 4 5\n"
        ],
        "starter_code": "\ndef vuWLh():\n",
        "scope": [
            [
                "Function Body",
                2,
                20
            ],
            [
                "Function Body",
                4,
                19
            ],
            [
                "While Loop Body",
                10,
                15
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "For Loop Body",
                16,
                17
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef VloLN():\n    \"\"\"You are fishing with polar bears Alice and Bob. While waiting for the fish to bite, the polar bears get bored. They come up with a game. First Alice and Bob each writes a 01-string (strings that only contain character \"0\" and \"1\") a and b. Then you try to turn a into b using two types of operations:  Write parity(a) to the end of a. For example, $1010 \\rightarrow 10100$.  Remove the first character of a. For example, $1001 \\rightarrow 001$. You cannot perform this operation if a is empty. \n\nYou can use as many operations as you want. The problem is, is it possible to turn a into b?\n\nThe parity of a 01-string is 1 if there is an odd number of \"1\"s in the string, and 0 otherwise.\n\n\n-----Input-----\n\nThe first line contains the string a and the second line contains the string b (1 ≤ |a|, |b| ≤ 1000). Both strings contain only the characters \"0\" and \"1\". Here |x| denotes the length of the string x.\n\n\n-----Output-----\n\nPrint \"YES\" (without quotes) if it is possible to turn a into b, and \"NO\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n01011\n0110\n\nOutput\nYES\n\nInput\n0011\n1110\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample, the steps are as follows: 01011 → 1011 → 011 → 0110\n    \"\"\"\n",
        "canonical_solution": "\ndef VloLN():\n    print('YES' if input().count('1')+1>>1<<1 >= input().count('1') else 'NO')",
        "inputs": [
            "01011\n0110\n",
            "0011\n1110\n",
            "11111\n111111\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "YES\n"
        ],
        "starter_code": "\ndef VloLN():\n",
        "scope": [
            [
                "Function Body",
                2,
                3
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef bTOVh():\n    \"\"\"Welcome to Innopolis city. Throughout the whole year, Innopolis citizens suffer from everlasting city construction. \n\nFrom the window in your room, you see the sequence of n hills, where i-th of them has height a_{i}. The Innopolis administration wants to build some houses on the hills. However, for the sake of city appearance, a house can be only built on the hill, which is strictly higher than neighbouring hills (if they are present). For example, if the sequence of heights is 5, 4, 6, 2, then houses could be built on hills with heights 5 and 6 only.\n\nThe Innopolis administration has an excavator, that can decrease the height of an arbitrary hill by one in one hour. The excavator can only work on one hill at a time. It is allowed to decrease hills up to zero height, or even to negative values. Increasing height of any hill is impossible. The city administration wants to build k houses, so there must be at least k hills that satisfy the condition above. What is the minimum time required to adjust the hills to achieve the administration's plan?\n\nHowever, the exact value of k is not yet determined, so could you please calculate answers for all k in range $1 \\leq k \\leq \\lceil \\frac{n}{2} \\rceil$? Here $\\lceil \\frac{n}{2} \\rceil$ denotes n divided by two, rounded up.\n\n\n-----Input-----\n\nThe first line of input contains the only integer n (1 ≤ n ≤ 5000)—the number of the hills in the sequence.\n\nSecond line contains n integers a_{i} (1 ≤ a_{i} ≤ 100 000)—the heights of the hills in the sequence.\n\n\n-----Output-----\n\nPrint exactly $\\lceil \\frac{n}{2} \\rceil$ numbers separated by spaces. The i-th printed number should be equal to the minimum number of hours required to level hills so it becomes possible to build i houses.\n\n\n-----Examples-----\nInput\n5\n1 1 1 1 1\n\nOutput\n1 2 2 \n\nInput\n3\n1 2 3\n\nOutput\n0 2 \n\nInput\n5\n1 2 3 2 2\n\nOutput\n0 1 3 \n\n\n\n-----Note-----\n\nIn the first example, to get at least one hill suitable for construction, one can decrease the second hill by one in one hour, then the sequence of heights becomes 1, 0, 1, 1, 1 and the first hill becomes suitable for construction.\n\nIn the first example, to get at least two or at least three suitable hills, one can decrease the second and the fourth hills, then the sequence of heights becomes 1, 0, 1, 0, 1, and hills 1, 3, 5 become suitable for construction.\n    \"\"\"\n",
        "canonical_solution": "\ndef bTOVh():\n    def main():\n        n, a, z = int(input()), 0, 10 ** 10\n        b, *cc = list(map(int, input().split()))\n        dp = [(0, z, z), (z, 0, z), *[(z, z, z)] * ((n - 1) // 2)]\n        for i, c in enumerate(cc, 1):\n            u, v, w = dp[i // 2 + 1]\n            dz = max(0, c - b + 1)\n            du = max(0, b - c + 1)\n            dw = max(0, min(a - 1, b) - c + 1)\n            for j in range(i // 2, -1, -1):\n                x, y, z = u, v, w\n                u, v, w = dp[j]\n                dp[j + 1] = (x if x < z else z, min(u + du, w + dw), y + dz)\n            a, b = b, c\n        print(' '.join(map(str, list(map(min, dp[1:])))))\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "5\n1 1 1 1 1\n",
            "3\n1 2 3\n",
            "5\n1 2 3 2 2\n"
        ],
        "outputs": [
            "1 2 2 \n",
            "0 2 \n",
            "0 1 3 \n"
        ],
        "starter_code": "\ndef bTOVh():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "Function Body",
                3,
                17
            ],
            [
                "For Loop Body",
                7,
                16
            ],
            [
                "For Loop Body",
                12,
                15
            ],
            [
                "Function Body",
                20,
                21
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef SLDOv():\n    \"\"\"Kevin and Nicky Sun have invented a new game called Lieges of Legendre. In this game, two players take turns modifying the game state with Kevin moving first. Initially, the game is set up so that there are n piles of cows, with the i-th pile containing a_{i} cows. During each player's turn, that player calls upon the power of Sunlight, and uses it to either:\n\n  Remove a single cow from a chosen non-empty pile.  Choose a pile of cows with even size 2·x (x > 0), and replace it with k piles of x cows each. \n\nThe player who removes the last cow wins. Given n, k, and a sequence a_1, a_2, ..., a_{n}, help Kevin and Nicky find the winner, given that both sides play in optimal way.\n\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n and k (1 ≤ n ≤ 100 000, 1 ≤ k ≤ 10^9).\n\nThe second line contains n integers, a_1, a_2, ... a_{n} (1 ≤ a_{i} ≤ 10^9) describing the initial state of the game. \n\n\n-----Output-----\n\nOutput the name of the winning player, either \"Kevin\" or \"Nicky\" (without quotes).\n\n\n-----Examples-----\nInput\n2 1\n3 4\n\nOutput\nKevin\n\nInput\n1 2\n3\n\nOutput\nNicky\n\n\n\n-----Note-----\n\nIn the second sample, Nicky can win in the following way: Kevin moves first and is forced to remove a cow, so the pile contains two cows after his move. Next, Nicky replaces this pile of size 2 with two piles of size 1. So the game state is now two piles of size 1. Kevin then removes one of the remaining cows and Nicky wins by removing the other.\n    \"\"\"\n",
        "canonical_solution": "\ndef SLDOv():\n    def grundy(n, k):\n        if k % 2 == 0:\n            if n <= 2:\n                return n\n            else:\n                return n % 2 == 0\n        else:\n            if n <= 4:\n                return [0, 1, 0, 1, 2][n]\n            elif n % 2 == 1:\n                return 0\n            else:\n                return 2 if grundy(n // 2, k) == 1 else 1\n    \n    \n    def __starting_point():\n        n, k = list(map(int, input().split()))\n        xList = list(map(int, input().split()))\n        res = 0\n        for x in xList:\n            res ^= grundy(x, k)\n        print(\"Kevin\" if res else \"Nicky\")\n    \n    \n    __starting_point()",
        "inputs": [
            "2 1\n3 4\n",
            "1 2\n3\n",
            "4 5\n20 21 22 25\n"
        ],
        "outputs": [
            "Kevin\n",
            "Nicky\n",
            "Kevin\n"
        ],
        "starter_code": "\ndef SLDOv():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                3,
                15
            ],
            [
                "If Statement Body",
                4,
                15
            ],
            [
                "If Statement Body",
                5,
                8
            ],
            [
                "If Statement Body",
                10,
                15
            ],
            [
                "If Statement Body",
                12,
                15
            ],
            [
                "Function Body",
                18,
                24
            ],
            [
                "For Loop Body",
                22,
                23
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef oNlIv():\n    \"\"\"You are given $n$ rectangles on a plane with coordinates of their bottom left and upper right points. Some $(n-1)$ of the given $n$ rectangles have some common point. A point belongs to a rectangle if this point is strictly inside the rectangle or belongs to its boundary.\n\nFind any point with integer coordinates that belongs to at least $(n-1)$ given rectangles.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\le n \\le 132\\,674$) — the number of given rectangles.\n\nEach the next $n$ lines contains four integers $x_1$, $y_1$, $x_2$ and $y_2$ ($-10^9 \\le x_1 < x_2 \\le 10^9$, $-10^9 \\le y_1 < y_2 \\le 10^9$) — the coordinates of the bottom left and upper right corners of a rectangle.\n\n\n-----Output-----\n\nPrint two integers $x$ and $y$ — the coordinates of any point that belongs to at least $(n-1)$ given rectangles.\n\n\n-----Examples-----\nInput\n3\n0 0 1 1\n1 1 2 2\n3 0 4 1\n\nOutput\n1 1\n\nInput\n3\n0 0 1 1\n0 1 1 2\n1 0 2 1\n\nOutput\n1 1\n\nInput\n4\n0 0 5 5\n0 0 4 4\n1 1 4 4\n1 1 4 4\n\nOutput\n1 1\n\nInput\n5\n0 0 10 8\n1 2 6 7\n2 3 5 6\n3 4 4 5\n8 1 9 2\n\nOutput\n3 4\n\n\n\n-----Note-----\n\nThe picture below shows the rectangles in the first and second samples. The possible answers are highlighted. [Image] \n\nThe picture below shows the rectangles in the third and fourth samples. [Image]\n    \"\"\"\n",
        "canonical_solution": "\ndef oNlIv():\n    def excl_max_list(a):\n        first_max = max(a)\n        imax = a.index(first_max)\n        second_max = max(a[:imax] + a[imax + 1:])\n        return [second_max if elem == first_max else first_max for elem in a]\n    \n    def excl_min_list(a):\n        first_min = min(a)\n        imin = a.index(first_min)\n        second_min = min(a[:imin] + a[imin + 1:])\n        return [second_min if elem == first_min else first_min for elem in a]\n    \n    n = int(input())\n    rectangles = [tuple(map(int, input().split())) for i in range(n)]\n    lefts = [l for l, d, r, u in rectangles]\n    rights = [r for l, d, r, u in rectangles]\n    downs = [d for l, d, r, u in rectangles]\n    ups = [u for l, d, r, u in rectangles]\n    \n    max_lefts = excl_max_list(lefts)\n    max_downs = excl_max_list(downs)\n    min_rights = excl_min_list(rights)\n    min_ups = excl_min_list(ups)\n    \n    for i in range(n):\n        if max_lefts[i] <= min_rights[i] and max_downs[i] <= min_ups[i]:\n            print(max_lefts[i], max_downs[i])\n            break\n    ",
        "inputs": [
            "3\n0 0 1 1\n1 1 2 2\n3 0 4 1\n",
            "3\n0 0 1 1\n0 1 1 2\n1 0 2 1\n",
            "4\n0 0 5 5\n0 0 4 4\n1 1 4 4\n1 1 4 4\n"
        ],
        "outputs": [
            "1 1\n",
            "1 1\n",
            "1 1\n"
        ],
        "starter_code": "\ndef oNlIv():\n",
        "scope": [
            [
                "Function Body",
                2,
                30
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "Function Body",
                9,
                13
            ],
            [
                "List Comprehension",
                13,
                13
            ],
            [
                "List Comprehension",
                16,
                16
            ],
            [
                "List Comprehension",
                17,
                17
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "List Comprehension",
                20,
                20
            ],
            [
                "For Loop Body",
                27,
                30
            ],
            [
                "If Statement Body",
                28,
                30
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef jwegC():\n    \"\"\"Once Vasya and Petya assembled a figure of m cubes, each of them is associated with a number between 0 and m - 1 (inclusive, each number appeared exactly once). Let's consider a coordinate system such that the OX is the ground, and the OY is directed upwards. Each cube is associated with the coordinates of its lower left corner, these coordinates are integers for each cube.\n\nThe figure turned out to be stable. This means that for any cube that is not on the ground, there is at least one cube under it such that those two cubes touch by a side or a corner. More formally, this means that for the cube with coordinates (x, y) either y = 0, or there is a cube with coordinates (x - 1, y - 1), (x, y - 1) or (x + 1, y - 1).\n\nNow the boys want to disassemble the figure and put all the cubes in a row. In one step the cube is removed from the figure and being put to the right of the blocks that have already been laid. The guys remove the cubes in such order that the figure remains stable. To make the process more interesting, the guys decided to play the following game. The guys take out the cubes from the figure in turns. It is easy to see that after the figure is disassembled, the integers written on the cubes form a number, written in the m-ary positional numerical system (possibly, with a leading zero). Vasya wants the resulting number to be maximum possible, and Petya, on the contrary, tries to make it as small as possible. Vasya starts the game.\n\nYour task is to determine what number is formed after the figure is disassembled, if the boys play optimally. Determine the remainder of the answer modulo 10^9 + 9.\n\n\n-----Input-----\n\nThe first line contains number m (2 ≤ m ≤ 10^5).\n\nThe following m lines contain the coordinates of the cubes x_{i}, y_{i} ( - 10^9 ≤ x_{i} ≤ 10^9, 0 ≤ y_{i} ≤ 10^9) in ascending order of numbers written on them. It is guaranteed that the original figure is stable.\n\nNo two cubes occupy the same place.\n\n\n-----Output-----\n\nIn the only line print the answer to the problem.\n\n\n-----Examples-----\nInput\n3\n2 1\n1 0\n0 1\n\nOutput\n19\n\nInput\n5\n0 0\n0 1\n0 2\n0 3\n0 4\n\nOutput\n2930\n    \"\"\"\n",
        "canonical_solution": "import heapq\ndef jwegC():\n    def coor_neighbor(coor, dxs, dys):\n        x, y = coor\n        for dx in dxs:\n            for dy in dys:\n                yield x + dx, y + dy\n    def coor_bottoms(coor):\n        return coor_neighbor(coor, (-1, 0, 1), (-1, ))\n    def coor_tops(coor):\n        return coor_neighbor(coor, (-1, 0, 1), (1, ))\n    def coor_sibs(coor):\n        return coor_neighbor(coor, (-2, -1, 1, 2), (0, ))\n    class Figure:\n        def __init__(self, coors):\n            self._coors = dict()\n            self._stables_min = []\n            self._stables_max = []\n            self._pushed = set()\n            self._dropped = set()\n            cubes = dict()\n            self._bots = dict()\n            self._tops = dict()\n            for idx, coor in enumerate(coors):\n                cubes[coor] = idx\n                self._coors[idx] = coor\n                self._bots[idx] = set()\n                self._tops[idx] = set()\n            coor_set = set(coors)\n            for idx, coor in enumerate(coors):\n                for bottom in coor_bottoms(coor):\n                    if bottom in coor_set:\n                        self._bots[idx].add(cubes[bottom])\n                for top in coor_tops(coor):\n                    if top in coor_set:\n                        self._tops[idx].add(cubes[top])\n            for idx in self._coors:\n                if self.isdroppable(idx):\n                    self.push(idx)\n        def sibs(self, idx):\n            for top_idx in self._tops[idx]:\n                for sib_idx in self._bots[top_idx]:\n                    if sib_idx not in self._dropped:\n                        yield sib_idx\n        def bottom_count(self, idx):\n            return len(self._bots[idx])\n        def isdroppable(self, idx):\n            return all(len(self._bots[top_idx]) > 1 for top_idx in self._tops[idx])\n        def push(self, idx):\n            if idx not in self._pushed:\n                heapq.heappush(self._stables_min, idx)\n                heapq.heappush(self._stables_max, -idx)\n                self._pushed.add(idx)\n        def unpush(self, idx):\n            if idx in self._pushed:\n                self._pushed.remove(idx)\n        def drop(self, idx):\n            if idx not in self._pushed:\n                return False\n            self._pushed.remove(idx)\n            self._dropped.add(idx)\n            for bot_idx in self._bots[idx]:\n                self._tops[bot_idx].remove(idx)\n            for top_idx in self._tops[idx]:\n                self._bots[top_idx].remove(idx)\n            coor = self._coors[idx]\n            for bot_idx in self._bots[idx]:\n                if self.isdroppable(bot_idx):\n                    self.push(bot_idx)\n            for sib_idx in self.sibs(idx):\n                if not self.isdroppable(sib_idx):\n                    self.unpush(sib_idx)\n            return True\n        def drop_min(self):\n            while True:\n                if not self._stables_min:\n                    return None\n                min_idx = heapq.heappop(self._stables_min)\n                if self.drop(min_idx):\n                    return min_idx\n        def drop_max(self):\n            while True:\n                if not self._stables_max:\n                    return None\n                max_idx = - heapq.heappop(self._stables_max)\n                if self.drop(max_idx):\n                    return max_idx\n        def __bool__(self):\n            return len(self._coors) != len(self._dropped)\n    def input_tuple():\n        return tuple(map(int, input().split()))\n    def result_add(result, base, num):\n        return (result * base + num) % (10 ** 9 + 9)\n    N = int(input())\n    coors = [input_tuple() for _ in range(N)]\n    figure = Figure(coors)\n    result = 0\n    while True:\n        if not figure:\n            break\n        result = result_add(result, N, figure.drop_max())\n        if not figure:\n            break\n        result = result_add(result, N, figure.drop_min())\n    print(result)",
        "inputs": [
            "3\n2 1\n1 0\n0 1\n",
            "5\n0 0\n0 1\n0 2\n0 3\n0 4\n",
            "10\n-1 2\n-3 0\n5 5\n4 4\n-2 1\n1 1\n3 3\n2 2\n0 0\n-1000000000 0\n"
        ],
        "outputs": [
            "19\n",
            "2930\n",
            "41236677\n"
        ],
        "starter_code": "\ndef jwegC():\n",
        "scope": [
            [
                "Function Body",
                2,
                105
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "Function Body",
                8,
                9
            ],
            [
                "Function Body",
                10,
                11
            ],
            [
                "Function Body",
                12,
                13
            ],
            [
                "Class Body",
                14,
                89
            ],
            [
                "Function Body",
                15,
                39
            ],
            [
                "For Loop Body",
                24,
                28
            ],
            [
                "For Loop Body",
                30,
                36
            ],
            [
                "For Loop Body",
                31,
                33
            ],
            [
                "If Statement Body",
                32,
                33
            ],
            [
                "For Loop Body",
                34,
                36
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "For Loop Body",
                37,
                39
            ],
            [
                "If Statement Body",
                38,
                39
            ],
            [
                "Function Body",
                40,
                44
            ],
            [
                "For Loop Body",
                41,
                44
            ],
            [
                "For Loop Body",
                42,
                44
            ],
            [
                "If Statement Body",
                43,
                44
            ],
            [
                "Function Body",
                45,
                46
            ],
            [
                "Function Body",
                47,
                48
            ],
            [
                "Generator Expression",
                48,
                48
            ],
            [
                "Function Body",
                49,
                53
            ],
            [
                "If Statement Body",
                50,
                53
            ],
            [
                "Function Body",
                54,
                56
            ],
            [
                "If Statement Body",
                55,
                56
            ],
            [
                "Function Body",
                57,
                73
            ],
            [
                "If Statement Body",
                58,
                59
            ],
            [
                "For Loop Body",
                62,
                63
            ],
            [
                "For Loop Body",
                64,
                65
            ],
            [
                "For Loop Body",
                67,
                69
            ],
            [
                "If Statement Body",
                68,
                69
            ],
            [
                "For Loop Body",
                70,
                72
            ],
            [
                "If Statement Body",
                71,
                72
            ],
            [
                "Function Body",
                74,
                80
            ],
            [
                "While Loop Body",
                75,
                80
            ],
            [
                "If Statement Body",
                76,
                77
            ],
            [
                "If Statement Body",
                79,
                80
            ],
            [
                "Function Body",
                81,
                87
            ],
            [
                "While Loop Body",
                82,
                87
            ],
            [
                "If Statement Body",
                83,
                84
            ],
            [
                "If Statement Body",
                86,
                87
            ],
            [
                "Function Body",
                88,
                89
            ],
            [
                "Function Body",
                90,
                91
            ],
            [
                "Function Body",
                92,
                93
            ],
            [
                "List Comprehension",
                95,
                95
            ],
            [
                "While Loop Body",
                98,
                104
            ],
            [
                "If Statement Body",
                99,
                100
            ],
            [
                "If Statement Body",
                102,
                103
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef TuIMt():\n    \"\"\"12:17 (UTC): The sample input 1 and 2 were swapped. The error is now fixed. We are very sorry for your inconvenience.\nThere are N children in AtCoder Kindergarten, conveniently numbered 1 through N. Mr. Evi will distribute C indistinguishable candies to the children.\nIf child i is given a candies, the child's happiness will become x_i^a, where x_i is the child's excitement level. The activity level of the kindergarten is the product of the happiness of all the N children.\nFor each possible way to distribute C candies to the children by giving zero or more candies to each child, calculate the activity level of the kindergarten. Then, calculate the sum over all possible way to distribute C candies. This sum can be seen as a function of the children's excitement levels x_1,..,x_N, thus we call it f(x_1,..,x_N).\nYou are given integers A_i,B_i (1≦i≦N). Find  modulo 10^9+7.\n\n-----Constraints-----\n - 1≦N≦400\n - 1≦C≦400\n - 1≦A_i≦B_i≦400 (1≦i≦N)\n\n-----Partial Score-----\n - 400 points will be awarded for passing the test set satisfying A_i=B_i (1≦i≦N).\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN C\nA_1 A_2 ... A_N\nB_1 B_2 ... B_N\n\n-----Output-----\nPrint the value of  modulo 10^9+7.\n\n-----Sample Input-----\n2 3\n1 1\n1 1\n\n-----Sample Output-----\n4\n\nThis case is included in the test set for the partial score, since A_i=B_i.\nWe only have to consider the sum of the activity level of the kindergarten where the excitement level of both child 1 and child 2 are 1 (f(1,1)).\n - If child 1 is given 0 candy, and child 2 is given 3 candies, the activity level of the kindergarten is 1^0*1^3=1.\n - If child 1 is given 1 candy, and child 2 is given 2 candies, the activity level of the kindergarten is 1^1*1^2=1.\n - If child 1 is given 2 candies, and child 2 is given 1 candy, the activity level of the kindergarten is 1^2*1^1=1.\n - If child 1 is given 3 candies, and child 2 is given 0 candy, the activity level of the kindergarten is 1^3*1^0=1.\nThus, f(1,1)=1+1+1+1=4, and the sum over all f is also 4.\n    \"\"\"\n",
        "canonical_solution": "\ndef TuIMt():\n    MOD=10**9+7\n    N,C=map(int, input().split())\n    A=list(map(int, input().split()))\n    B=list(map(int, input().split()))\n    P=[[1] for _ in range(401)]\n    for _ in range(1,401):\n        for i in range(1,401):\n            P[i].append(P[i][-1]*i%MOD)\n    R=[[] for _ in range(N)]\n    for i,AB in enumerate(zip(A, B)):\n        AA,BB=AB\n        for a in range(401):\n            tmp=0\n            for x in range(AA,BB+1):\n                tmp+=P[x][a]\n                tmp%=MOD\n            R[i].append(tmp)\n    dp=[[0]*(C+1) for _ in range(N+1)]\n    dp[0][0]=1\n    for n in range(1,N+1):\n        for k in range(C+1):\n            for l in range(k+1):\n                dp[n][k]+=dp[n-1][k-l]*R[n-1][l]\n                dp[n][k]%=MOD\n    print(dp[N][C])",
        "inputs": [
            "2 3\n1 1\n1 1\n",
            "1 2\n1\n3\n",
            "2 3\n1 1\n2 2\n"
        ],
        "outputs": [
            "4\n",
            "14\n",
            "66\n"
        ],
        "starter_code": "\ndef TuIMt():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "For Loop Body",
                9,
                10
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "For Loop Body",
                12,
                19
            ],
            [
                "For Loop Body",
                14,
                19
            ],
            [
                "For Loop Body",
                16,
                18
            ],
            [
                "List Comprehension",
                20,
                20
            ],
            [
                "For Loop Body",
                22,
                26
            ],
            [
                "For Loop Body",
                23,
                26
            ],
            [
                "For Loop Body",
                24,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef RNnVS():\n    \"\"\"Sergey Semyonovich is a mayor of a county city N and he used to spend his days and nights in thoughts of further improvements of Nkers' lives. Unfortunately for him, anything and everything has been done already, and there are no more possible improvements he can think of during the day (he now prefers to sleep at night). However, his assistants have found a solution and they now draw an imaginary city on a paper sheet and suggest the mayor can propose its improvements.\n\nRight now he has a map of some imaginary city with $n$ subway stations. Some stations are directly connected with tunnels in such a way that the whole map is a tree (assistants were short on time and enthusiasm). It means that there exists exactly one simple path between each pair of station. We call a path simple if it uses each tunnel no more than once.\n\nOne of Sergey Semyonovich's favorite quality objectives is the sum of all pairwise distances between every pair of stations. The distance between two stations is the minimum possible number of tunnels on a path between them.\n\nSergey Semyonovich decided to add new tunnels to the subway map. In particular, he connected any two stations $u$ and $v$ that were not connected with a direct tunnel but share a common neighbor, i.e. there exists such a station $w$ that the original map has a tunnel between $u$ and $w$ and a tunnel between $w$ and $v$. You are given a task to compute the sum of pairwise distances between all pairs of stations in the new map.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer $n$ ($2 \\leq n \\leq 200\\,000$) — the number of subway stations in the imaginary city drawn by mayor's assistants. Each of the following $n - 1$ lines contains two integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq n$, $u_i \\ne v_i$), meaning the station with these indices are connected with a direct tunnel.\n\nIt is guaranteed that these $n$ stations and $n - 1$ tunnels form a tree.\n\n\n-----Output-----\n\nPrint one integer that is equal to the sum of distances between all pairs of stations after Sergey Semyonovich draws new tunnels between all pairs of stations that share a common neighbor in the original map.\n\n\n-----Examples-----\nInput\n4\n1 2\n1 3\n1 4\n\nOutput\n6\n\nInput\n4\n1 2\n2 3\n3 4\n\nOutput\n7\n\n\n\n-----Note-----\n\nIn the first sample, in the new map all pairs of stations share a direct connection, so the sum of distances is $6$.\n\nIn the second sample, the new map has a direct tunnel between all pairs of stations except for the pair $(1, 4)$. For these two stations the distance is $2$.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport threading\ndef RNnVS():\n    def main():\n        def countchildren(graph,vert,memo,pard=None):\n            dumi=0\n            for child in graph[vert]:\n                if child!=pard:\n                    if len(graph[child])==1:\n                        memo[child]=0\n                    else:\n                        memo[child]=countchildren(graph,child,memo,vert)[0]\n                    dumi+=memo[child]+1\n            return((dumi,memo))\n        n=int(input())\n        neigh=[]\n        for i in range(n):\n            neigh.append([])\n        for i in range(n-1):\n            a,b=map(int,input().split())\n            neigh[a-1].append(b-1)\n            neigh[b-1].append(a-1)\n        same=1\n        layer=[0]\n        pars=[None]\n        j=0\n        while layer!=[]:\n            j+=1\n            newlayer=[]\n            newpars=[]\n            for i in range(len(layer)):\n                for vert in neigh[layer[i]]:\n                    if vert!=pars[i]:\n                        newlayer.append(vert)\n                        newpars.append(layer[i])\n            layer=newlayer\n            pars=newpars\n            if j%2==0:\n                same+=len(layer)\n        bipartite=same*(n-same)\n        info=countchildren(neigh,0,[None]*n)[1]\n        dist=0\n        for guy in info:\n            if guy!=None:\n               dist+=(guy+1)*(n-guy-1)\n        print((dist+bipartite)//2)\n    sys.setrecursionlimit(2097152)\n    threading.stack_size(134217728)\n    main_thread=threading.Thread(target=main)\n    main_thread.start()\n    main_thread.join()",
        "inputs": [
            "4\n1 2\n1 3\n1 4\n",
            "4\n1 2\n2 3\n3 4\n",
            "2\n2 1\n"
        ],
        "outputs": [
            "6\n",
            "7\n",
            "1\n"
        ],
        "starter_code": "\ndef RNnVS():\n",
        "scope": [
            [
                "Function Body",
                3,
                51
            ],
            [
                "Function Body",
                4,
                46
            ],
            [
                "Function Body",
                5,
                14
            ],
            [
                "For Loop Body",
                7,
                13
            ],
            [
                "If Statement Body",
                8,
                13
            ],
            [
                "If Statement Body",
                9,
                12
            ],
            [
                "For Loop Body",
                17,
                18
            ],
            [
                "For Loop Body",
                19,
                22
            ],
            [
                "While Loop Body",
                27,
                39
            ],
            [
                "For Loop Body",
                31,
                35
            ],
            [
                "For Loop Body",
                32,
                35
            ],
            [
                "If Statement Body",
                33,
                35
            ],
            [
                "If Statement Body",
                38,
                39
            ],
            [
                "For Loop Body",
                43,
                45
            ],
            [
                "If Statement Body",
                44,
                45
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef eUGVk():\n    \"\"\"This morning Tolik has understood that while he was sleeping he had invented an incredible problem which will be a perfect fit for Codeforces! But, as a \"Discuss tasks\" project hasn't been born yet (in English, well), he decides to test a problem and asks his uncle.\n\nAfter a long time thinking, Tolik's uncle hasn't any ideas on how to solve it. But, he doesn't want to tell Tolik about his inability to solve it, so he hasn't found anything better than asking you how to solve this task.\n\nIn this task you are given a cell field $n \\cdot m$, consisting of $n$ rows and $m$ columns, where point's coordinates $(x, y)$ mean it is situated in the $x$-th row and $y$-th column, considering numeration from one ($1 \\leq x \\leq n, 1 \\leq y \\leq m$). Initially, you stand in the cell $(1, 1)$. Every move you can jump from cell $(x, y)$, which you stand in, by any non-zero vector $(dx, dy)$, thus you will stand in the $(x+dx, y+dy)$ cell. Obviously, you can't leave the field, but also there is one more important condition — you're not allowed to use one vector twice. Your task is to visit each cell of the field exactly once (the initial cell is considered as already visited).\n\nTolik's uncle is a very respectful person. Help him to solve this task!\n\n\n-----Input-----\n\nThe first and only line contains two positive integers $n, m$ ($1 \\leq n \\cdot m \\leq 10^{6}$) — the number of rows and columns of the field respectively.\n\n\n-----Output-----\n\nPrint \"-1\" (without quotes) if it is impossible to visit every cell exactly once.\n\nElse print $n \\cdot m$ pairs of integers, $i$-th from them should contain two integers $x_i, y_i$ ($1 \\leq x_i \\leq n, 1 \\leq y_i \\leq m$) — cells of the field in order of visiting, so that all of them are distinct and vectors of jumps between them are distinct too.\n\nNotice that the first cell should have $(1, 1)$ coordinates, according to the statement.\n\n\n-----Examples-----\nInput\n2 3\n\nOutput\n1 1\n1 3\n1 2\n2 2\n2 3\n2 1\nInput\n1 1\n\nOutput\n1 1\n\n\n\n-----Note-----\n\nThe vectors from the first example in the order of making jumps are $(0, 2), (0, -1), (1, 0), (0, 1), (0, -2)$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef eUGVk():\n    input = sys.stdin.readline\n    n,m=list(map(int,input().split()))\n    ANS=[]\n    for i in range(1,n//2+1):\n        for j in range(1,m+1):\n            sys.stdout.write(\"\".join((str(i),\" \",str(j),\"\\n\")))\n            sys.stdout.write(\"\".join((str(n-i+1),\" \",str(m-j+1),\"\\n\")))\n    if n%2==1:\n        for j in range(1,m//2+1):\n            sys.stdout.write(\"\".join((str(n//2+1),\" \",str(j),\"\\n\")))\n            sys.stdout.write(\"\".join((str(n//2+1),\" \",str(m-j+1),\"\\n\")))\n        if m%2==1:\n            sys.stdout.write(\"\".join((str(n//2+1),\" \",str(m//2+1),\"\\n\")))",
        "inputs": [
            "1 1\n",
            "8 8\n",
            "6 8\n"
        ],
        "outputs": [
            "1 1\n",
            "1 1\n8 8\n1 2\n8 7\n1 3\n8 6\n1 4\n8 5\n1 5\n8 4\n1 6\n8 3\n1 7\n8 2\n1 8\n8 1\n2 1\n7 8\n2 2\n7 7\n2 3\n7 6\n2 4\n7 5\n2 5\n7 4\n2 6\n7 3\n2 7\n7 2\n2 8\n7 1\n3 1\n6 8\n3 2\n6 7\n3 3\n6 6\n3 4\n6 5\n3 5\n6 4\n3 6\n6 3\n3 7\n6 2\n3 8\n6 1\n4 1\n5 8\n4 2\n5 7\n4 3\n5 6\n4 4\n5 5\n4 5\n5 4\n4 6\n5 3\n4 7\n5 2\n4 8\n5 1\n",
            "1 1\n6 8\n1 2\n6 7\n1 3\n6 6\n1 4\n6 5\n1 5\n6 4\n1 6\n6 3\n1 7\n6 2\n1 8\n6 1\n2 1\n5 8\n2 2\n5 7\n2 3\n5 6\n2 4\n5 5\n2 5\n5 4\n2 6\n5 3\n2 7\n5 2\n2 8\n5 1\n3 1\n4 8\n3 2\n4 7\n3 3\n4 6\n3 4\n4 5\n3 5\n4 4\n3 6\n4 3\n3 7\n4 2\n3 8\n4 1\n"
        ],
        "starter_code": "\ndef eUGVk():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "For Loop Body",
                7,
                9
            ],
            [
                "If Statement Body",
                10,
                15
            ],
            [
                "For Loop Body",
                11,
                13
            ],
            [
                "If Statement Body",
                14,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef SuxoX():\n    \"\"\"So the Beautiful Regional Contest (BeRC) has come to an end! $n$ students took part in the contest. The final standings are already known: the participant in the $i$-th place solved $p_i$ problems. Since the participants are primarily sorted by the number of solved problems, then $p_1 \\ge p_2 \\ge \\dots \\ge p_n$.\n\nHelp the jury distribute the gold, silver and bronze medals. Let their numbers be $g$, $s$ and $b$, respectively. Here is a list of requirements from the rules, which all must be satisfied:  for each of the three types of medals, at least one medal must be awarded (that is, $g>0$, $s>0$ and $b>0$);  the number of gold medals must be strictly less than the number of silver and the number of bronze (that is, $g<s$ and $g<b$, but there are no requirements between $s$ and $b$);  each gold medalist must solve strictly more problems than any awarded with a silver medal;  each silver medalist must solve strictly more problems than any awarded a bronze medal;  each bronze medalist must solve strictly more problems than any participant not awarded a medal;  the total number of medalists $g+s+b$ should not exceed half of all participants (for example, if $n=21$, then you can award a maximum of $10$ participants, and if $n=26$, then you can award a maximum of $13$ participants). \n\nThe jury wants to reward with medals the total maximal number participants (i.e. to maximize $g+s+b$) so that all of the items listed above are fulfilled. Help the jury find such a way to award medals.\n\n\n-----Input-----\n\nThe first line of the input contains an integer $t$ ($1 \\le t \\le 10000$) — the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains an integer $n$ ($1 \\le n \\le 4\\cdot10^5$) — the number of BeRC participants. The second line of a test case contains integers $p_1, p_2, \\dots, p_n$ ($0 \\le p_i \\le 10^6$), where $p_i$ is equal to the number of problems solved by the $i$-th participant from the final standings. The values $p_i$ are sorted in non-increasing order, i.e. $p_1 \\ge p_2 \\ge \\dots \\ge p_n$.\n\nThe sum of $n$ over all test cases in the input does not exceed $4\\cdot10^5$.\n\n\n-----Output-----\n\nPrint $t$ lines, the $j$-th line should contain the answer to the $j$-th test case.\n\nThe answer consists of three non-negative integers $g, s, b$.  Print $g=s=b=0$ if there is no way to reward participants with medals so that all requirements from the statement are satisfied at the same time.  Otherwise, print three positive numbers $g, s, b$ — the possible number of gold, silver and bronze medals, respectively. The sum of $g+s+b$ should be the maximum possible. If there are several answers, print any of them. \n\n\n-----Example-----\nInput\n5\n12\n5 4 4 3 2 2 1 1 1 1 1 1\n4\n4 3 2 1\n1\n1000000\n20\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n32\n64 64 63 58 58 58 58 58 37 37 37 37 34 34 28 28 28 28 28 28 24 24 19 17 17 17 17 16 16 16 16 11\n\nOutput\n1 2 3\n0 0 0\n0 0 0\n2 5 3\n2 6 6\n\n\n\n-----Note-----\n\nIn the first test case, it is possible to reward $1$ gold, $2$ silver and $3$ bronze medals. In this case, the participant solved $5$ tasks will be rewarded with the gold medal, participants solved $4$ tasks will be rewarded with silver medals, participants solved $2$ or $3$ tasks will be rewarded with bronze medals. Participants solved exactly $1$ task won't be rewarded. It's easy to see, that in this case, all conditions are satisfied and it is possible to reward participants in this way. It is impossible to give more than $6$ medals because the number of medals should not exceed half of the number of participants. The answer $1$, $3$, $2$ is also correct in this test case.\n\nIn the second and third test cases, it is impossible to reward medals, because at least one medal of each type should be given, but the number of medals should not exceed half of the number of participants.\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom collections import Counter\ndef SuxoX():\n    input = sys.stdin.readline\n    t=int(input())\n    for testcases in range(t):\n        n=int(input())\n        P=list(map(int,input().split()))\n        C=Counter(P)\n        PLIST=sorted(set(P),reverse=True)\n        g=C[PLIST[0]]\n        s=0\n        b=0\n        sflag=1\n        for i in PLIST[1:]:\n            if sflag:\n                if s<=g:\n                    s+=C[i]\n                else:\n                    sflag=0\n                    bflag=1\n                    b+=C[i]\n            elif bflag:\n                if b<=g:\n                    b+=C[i]\n                elif g+s+b+C[i]<=n//2:\n                    b+=C[i]\n                else:\n                    break\n            #print(i,g,s,b)\n        if g+s+b<=n//2:\n            print(g,s,b)\n        else:\n            print(0,0,0)\n                \n                \n                ",
        "inputs": [
            "5\n12\n5 4 4 3 2 2 1 1 1 1 1 1\n4\n4 3 2 1\n1\n1000000\n20\n20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n32\n64 64 63 58 58 58 58 58 37 37 37 37 34 34 28 28 28 28 28 28 24 24 19 17 17 17 17 16 16 16 16 11\n"
        ],
        "outputs": [
            "1 2 3\n0 0 0\n0 0 0\n1 2 7\n2 6 6\n"
        ],
        "starter_code": "\ndef SuxoX():\n",
        "scope": [
            [
                "Function Body",
                3,
                34
            ],
            [
                "For Loop Body",
                6,
                34
            ],
            [
                "For Loop Body",
                15,
                29
            ],
            [
                "If Statement Body",
                16,
                29
            ],
            [
                "If Statement Body",
                17,
                22
            ],
            [
                "If Statement Body",
                23,
                29
            ],
            [
                "If Statement Body",
                24,
                29
            ],
            [
                "If Statement Body",
                26,
                29
            ],
            [
                "If Statement Body",
                31,
                34
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef CckOU():\n    \"\"\"Jeff got 2n real numbers a_1, a_2, ..., a_2n as a birthday present. The boy hates non-integer numbers, so he decided to slightly \"adjust\" the numbers he's got. Namely, Jeff consecutively executes n operations, each of them goes as follows:  choose indexes i and j (i ≠ j) that haven't been chosen yet;  round element a_{i} to the nearest integer that isn't more than a_{i} (assign to a_{i}: ⌊ a_{i} ⌋);  round element a_{j} to the nearest integer that isn't less than a_{j} (assign to a_{j}: ⌈ a_{j} ⌉). \n\nNevertheless, Jeff doesn't want to hurt the feelings of the person who gave him the sequence. That's why the boy wants to perform the operations so as to make the absolute value of the difference between the sum of elements before performing the operations and the sum of elements after performing the operations as small as possible. Help Jeff find the minimum absolute value of the difference.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 2000). The next line contains 2n real numbers a_1, a_2, ..., a_2n (0 ≤ a_{i} ≤ 10000), given with exactly three digits after the decimal point. The numbers are separated by spaces.\n\n\n-----Output-----\n\nIn a single line print a single real number — the required difference with exactly three digits after the decimal point.\n\n\n-----Examples-----\nInput\n3\n0.000 0.500 0.750 1.000 2.000 3.000\n\nOutput\n0.250\n\nInput\n3\n4469.000 6526.000 4864.000 9356.383 7490.000 995.896\n\nOutput\n0.279\n\n\n\n-----Note-----\n\nIn the first test case you need to perform the operations as follows: (i = 1, j = 4), (i = 2, j = 3), (i = 5, j = 6). In this case, the difference will equal |(0 + 0.5 + 0.75 + 1 + 2 + 3) - (0 + 0 + 1 + 1 + 2 + 3)| = 0.25.\n    \"\"\"\n",
        "canonical_solution": "\ndef CckOU():\n    k = 0\n    ans = 0\n    n = int(input())\n    a = input().split()\n    for i in range(2 * n):\n        s = float(a[i])\n        if s != int(s):\n            k+=1\n            ans += (int(s) + 1 - s)\n    \n    if ans - int(ans) > 0.5:\n        p = int(ans) + 1\n    else:\n        p = int(ans)\n    if p > n:\n        p = n\n    if (p + n >= k):\n        print('%.3f'% abs(ans - p))\n    else:\n        print('%.3f'% abs(ans - k + n))\n    ",
        "inputs": [
            "3\n0.000 0.500 0.750 1.000 2.000 3.000\n",
            "3\n4469.000 6526.000 4864.000 9356.383 7490.000 995.896\n",
            "3\n673.674 9263.142 6780.000 9801.000 4640.000 8244.000\n"
        ],
        "outputs": [
            "0.250\n",
            "0.279\n",
            "0.184\n"
        ],
        "starter_code": "\ndef CckOU():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                9,
                11
            ],
            [
                "If Statement Body",
                13,
                16
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                19,
                22
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef vCPVc():\n    \"\"\"You are given a sequence of n integers a_1, a_2, ..., a_{n}. \n\nDetermine a real number x such that the weakness of the sequence a_1 - x, a_2 - x, ..., a_{n} - x is as small as possible.\n\nThe weakness of a sequence is defined as the maximum value of the poorness over all segments (contiguous subsequences) of a sequence.\n\nThe poorness of a segment is defined as the absolute value of sum of the elements of segment.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 ≤ n ≤ 200 000), the length of a sequence.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (|a_{i}| ≤ 10 000).\n\n\n-----Output-----\n\nOutput a real number denoting the minimum possible weakness of a_1 - x, a_2 - x, ..., a_{n} - x. Your answer will be considered correct if its relative or absolute error doesn't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n1.000000000000000\n\nInput\n4\n1 2 3 4\n\nOutput\n2.000000000000000\n\nInput\n10\n1 10 2 9 3 8 4 7 5 6\n\nOutput\n4.500000000000000\n\n\n\n-----Note-----\n\nFor the first case, the optimal value of x is 2 so the sequence becomes  - 1, 0, 1 and the max poorness occurs at the segment \"-1\" or segment \"1\". The poorness value (answer) equals to 1 in this case. \n\nFor the second sample the optimal value of x is 2.5 so the sequence becomes  - 1.5,  - 0.5, 0.5, 1.5 and the max poorness occurs on segment \"-1.5 -0.5\" or \"0.5 1.5\". The poorness value (answer) equals to 2 in this case.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef vCPVc():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    eps = 1e-12\n    def f(x):\n        mx = a[0] - x\n        tsmx = 0.0\n        mn = a[0] - x\n        tsmn = 0.0\n        for ai in a:\n            tsmx = max(tsmx + ai - x, ai - x)\n            mx = max(tsmx, mx)\n            tsmn = min(tsmn + ai - x, ai - x)\n            mn = min(tsmn, mn)\n        return abs(mx), abs(mn)\n    l = min(a)\n    r = max(a)\n    f1, f2 = f(l)\n    for i in range(0, 90):\n        m = (l + r) / 2\n        f1, f2 = f(m)\n        if f1 > f2:\n            l = m\n        else:\n            r = m\n    A, B = f(l)\n    print(min(A,B))",
        "inputs": [
            "3\n1 2 3\n",
            "4\n1 2 3 4\n",
            "10\n1 10 2 9 3 8 4 7 5 6\n"
        ],
        "outputs": [
            "0.9999999999999998\n",
            "1.9999999999999991\n",
            "4.499999999999999\n"
        ],
        "starter_code": "\ndef vCPVc():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "Function Body",
                6,
                16
            ],
            [
                "For Loop Body",
                11,
                15
            ],
            [
                "For Loop Body",
                20,
                26
            ],
            [
                "If Statement Body",
                23,
                26
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef yPYuV():\n    \"\"\"In Morse code, an letter of English alphabet is represented as a string of some length from $1$ to $4$. Moreover, each Morse code representation of an English letter contains only dots and dashes. In this task, we will represent a dot with a \"0\" and a dash with a \"1\".\n\nBecause there are $2^1+2^2+2^3+2^4 = 30$ strings with length $1$ to $4$ containing only \"0\" and/or \"1\", not all of them correspond to one of the $26$ English letters. In particular, each string of \"0\" and/or \"1\" of length at most $4$ translates into a distinct English letter, except the following four strings that do not correspond to any English alphabet: \"0011\", \"0101\", \"1110\", and \"1111\".\n\nYou will work with a string $S$, which is initially empty. For $m$ times, either a dot or a dash will be appended to $S$, one at a time. Your task is to find and report, after each of these modifications to string $S$, the number of non-empty sequences of English letters that are represented with some substring of $S$ in Morse code.\n\nSince the answers can be incredibly tremendous, print them modulo $10^9 + 7$.\n\n\n-----Input-----\n\nThe first line contains an integer $m$ ($1 \\leq m \\leq 3\\,000$) — the number of modifications to $S$. \n\nEach of the next $m$ lines contains either a \"0\" (representing a dot) or a \"1\" (representing a dash), specifying which character should be appended to $S$.\n\n\n-----Output-----\n\nPrint $m$ lines, the $i$-th of which being the answer after the $i$-th modification to $S$.\n\n\n-----Examples-----\nInput\n3\n1\n1\n1\n\nOutput\n1\n3\n7\n\nInput\n5\n1\n0\n1\n0\n1\n\nOutput\n1\n4\n10\n22\n43\n\nInput\n9\n1\n1\n0\n0\n0\n1\n1\n0\n1\n\nOutput\n1\n3\n10\n24\n51\n109\n213\n421\n833\n\n\n\n-----Note-----\n\nLet us consider the first sample after all characters have been appended to $S$, so S is \"111\".\n\nAs you can see, \"1\", \"11\", and \"111\" all correspond to some distinct English letter. In fact, they are translated into a 'T', an 'M', and an 'O', respectively. All non-empty sequences of English letters that are represented with some substring of $S$ in Morse code, therefore, are as follows.  \"T\" (translates into \"1\")  \"M\" (translates into \"11\")  \"O\" (translates into \"111\")  \"TT\" (translates into \"11\")  \"TM\" (translates into \"111\")  \"MT\" (translates into \"111\")  \"TTT\" (translates into \"111\") \n\nAlthough unnecessary for this task, a conversion table from English alphabets into Morse code can be found here.\n    \"\"\"\n",
        "canonical_solution": "\ndef yPYuV():\n    MOD = 10 ** 9 + 7\n    BAD = ([0, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1])\n    \n    def zfunc(s):\n        z = [0] * len(s)\n        l = r = 0\n        for i in range(1, len(s)):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < len(s) and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n    \n    n = int(input())\n    s = []\n    sm = 0\n    for i in range(1, n + 1):\n        s.append(int(input()))\n        cur = 0\n        f = [0] * (i + 1)\n        sum4 = f[i] = 1\n        for j in range(i - 1, -1, -1):\n            if j + 4 < i:\n                sum4 -= f[j + 5]\n            if j + 4 <= i and s[j : j + 4] in BAD:\n                f[j] -= f[j + 4]\n            f[j] = (f[j] + sum4) % MOD\n            sum4 += f[j]\n        z = zfunc(s[::-1])\n        new = i - max(z)\n        sm = (sm + sum(f[:new])) % MOD\n        print(sm)\n    ",
        "inputs": [
            "3\n1\n1\n1\n",
            "5\n1\n0\n1\n0\n1\n",
            "9\n1\n1\n0\n0\n0\n1\n1\n0\n1\n"
        ],
        "outputs": [
            "1\n3\n7\n",
            "1\n4\n10\n22\n43\n",
            "1\n3\n10\n24\n51\n109\n213\n421\n833\n"
        ],
        "starter_code": "\ndef yPYuV():\n",
        "scope": [
            [
                "Function Body",
                2,
                36
            ],
            [
                "Function Body",
                6,
                16
            ],
            [
                "For Loop Body",
                9,
                15
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "While Loop Body",
                12,
                13
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "For Loop Body",
                21,
                36
            ],
            [
                "For Loop Body",
                26,
                32
            ],
            [
                "If Statement Body",
                27,
                28
            ],
            [
                "If Statement Body",
                29,
                30
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef Uevdt():\n    \"\"\"After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x? \n\nIf the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.\n\nInitially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.\n\nMisha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.\n\n\n-----Input-----\n\nThe first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered around the room.\n\nThe next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10^600 that doesn't contain leading zeroes. \n\n\n-----Output-----\n\nFor each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.\n\n\n-----Examples-----\nInput\n7\n7\n6\n5\n4\n3\n2\n1\n\nOutput\n0\n0\n0\n3 0 1 2\n2 1 2\n2 0 2\n2 0 1\n\nInput\n2\n5\n5\n\nOutput\n0\n1 0\n\n\n\n-----Note-----\n\nThe XOR sum of numbers is the result of bitwise sum of numbers modulo 2.\n    \"\"\"\n",
        "canonical_solution": "\ndef Uevdt():\n    buck = [[0, 0] for i in range(2201)]\n    m = int(input())\n    for i in range(m):\n        a = int(input())\n        ok = True\n        br = 0\n        for j in range(2200, -1, -1):\n            if a & (1 << j):\n                if(buck[j][0]):\n                    a  ^= buck[j][0]\n                    br ^= buck[j][1]\n                else:\n                    ok = False\n                    buck[j][0] = a\n                    buck[j][1] = br | (1 << i)\n                    break\n        if not ok:\n            print(\"0\")\n        else:\n            lst = []\n            for j in range(2201):\n                if br & (1 << j):\n                    lst.append(j)\n            print(len(lst), end = ' ')\n            for j in lst:\n                print(j, end = ' ')\n            print('\\n', end='')\n    ",
        "inputs": [
            "7\n7\n6\n5\n4\n3\n2\n1\n",
            "2\n5\n5\n",
            "10\n81\n97\n12\n2\n16\n96\n80\n99\n6\n83\n"
        ],
        "outputs": [
            "0\n0\n0\n3 0 1 2\n2 1 2\n2 0 2\n2 0 1\n",
            "0\n1 0\n",
            "0\n0\n0\n0\n0\n0\n3 0 1 5\n2 1 3\n0\n2 0 3\n"
        ],
        "starter_code": "\ndef Uevdt():\n",
        "scope": [
            [
                "Function Body",
                2,
                29
            ],
            [
                "List Comprehension",
                3,
                3
            ],
            [
                "For Loop Body",
                5,
                29
            ],
            [
                "For Loop Body",
                9,
                18
            ],
            [
                "If Statement Body",
                10,
                18
            ],
            [
                "If Statement Body",
                11,
                18
            ],
            [
                "If Statement Body",
                19,
                29
            ],
            [
                "For Loop Body",
                23,
                25
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "For Loop Body",
                27,
                28
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef tBlgL():\n    \"\"\"John Smith knows that his son, Thomas Smith, is among the best students in his class and even in his school. After the students of the school took the exams in English, German, Math, and History, a table of results was formed.\n\nThere are $n$ students, each of them has a unique id (from $1$ to $n$). Thomas's id is $1$. Every student has four scores correspond to his or her English, German, Math, and History scores. The students are given in order of increasing of their ids.\n\nIn the table, the students will be sorted by decreasing the sum of their scores. So, a student with the largest sum will get the first place. If two or more students have the same sum, these students will be sorted by increasing their ids. \n\nPlease help John find out the rank of his son. \n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 1000$) — the number of students.\n\nEach of the next $n$ lines contains four integers $a_i$, $b_i$, $c_i$, and $d_i$ ($0\\leq a_i, b_i, c_i, d_i\\leq 100$) — the grades of the $i$-th student on English, German, Math, and History. The id of the $i$-th student is equal to $i$.\n\n\n-----Output-----\n\nPrint the rank of Thomas Smith. Thomas's id is $1$.\n\n\n-----Examples-----\nInput\n5\n100 98 100 100\n100 100 100 100\n100 100 99 99\n90 99 90 100\n100 98 60 99\n\nOutput\n2\n\nInput\n6\n100 80 90 99\n60 60 60 60\n90 60 100 60\n60 100 60 80\n100 100 0 100\n0 0 0 0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample, the students got total scores: $398$, $400$, $398$, $379$, and $357$. Among the $5$ students, Thomas and the third student have the second highest score, but Thomas has a smaller id, so his rank is $2$.\n\nIn the second sample, the students got total scores: $369$, $240$, $310$, $300$, $300$, and $0$. Among the $6$ students, Thomas got the highest score, so his rank is $1$.\n    \"\"\"\n",
        "canonical_solution": "\ndef tBlgL():\n    def main():\n        n = int(input())\n        scores = []\n        for i in range(n):\n            a = list(map(int, input().split()))\n            tot = sum(a)\n            scores.append((-tot, i))\n    \n        scores.sort()\n        for i in range(n):\n            if scores[i][1] == 0:\n                print(i + 1)\n    \n    main()\n    ",
        "inputs": [
            "5\n100 98 100 100\n100 100 100 100\n100 100 99 99\n90 99 90 100\n100 98 60 99\n",
            "6\n100 80 90 99\n60 60 60 60\n90 60 100 60\n60 100 60 80\n100 100 0 100\n0 0 0 0\n",
            "1\n0 0 0 0\n"
        ],
        "outputs": [
            "2\n",
            "1\n",
            "1\n"
        ],
        "starter_code": "\ndef tBlgL():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "Function Body",
                3,
                14
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                14
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef TYqGr():\n    \"\"\"Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.\n\nSince the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 10^9).\n\n\n-----Output-----\n\nIn the first line print one integer k — number of different values of x satisfying the condition. \n\nIn next k lines print these values in ascending order.\n\n\n-----Examples-----\nInput\n21\n\nOutput\n1\n15\n\nInput\n20\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first test case x = 15 there is only one variant: 15 + 1 + 5 = 21.\n\nIn the second test case there are no such x.\n    \"\"\"\n",
        "canonical_solution": "\ndef TYqGr():\n    n=int(input())\n    q=[]\n    for i in range(max(0,n-100),n+1):\n    \tj=i\n    \tres=i\n    \twhile j:\n    \t\tres+=j%10\n    \t\tj//=10\n    \tif res==n:\n    \t\tq.append(i)\n    print(len(q))\n    for i in q:\n    \tprint(i)",
        "inputs": [
            "21\n",
            "20\n",
            "1\n"
        ],
        "outputs": [
            "1\n15\n",
            "0\n",
            "0\n"
        ],
        "starter_code": "\ndef TYqGr():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                5,
                12
            ],
            [
                "While Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "For Loop Body",
                14,
                15
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef yJdju():\n    \"\"\"Polycarpus has a sequence, consisting of n non-negative integers: a_1, a_2, ..., a_{n}.\n\nLet's define function f(l, r) (l, r are integer, 1 ≤ l ≤ r ≤ n) for sequence a as an operation of bitwise OR of all the sequence elements with indexes from l to r. Formally: f(l, r) = a_{l} | a_{l} + 1 | ...  | a_{r}. \n\nPolycarpus took a piece of paper and wrote out the values of function f(l, r) for all l, r (l, r are integer, 1 ≤ l ≤ r ≤ n). Now he wants to know, how many distinct values he's got in the end. \n\nHelp Polycarpus, count the number of distinct values of function f(l, r) for the given sequence a.\n\nExpression x | y means applying the operation of bitwise OR to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is marked as \"|\", in Pascal — as \"or\".\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 10^5) — the number of elements of sequence a. The second line contains n space-separated integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 10^6) — the elements of sequence a.\n\n\n-----Output-----\n\nPrint a single integer — the number of distinct values of function f(l, r) for the given sequence a.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n1 2 0\n\nOutput\n4\nInput\n10\n1 2 3 4 5 6 1 2 9 10\n\nOutput\n11\n\n\n-----Note-----\n\nIn the first test case Polycarpus will have 6 numbers written on the paper: f(1, 1) = 1, f(1, 2) = 3, f(1, 3) = 3, f(2, 2) = 2, f(2, 3) = 2, f(3, 3) = 0. There are exactly 4 distinct numbers among them: 0, 1, 2, 3.\n    \"\"\"\n",
        "canonical_solution": "\ndef yJdju():\n    n, p, q = input(), set(), set()\n    for i in map(int, input().split()):\n        q = set(i | j for j in q)\n        q.add(i)\n        p.update(q)\n    print(len(p))",
        "inputs": [
            "3\n1 2 0\n",
            "10\n1 2 3 4 5 6 1 2 9 10\n",
            "1\n123\n"
        ],
        "outputs": [
            "4",
            "11",
            "1"
        ],
        "starter_code": "\ndef yJdju():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "For Loop Body",
                4,
                7
            ],
            [
                "Generator Expression",
                5,
                5
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef vtTyl():\n    \"\"\"After learning a lot about space exploration, a little girl named Ana wants to change the subject.\n\nAna is a girl who loves palindromes (string that can be read the same backwards as forward). She has learned how to check for a given string whether it's a palindrome or not, but soon she grew tired of this problem, so she came up with a more interesting one and she needs your help to solve it:\n\nYou are given an array of strings which consist of only small letters of the alphabet. Your task is to find how many palindrome pairs are there in the array. A palindrome pair is a pair of strings such that the following condition holds: at least one permutation of the concatenation of the two strings is a palindrome. In other words, if you have two strings, let's say \"aab\" and \"abcac\", and you concatenate them into \"aababcac\", we have to check if there exists a permutation of this new string such that it is a palindrome (in this case there exists the permutation \"aabccbaa\"). \n\nTwo pairs are considered different if the strings are located on different indices. The pair of strings with indices $(i,j)$ is considered the same as the pair $(j,i)$.\n\n\n-----Input-----\n\nThe first line contains a positive integer $N$ ($1 \\le N \\le 100\\,000$), representing the length of the input array.\n\nEacg of the next $N$ lines contains a string (consisting of lowercase English letters from 'a' to 'z') — an element of the input array. \n\nThe total number of characters in the input array will be less than $1\\,000\\,000$.\n\n\n-----Output-----\n\nOutput one number, representing how many palindrome pairs there are in the array.\n\n\n-----Examples-----\nInput\n3\naa\nbb\ncd\n\nOutput\n1\n\nInput\n6\naab\nabcac\ndffe\ned\naa\naade\n\nOutput\n6\n\n\n\n-----Note-----\n\nThe first example:  aa $+$ bb $\\to$ abba. \n\nThe second example:  aab $+$ abcac $=$ aababcac $\\to$ aabccbaa aab $+$ aa $=$ aabaa abcac $+$ aa $=$ abcacaa $\\to$ aacbcaa dffe $+$ ed $=$ dffeed $\\to$ fdeedf dffe $+$ aade $=$ dffeaade $\\to$ adfaafde ed $+$ aade $=$ edaade $\\to$ aeddea\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef vtTyl():\n    #!/usr/bin/env python3\n    \"\"\"\n    Created on Wed Feb 28 11:47:12 2018\n    @author: mikolajbinkowski\n    \"\"\"\n    N = int(input())\n    string_count = {}\n    for _ in range(N):\n        s = str(input())\n        char_count = {}\n        for c in s:\n            char_count[c] = char_count.get(c, 0) + 1\n        s0 = []\n        for a in 'abcdefghijklmnopqrstuvwxyz':\n            if char_count.get(a, 0) % 2 == 1:\n                s0.append(a)\n        s1 = ''.join(s0)\n        string_count[s1] = string_count.get(s1, 0) + 1\n    pairs = 0\n    for s, v in list(string_count.items()):\n        pairs += v * (v-1) // 2\n        for i in range(len(s)):\n            pairs += v * string_count.get(s[:i] + s[i+1:], 0)\n    print(pairs)\n            \n        ",
        "inputs": [
            "3\naa\nbb\ncd\n",
            "6\naab\nabcac\ndffe\ned\naa\naade\n",
            "20\niw\nix\nudb\nbg\noi\nuo\njsm\num\ns\nquy\nqo\nbxct\nng\nrmr\nnu\nps\nio\nkh\nw\nk\n"
        ],
        "outputs": [
            "1\n",
            "6\n",
            "5\n"
        ],
        "starter_code": "\ndef vtTyl():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "For Loop Body",
                10,
                20
            ],
            [
                "For Loop Body",
                13,
                14
            ],
            [
                "For Loop Body",
                16,
                18
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "For Loop Body",
                22,
                25
            ],
            [
                "For Loop Body",
                24,
                25
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef cjhXZ():\n    \"\"\"We have three stones at points (0, 0), (1,0), and (0,1) on a two-dimensional plane.\nThese three stones are said to form an L when they satisfy the following conditions:\n - Each of the stones is at integer coordinates.\n - Each of the stones is adjacent to another stone. (That is, for each stone, there is another stone whose distance from that stone is 1.)\n - The three stones do not lie on the same line.\nParticularly, the initial arrangement of the stone - (0, 0), (1,0), and (0,1) - forms an L.\nYou can do the following operation any number of times: choose one of the stones and move it to any position. However, after each operation, the stones must form an L.\nYou want to do as few operations as possible to put stones at points (ax, ay), (bx, by), and (cx, cy). How many operations do you need to do this?\nIt is guaranteed that the desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L. Under this condition, it is always possible to achieve the objective with a finite number of operations.\nYou will be given T cases of this problem. Solve each of them.\n\n-----Notes-----\nWe assume that the three stones are indistinguishable. For example, the stone that is initially at point (0,0) may be at any of the points (ax, ay), (bx, by), and (cx, cy) in the end.\n\n-----Constraints-----\n - 1 \\leq T \\leq 10^3\n - |ax|,|ay|,|bx|,|by|,|cx|,|cy| \\leq 10^9\n - The desired arrangement of stones - (ax, ay), (bx, by), and (cx, cy) - forms an L.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nT\n\\text{case}_1\n\\vdots\n\\text{case}_T\n\nEach case is in the following format:\nax ay bx by cx cy\n\n-----Output-----\nPrint T values. The i-th value should be the minimum number of operations for \\text{case}_i.\n\n-----Sample Input-----\n1\n3 2 2 2 2 1\n\n-----Sample Output-----\n4\n\nLet us use # to represent a stone.\nYou can move the stones to the specified positions with four operations, as follows:\n....    ....    ....    ..#.    ..##\n#... -> ##.. -> .##. -> .##. -> ..#.\n##..    .#..    .#..    ....    ....\n\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef cjhXZ():\n    input = sys.stdin.readline\n    def solve(ax,ay,bx,by,cx,cy):\n        x = ax+bx+cx\n        y = ay+by+cy\n        x -= x//3+1\n        y -= y//3+1\n        if x==y:\n            return x if 0 <= x <= 1 else abs(x)+1\n        else:\n            return max(abs(x), abs(y))\n    T = int(input())\n    for _ in range(T):\n        ax,ay,bx,by,cx,cy = map(int,input().split())\n        print(solve(ax,ay,bx,by,cx,cy))",
        "inputs": [
            "1\n3 2 2 2 2 1\n",
            "10\n0 0 1 0 0 1\n1 0 0 1 1 1\n2 -1 1 -1 1 0\n1 -2 2 -1 1 -1\n-1 2 0 2 -1 3\n-1 -2 -2 -2 -2 -3\n-2 4 -3 3 -2 3\n3 1 4 2 4 1\n-4 2 -4 3 -3 3\n5 4 5 3 4 4\n"
        ],
        "outputs": [
            "4\n",
            "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n"
        ],
        "starter_code": "\ndef cjhXZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "Function Body",
                4,
                12
            ],
            [
                "If Statement Body",
                9,
                12
            ],
            [
                "For Loop Body",
                14,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef dPaVZ():\n    \"\"\"Fennec and Snuke are playing a board game.\nOn the board, there are N cells numbered 1 through N, and N-1 roads, each connecting two cells. Cell a_i is adjacent to Cell b_i through the i-th road. Every cell can be reached from every other cell by repeatedly traveling to an adjacent cell. In terms of graph theory, the graph formed by the cells and the roads is a tree.\nInitially, Cell 1 is painted black, and Cell N is painted white. The other cells are not yet colored.\nFennec (who goes first) and Snuke (who goes second) alternately paint an uncolored cell.\nMore specifically, each player performs the following action in her/his turn:\n - Fennec: selects an uncolored cell that is adjacent to a black cell, and paints it black.\n - Snuke: selects an uncolored cell that is adjacent to a white cell, and paints it white.\nA player loses when she/he cannot paint a cell. Determine the winner of the game when Fennec and Snuke play optimally.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq a_i, b_i \\leq N\n - The given graph is a tree.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 b_1\n:\na_{N-1} b_{N-1}\n\n-----Output-----\nIf Fennec wins, print Fennec; if Snuke wins, print Snuke.\n\n-----Sample Input-----\n7\n3 6\n1 2\n3 1\n7 4\n5 7\n1 4\n\n-----Sample Output-----\nFennec\n\nFor example, if Fennec first paints Cell 2 black, she will win regardless of Snuke's moves.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef dPaVZ():\n    #!/usr/bin/env python3\n    sys.setrecursionlimit(10 ** 6)\n    def main():\n        n = int(input())\n        adj_list = [[] for i in range(n)]\n        for i in range(n - 1):\n            a1, b1 = list(map(int, sys.stdin.readline().split()))\n            adj_list[a1 - 1].append(b1 - 1)\n            adj_list[b1 - 1].append(a1 - 1)\n        path = list(reversed(dfs(0, -1, adj_list, n)))\n        assert len(path) >= 2\n        fpath = len(path) - len(path) // 2\n        cut = set(path[fpath - 1:fpath + 1])\n        f = dfs2(0, -1, adj_list, n, cut)\n        s = dfs2(n - 1, -1, adj_list, n, cut)\n        assert f + s == n\n        print((\"Fennec\" if f > s else \"Snuke\"))\n    def dfs(now, prev, adj_list, n):\n        if now == n - 1:\n            return [now]\n        for next in adj_list[now]:\n            if next == prev:\n                continue\n            p = dfs(next, now, adj_list, n)\n            if p is not None:\n                p.append(now)\n                return p\n    def dfs2(now, prev, adj_list, n, cut):\n        size = 1\n        for next in adj_list[now]:\n            if next == prev:\n                continue\n            if {now, next} == cut:\n                continue\n            s = dfs2(next, now, adj_list, n, cut)\n            size += s\n        return size\n    def __starting_point():\n        main()\n    __starting_point()",
        "inputs": [
            "7\n3 6\n1 2\n3 1\n7 4\n5 7\n1 4\n",
            "4\n1 4\n4 2\n2 3\n"
        ],
        "outputs": [
            "Fennec\n",
            "Snuke\n"
        ],
        "starter_code": "\ndef dPaVZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                42
            ],
            [
                "Function Body",
                5,
                19
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                11
            ],
            [
                "Function Body",
                20,
                29
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "For Loop Body",
                23,
                29
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "If Statement Body",
                27,
                29
            ],
            [
                "Function Body",
                30,
                39
            ],
            [
                "For Loop Body",
                32,
                38
            ],
            [
                "If Statement Body",
                33,
                34
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "Function Body",
                40,
                41
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef tQnhN():\n    \"\"\"There are some rabbits in Singapore Zoo. To feed them, Zookeeper bought $n$ carrots with lengths $a_1, a_2, a_3, \\ldots, a_n$. However, rabbits are very fertile and multiply very quickly. Zookeeper now has $k$ rabbits and does not have enough carrots to feed all of them. To solve this problem, Zookeeper decided to cut the carrots into $k$ pieces. For some reason, all resulting carrot lengths must be positive integers.\n\nBig carrots are very difficult for rabbits to handle and eat, so the time needed to eat a carrot of size $x$ is $x^2$.\n\nHelp Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ $(1 \\leq n \\leq k \\leq 10^5)$: the initial number of carrots and the number of rabbits.\n\nThe next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ $(1 \\leq a_i \\leq 10^6)$: lengths of carrots.\n\nIt is guaranteed that the sum of $a_i$ is at least $k$.\n\n\n-----Output-----\n\nOutput one integer: the minimum sum of time taken for rabbits to eat carrots.\n\n\n-----Examples-----\nInput\n3 6\n5 3 1\n\nOutput\n15\n\nInput\n1 4\n19\n\nOutput\n91\n\n\n\n-----Note-----\n\nFor the first test, the optimal sizes of carrots are $\\{1,1,1,2,2,2\\}$. The time taken is $1^2+1^2+1^2+2^2+2^2+2^2=15$\n\nFor the second test, the optimal sizes of carrots are $\\{4,5,5,5\\}$. The time taken is $4^2+5^2+5^2+5^2=91$.\n    \"\"\"\n",
        "canonical_solution": "import heapq\ndef tQnhN():\n    def sum_sqaure(a, k):\n        q, r = divmod(a, k)\n        return q**2 * (k-r) + (q+1)**2 * r\n    def diff(a, k):\n        return sum_sqaure(a, k+1) - sum_sqaure(a, k)\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    curr = sum(sum_sqaure(a, 1) for a in nums)\n    Q = [(diff(a, 1), a, 1) for a in nums]\n    heapq.heapify(Q)\n    for __ in range(k - n):\n        d, a, i = heapq.heappop(Q)\n        curr += d\n        heapq.heappush(Q, (diff(a, i+1), a, i+1))\n    print(curr)",
        "inputs": [
            "3 6\n5 3 1\n",
            "1 4\n19\n",
            "1 3\n1000000\n"
        ],
        "outputs": [
            "15\n",
            "91\n",
            "333333333334\n"
        ],
        "starter_code": "\ndef tQnhN():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "Function Body",
                3,
                5
            ],
            [
                "Function Body",
                6,
                7
            ],
            [
                "Generator Expression",
                10,
                10
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "For Loop Body",
                13,
                16
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef CSjXz():\n    \"\"\"Someone give a strange birthday present to Ivan. It is hedgehog — connected undirected graph in which one vertex has degree at least $3$ (we will call it center) and all other vertices has degree 1. Ivan thought that hedgehog is too boring and decided to make himself $k$-multihedgehog.\n\nLet us define $k$-multihedgehog as follows: $1$-multihedgehog is hedgehog: it has one vertex of degree at least $3$ and some vertices of degree 1. For all $k \\ge 2$, $k$-multihedgehog is $(k-1)$-multihedgehog in which the following changes has been made for each vertex $v$ with degree 1: let $u$ be its only neighbor; remove vertex $v$, create a new hedgehog with center at vertex $w$ and connect vertices $u$ and $w$ with an edge. New hedgehogs can differ from each other and the initial gift. \n\nThereby $k$-multihedgehog is a tree. Ivan made $k$-multihedgehog but he is not sure that he did not make any mistakes. That is why he asked you to check if his tree is indeed $k$-multihedgehog.\n\n\n-----Input-----\n\nFirst line of input contains $2$ integers $n$, $k$ ($1 \\le n \\le 10^{5}$, $1 \\le k \\le 10^{9}$) — number of vertices and hedgehog parameter.\n\nNext $n-1$ lines contains two integers $u$ $v$ ($1 \\le u, \\,\\, v \\le n; \\,\\, u \\ne v$) — indices of vertices connected by edge.\n\nIt is guaranteed that given graph is a tree.\n\n\n-----Output-----\n\nPrint \"Yes\" (without quotes), if given graph is $k$-multihedgehog, and \"No\" (without quotes) otherwise.\n\n\n-----Examples-----\nInput\n14 2\n1 4\n2 4\n3 4\n4 13\n10 5\n11 5\n12 5\n14 5\n5 13\n6 7\n8 6\n13 6\n9 6\n\nOutput\nYes\n\nInput\n3 1\n1 3\n2 3\n\nOutput\nNo\n\n\n\n-----Note-----\n\n2-multihedgehog from the first example looks like this:\n\n[Image]\n\nIts center is vertex $13$. Hedgehogs created on last step are: [4 (center), 1, 2, 3], [6 (center), 7, 8, 9], [5 (center), 10, 11, 12, 13].\n\nTree from second example is not a hedgehog because degree of center should be at least $3$.\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\ndef CSjXz():\n    n, k = list(map(int, input().split()))\n    connections = defaultdict(set)\n    for _ in range(n-1):\n    \tu, v = list(map(int, input().split()))\n    \tconnections[u].add(v)\n    \tconnections[v].add(u)\n    leafs = set()\n    for node in connections:\n    \tif len(connections[node])==1:\n    \t\tleafs.add(node)\n    steps = 0\n    is_correct = True\n    while is_correct and steps<=k:\n    \tnew_leafs = set()\n    \tfor x in leafs:\n    \t\tif len(connections[x])>1:\n    \t\t\tis_correct = False\n    \t\t\t#print(\"Len of %d more than one\"%x)\n    \t\t\tbreak\n    \t\troot = list(connections[x])[0]\n    \t\tif len(connections[root])<4 and len(leafs)!=3:\n    \t\t\tis_correct = False\n    \t\t\t#print(\"x: %d Len of root %d less than three\"%(x,root))\n    \t\t\t#print(connections[root])\n    \t\t\tbreak\n    \tif not is_correct:\n    \t\tbreak\n    \tfor x in leafs:\n    \t\troot = list(connections[x])[0]\n    \t\tnew_leafs.add(root)\n    \t\tconnections[root].remove(x)\n    \tleafs = new_leafs\n    \tsteps += 1\n    \tif len(leafs)==1 and len(connections[list(leafs)[0]])==0:\n    \t\tbreak\n    #print(\"steps is %d\"%steps)\n    if is_correct and steps==k:\n    \tprint(\"Yes\")\n    else:\n    \tprint('No')",
        "inputs": [
            "14 2\n1 4\n2 4\n3 4\n4 13\n10 5\n11 5\n12 5\n14 5\n5 13\n6 7\n8 6\n13 6\n9 6\n",
            "3 1\n1 3\n2 3\n",
            "16 2\n1 12\n2 12\n3 12\n4 13\n5 13\n6 13\n7 14\n8 14\n9 15\n10 15\n11 15\n12 16\n13 16\n14 16\n15 16\n"
        ],
        "outputs": [
            "Yes\n",
            "No\n",
            "No\n"
        ],
        "starter_code": "\ndef CSjXz():\n",
        "scope": [
            [
                "Function Body",
                2,
                42
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "While Loop Body",
                15,
                37
            ],
            [
                "For Loop Body",
                17,
                27
            ],
            [
                "If Statement Body",
                18,
                21
            ],
            [
                "If Statement Body",
                23,
                27
            ],
            [
                "If Statement Body",
                28,
                29
            ],
            [
                "For Loop Body",
                30,
                33
            ],
            [
                "If Statement Body",
                36,
                37
            ],
            [
                "If Statement Body",
                39,
                42
            ]
        ],
        "difficulty": "competition"
    },
    {
        "prompt": "\ndef bKDRL():\n    \"\"\"One way to create a task is to learn from life. You can choose some experience in real life, formalize it and then you will get a new task.\n\nLet's think about a scene in real life: there are lots of people waiting in front of the elevator, each person wants to go to a certain floor. We can formalize it in the following way. We have n people standing on the first floor, the i-th person wants to go to the f_{i}-th floor. Unfortunately, there is only one elevator and its capacity equal to k (that is at most k people can use it simultaneously). Initially the elevator is located on the first floor. The elevator needs |a - b| seconds to move from the a-th floor to the b-th floor (we don't count the time the people need to get on and off the elevator).\n\nWhat is the minimal number of seconds that is needed to transport all the people to the corresponding floors and then return the elevator to the first floor?\n\n\n-----Input-----\n\nThe first line contains two integers n and k (1 ≤ n, k ≤ 2000) — the number of people and the maximal capacity of the elevator.\n\nThe next line contains n integers: f_1, f_2, ..., f_{n} (2 ≤ f_{i} ≤ 2000), where f_{i} denotes the target floor of the i-th person.\n\n\n-----Output-----\n\nOutput a single integer — the minimal time needed to achieve the goal.\n\n\n-----Examples-----\nInput\n3 2\n2 3 4\n\nOutput\n8\n\nInput\n4 2\n50 100 50 100\n\nOutput\n296\n\nInput\n10 3\n2 2 2 2 2 2 2 2 2 2\n\nOutput\n8\n\n\n\n-----Note-----\n\nIn first sample, an optimal solution is:   The elevator takes up person #1 and person #2.  It goes to the 2nd floor.  Both people go out of the elevator.  The elevator goes back to the 1st floor.  Then the elevator takes up person #3.  And it goes to the 2nd floor.  It picks up person #2.  Then it goes to the 3rd floor.  Person #2 goes out.  Then it goes to the 4th floor, where person #3 goes out.  The elevator goes back to the 1st floor.\n    \"\"\"\n",
        "canonical_solution": "\ndef bKDRL():\n    \"\"\"\n    Codeforces Contest 270 Problem B\n    \n    Author  : chaotic_iak\n    Language: Python 3.3.4\n    \"\"\"\n    \n    def main():\n        n,k = read()\n        a = [i-1 for i in read()]\n        a.sort()\n        a.reverse()\n        print(sum(a[::k])*2)\n    \n    ################################### NON-SOLUTION STUFF BELOW\n    \n    def read(mode=2):\n        # 0: String\n        # 1: List of strings\n        # 2: List of integers\n        inputs = input().strip()\n        if mode == 0: return inputs\n        if mode == 1: return inputs.split()\n        if mode == 2: return list(map(int, inputs.split()))\n    \n    def write(s=\"\\n\"):\n        if s is None: s = \"\"\n        if isinstance(s, list): s = \" \".join(map(str, s))\n        s = str(s)\n        print(s, end=\"\")\n    \n    write(main())",
        "inputs": [
            "3 2\n2 3 4\n",
            "4 2\n50 100 50 100\n",
            "10 3\n2 2 2 2 2 2 2 2 2 2\n"
        ],
        "outputs": [
            "8\n",
            "296\n",
            "8\n"
        ],
        "starter_code": "\ndef bKDRL():\n",
        "scope": [
            [
                "Function Body",
                2,
                34
            ],
            [
                "Function Body",
                10,
                15
            ],
            [
                "List Comprehension",
                12,
                12
            ],
            [
                "Function Body",
                19,
                26
            ],
            [
                "If Statement Body",
                24,
                24
            ],
            [
                "If Statement Body",
                25,
                25
            ],
            [
                "If Statement Body",
                26,
                26
            ],
            [
                "Function Body",
                28,
                32
            ],
            [
                "If Statement Body",
                29,
                29
            ],
            [
                "If Statement Body",
                30,
                30
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef UlomZ():\n    \"\"\"Alice and Bob are playing a game. The game involves splitting up game pieces into two teams. There are n pieces, and the i-th piece has a strength p_{i}.\n\nThe way to split up game pieces is split into several steps:\n\n  First, Alice will split the pieces into two different groups A and B. This can be seen as writing the assignment of teams of a piece in an n character string, where each character is A or B.  Bob will then choose an arbitrary prefix or suffix of the string, and flip each character in that suffix (i.e. change A to B and B to A). He can do this step at most once.  Alice will get all the pieces marked A and Bob will get all the pieces marked B. \n\nThe strength of a player is then the sum of strengths of the pieces in the group.\n\nGiven Alice's initial split into two teams, help Bob determine an optimal strategy. Return the maximum strength he can achieve.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 5·10^5) — the number of game pieces.\n\nThe second line contains n integers p_{i} (1 ≤ p_{i} ≤ 10^9) — the strength of the i-th piece.\n\nThe third line contains n characters A or B — the assignment of teams after the first step (after Alice's step).\n\n\n-----Output-----\n\nPrint the only integer a — the maximum strength Bob can achieve.\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\nABABA\n\nOutput\n11\n\nInput\n5\n1 2 3 4 5\nAAAAA\n\nOutput\n15\n\nInput\n1\n1\nB\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample Bob should flip the suffix of length one.\n\nIn the second sample Bob should flip the prefix or the suffix (here it is the same) of length 5.\n\nIn the third sample Bob should do nothing.\n    \"\"\"\n",
        "canonical_solution": "\ndef UlomZ():\n    n = input()\n    s = [int(x) for x in input().split(' ')]\n    g = input()\n    A = 0\n    B = 0\n    for i in range(len(g)):\n    \tif g[i] == 'A':\n    \t\tA += s[i]\n    \telse:\n    \t\tB += s[i]\n    \n    startA, startB = A, B\n    maximum = B\n    \n    for i in range(len(g)):\n    \tif g[i] == 'A':\n    \t\tA -= s[i]\n    \t\tB += s[i]\n    \telse:\n    \t\tA += s[i]\n    \t\tB -= s[i]\n    \tif B > maximum:\n    \t\tmaximum = B\n    \n    A, B = startA, startB\n    \n    for i in reversed(range(len(g))):\n    \tif g[i] == 'A':\n    \t\tA -= s[i]\n    \t\tB += s[i]\n    \telse:\n    \t\tA += s[i]\n    \t\tB -= s[i]\n    \tif B > maximum:\n    \t\tmaximum = B\n    \n    print(maximum)",
        "inputs": [
            "5\n1 2 3 4 5\nABABA\n",
            "5\n1 2 3 4 5\nAAAAA\n",
            "1\n1\nB\n"
        ],
        "outputs": [
            "11\n",
            "15\n",
            "1\n"
        ],
        "starter_code": "\ndef UlomZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                39
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "If Statement Body",
                9,
                12
            ],
            [
                "For Loop Body",
                17,
                25
            ],
            [
                "If Statement Body",
                18,
                23
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "For Loop Body",
                29,
                37
            ],
            [
                "If Statement Body",
                30,
                35
            ],
            [
                "If Statement Body",
                36,
                37
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n            \"\"\"Given a string s, return the maximum number of unique substrings that the given string can be split into.\nYou can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.\nA substring is a contiguous sequence of characters within a string.\n \nExample 1:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.\n\nExample 2:\nInput: s = \"aba\"\nOutput: 2\nExplanation: One way to split maximally is ['a', 'ba'].\n\nExample 3:\nInput: s = \"aa\"\nOutput: 1\nExplanation: It is impossible to split the string any further.\n\n \nConstraints:\n\n\n1 <= s.length <= 16\n\n\ns contains only lower case English letters.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n        self.x, n = 0, len(s)\n        def maxUniqueSplit_(i=0, S=set()):\n            if s[i:] not in S:\n                self.x = max(self.x, len(S) + 1)\n            \n            for j in range(i + 1, n):\n                if s[i : j] not in S and len(S) + 1 + n - j > self.x:\n                    maxUniqueSplit_(j, S.union({s[i : j]}))\n            \n        \n        maxUniqueSplit_()\n        return self.x",
        "inputs": [
            [
                "\"ababccc\""
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxUniqueSplit(self, s: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                14
            ],
            [
                "Function Body",
                2,
                14
            ],
            [
                "Function Body",
                4,
                10
            ],
            [
                "If Statement Body",
                5,
                6
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                9,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef cpgYB():\n    \"\"\"Chef likes to travel a lot. Every day Chef tries to visit as much cities as possible. Recently he had a quite a few trips of great Chefland for learning various recipes. Chefland had N cities numbered from 1 to N. People in Chefland are very friendly, friendliness of i-th city is given by Fi.\n\nBefore starting of each trip, Chef's initial enjoyment is 1 unit. Whenever he visits a city with friendliness Fi, his enjoyment gets multiplied by Fi units. \n\nCity 1 is the home city of Chef. He starts each trip from his home city. Before starting a trip, he chooses a parameter R which denotes that he will start from city 1, and go to city 1 + R, then to 1 + 2 * R, then to 1 + 3 * R, till 1 + i * R such that i is largest integer satisfying 1 + i * R ≤ N.\n\nNow, Chef wants you to help him recreate his visit of the cities. Specifically, he will ask you Q queries, each of which can be of following two types.\n\n- 1 p f : friendliness of p-th city changes to f, i.e. Fp = f \n- 2 R   : Find out the total enjoyment Chef will have during this trip. As Chef does not like big numbers, he just asks you to output two things, first digit of the enjoyment and value of enjoyment modulo 109 + 7.\n\n-----Input-----\nThere is a single test case.\nFirst line of input contains a single integer N, denoting number of cities in Chefland.\nSecond line of the input contains N space separated integer - F1, F2, ..., FN, denoting the friendliness of the cities in order from 1 to N.\nNext line contains an integer Q, denoting number of queries.\n\nFor each of the next Q queries, each line corresponds to one of the two types of the query. First there will be an integer denoting the type of the query, followed by the actual query. For query of type 1, there will be three space separated integers \"1 p f\" as defined above. For query of type 2, there will be two space separated integers \"2 R \", as defined above.\n\n-----Output-----\nFor each query of type 2, output two space separated integers, first digit of Chef's enjoyment in this trip followed by the value of enjoyment modulo 109 + 7.\n\n-----Constraints-----\n-  1 ≤ N, Q ≤ 105 \n-  1 ≤ Fi ≤ 10^9 \n-  1 ≤ f ≤ 10^9 \n-  1 ≤ p ≤ N \n-  1 ≤ R ≤ N \n\n-----Subtasks-----\nSubtask #1 (5 points) : \n\n-  1 ≤ N ≤ 10 \n-  1 ≤ Q  ≤ 1000 \n-  1 ≤ Fi ≤ 10 \n-  1 ≤ f ≤ 10 \n\nSubtask #2 (15 points) : \n\n-  1 ≤ N ≤ 1000 \n-  1 ≤ Q  ≤ 100 \n-  1 ≤ Fi ≤ 109 \n-  1 ≤ f ≤ 1000 \n\nSubtask #3 (80 points) : \n\n- original constraints\n\n-----Example-----\nInput:\n5\n1 2 3 4 5\n3\n2 1\n1 3 10\n2 2\n\nOutput:\n1 120\n5 50\n\n-----Explanation-----\nIn the first query, Chef is going to visit cities 1, 2, 3, 4, 5 in order. At the end of the trip, his total enjoyment will be 1 * 2 * 3 * 4 * 5 = 120. First digit of enjoyment is 1 and 120 modulo 109 + 7 is 120.\nIn the third query, Chef is going to visit cities 1, 3, 5 in order. At the end of the trip, his total enjoyment will be 1 * 10 * 5 = 50.\n    \"\"\"\n",
        "canonical_solution": "\ndef cpgYB():\n    n=int(input())\n    a=list(map(int,input().split()))\n    q=int(input())\n    while q>0:\n     i=1\n     tot=a[0]\n     b=list(map(int,input().split()))\n     if b[0]==1:\n      #p,f=map(int,raw_input().split())\n      a[b[1]-1]=b[2]\n     else:\n      #r=int(raw_input())\n      tot=a[0]\n      while 1+i*b[1]<=n:\n       tot=tot*a[i*b[1]]\n       i=i+1\n      m=(str)(tot)\n      tot=tot%1000000007\n      print((int)(m[0]),tot)\n     q=q-1\n    ",
        "inputs": [
            "5\n1 2 3 4 5\n3\n2 1\n1 3 10\n2 2\n"
        ],
        "outputs": [
            "1 120\n5 50\n"
        ],
        "starter_code": "\ndef cpgYB():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "While Loop Body",
                6,
                22
            ],
            [
                "If Statement Body",
                10,
                21
            ],
            [
                "While Loop Body",
                16,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef yjowB():\n    \"\"\"You might have remembered Theatre square from the problem 1A. Now it's finally getting repaved.\n\nThe square still has a rectangular shape of $n \\times m$ meters. However, the picture is about to get more complicated now. Let $a_{i,j}$ be the $j$-th square in the $i$-th row of the pavement.\n\nYou are given the picture of the squares:  if $a_{i,j} = $ \"*\", then the $j$-th square in the $i$-th row should be black;  if $a_{i,j} = $ \".\", then the $j$-th square in the $i$-th row should be white. \n\nThe black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:  $1 \\times 1$ tiles — each tile costs $x$ burles and covers exactly $1$ square;  $1 \\times 2$ tiles — each tile costs $y$ burles and covers exactly $2$ adjacent squares of the same row. Note that you are not allowed to rotate these tiles or cut them into $1 \\times 1$ tiles. \n\nYou should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.\n\nWhat is the smallest total price of the tiles needed to cover all the white squares?\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 500$) — the number of testcases. Then the description of $t$ testcases follow.\n\nThe first line of each testcase contains four integers $n$, $m$, $x$ and $y$ ($1 \\le n \\le 100$; $1 \\le m \\le 1000$; $1 \\le x, y \\le 1000$) — the size of the Theatre square, the price of the $1 \\times 1$ tile and the price of the $1 \\times 2$ tile.\n\nEach of the next $n$ lines contains $m$ characters. The $j$-th character in the $i$-th line is $a_{i,j}$. If $a_{i,j} = $ \"*\", then the $j$-th square in the $i$-th row should be black, and if $a_{i,j} = $ \".\", then the $j$-th square in the $i$-th row should be white.\n\nIt's guaranteed that the sum of $n \\times m$ over all testcases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each testcase print a single integer — the smallest total price of the tiles needed to cover all the white squares in burles.\n\n\n-----Example-----\nInput\n4\n1 1 10 1\n.\n1 2 10 1\n..\n2 1 10 1\n.\n.\n3 3 3 7\n..*\n*..\n.*.\n\nOutput\n10\n1\n20\n18\n\n\n\n-----Note-----\n\nIn the first testcase you are required to use a single $1 \\times 1$ tile, even though $1 \\times 2$ tile is cheaper. So the total price is $10$ burles.\n\nIn the second testcase you can either use two $1 \\times 1$ tiles and spend $20$ burles or use a single $1 \\times 2$ tile and spend $1$ burle. The second option is cheaper, thus the answer is $1$.\n\nThe third testcase shows that you can't rotate $1 \\times 2$ tiles. You still have to use two $1 \\times 1$ tiles for the total price of $20$.\n\nIn the fourth testcase the cheapest way is to use $1 \\times 1$ tiles everywhere. The total cost is $6 \\cdot 3 = 18$.\n    \"\"\"\n",
        "canonical_solution": "\ndef yjowB():\n    inp=lambda :map(int,input().split())\n    def sol():\n        x,y,on,tw=inp()\n        res=0\n        for n in range(x):\n            s=input()\n            sm=0\n            for n in s:\n                if n=='.':\n                    sm+=1\n                else:\n                    a=sm*on\n                    b=(sm//2)*tw+(sm%2)*on\n                    res+=min(a,b)\n                    sm=0\n            a=sm*on\n            b=(sm//2)*tw+(sm%2)*on\n            res+=min(a,b)\n        print(res)\n    \n    for n in range(int(input())):\n        sol()",
        "inputs": [
            "4\n1 1 10 1\n.\n1 2 10 1\n..\n2 1 10 1\n.\n.\n3 3 3 7\n..*\n*..\n.*.\n",
            "1\n3 3 2 4\n**.\n***\n***\n",
            "1\n9 9 9 9\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n.........\n"
        ],
        "outputs": [
            "10\n1\n20\n18\n",
            "2\n",
            "405\n"
        ],
        "starter_code": "\ndef yjowB():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "Lambda Expression",
                3,
                3
            ],
            [
                "Function Body",
                4,
                21
            ],
            [
                "For Loop Body",
                7,
                20
            ],
            [
                "For Loop Body",
                10,
                17
            ],
            [
                "If Statement Body",
                11,
                17
            ],
            [
                "For Loop Body",
                23,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n            \"\"\"Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors.\nIf there is no such integer in the array, return 0.\n \nExample 1:\nInput: nums = [21,4,7]\nOutput: 32\nExplanation:\n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\n \nConstraints:\n\n1 <= nums.length <= 10^4\n1 <= nums[i] <= 10^5\n    \"\"\"\n",
        "canonical_solution": "# 1390. Four Divisors\n# version 2, with optimized prime-finding.\n\nimport math\n\ndef remove (lst, index):\n    assert lst\n    tail = len (lst) - 1\n    lst[index], lst[tail] = lst[tail], lst[index]\n    lst.pop ()\n\ndef swap_min (lst):\n    if not lst: return\n    argmin = min (range (len (lst)), key = lambda i: lst[i])\n    lst[0], lst[argmin] = lst[argmin], lst[0]\n\ndef find_primes (top):\n    candidates = list (range (2, top))\n    primes = []\n    while candidates:\n        # here, candidates[0] is the least element.\n        latest_prime = candidates[0]\n        primes.append (latest_prime)\n        remove (candidates, 0)\n        for i in range (len (candidates) - 1, -1, -1):\n            if candidates[i] % latest_prime == 0:\n                remove (candidates, i)\n\n        swap_min (candidates)\n        # before continuing, set candidates[0] to be the least element.\n    return primes\n\ndef find_prime_factor (n, primes):\n    for p in primes:\n        if n % p == 0:\n            return p\n\ndef div4 (n, primes, setprimes):\n    if n <= 3:\n        return 0\n    elif n in setprimes:\n        return 0\n    else:\n        p1 = find_prime_factor (n, primes)\n        if p1 is None:\n            return 0\n        p2 = find_prime_factor (n // p1, primes)\n        if p2 is None:\n            p2 = n // p1\n        if p1 * p2 == n and p1 != p2:\n            # success\n            return (1 + p1) * (1 + p2)\n        elif p1 ** 3 == n:\n            # success\n            return (1 + p1) * (1 + p1**2)\n        else:\n            return 0\n\ndef sum_four_divisors (arr):\n    top = math.ceil (math.sqrt (max (arr) + 5))\n    primes = find_primes (top)\n    setprimes = set (primes)\n    return sum (div4 (elem, primes, setprimes) for elem in arr)\n\nclass Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n        return sum_four_divisors(nums)",
        "inputs": [
            [
                [
                    21,
                    4,
                    7
                ]
            ]
        ],
        "outputs": [
            [
                32
            ]
        ],
        "starter_code": "\nclass Solution:\n    def sumFourDivisors(self, nums: List[int]) -> int:\n",
        "scope": [
            [
                "Function Body",
                6,
                10
            ],
            [
                "Function Body",
                12,
                15
            ],
            [
                "If Statement Body",
                13,
                13
            ],
            [
                "Lambda Expression",
                14,
                14
            ],
            [
                "Function Body",
                17,
                31
            ],
            [
                "While Loop Body",
                20,
                29
            ],
            [
                "For Loop Body",
                25,
                27
            ],
            [
                "If Statement Body",
                26,
                27
            ],
            [
                "Function Body",
                33,
                36
            ],
            [
                "For Loop Body",
                34,
                36
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "Function Body",
                38,
                57
            ],
            [
                "If Statement Body",
                39,
                57
            ],
            [
                "If Statement Body",
                41,
                57
            ],
            [
                "If Statement Body",
                45,
                46
            ],
            [
                "If Statement Body",
                48,
                49
            ],
            [
                "If Statement Body",
                50,
                57
            ],
            [
                "If Statement Body",
                53,
                57
            ],
            [
                "Function Body",
                59,
                63
            ],
            [
                "Generator Expression",
                63,
                63
            ],
            [
                "Class Body",
                65,
                67
            ],
            [
                "Function Body",
                66,
                67
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gAUSL():\n    \"\"\"In Takahashi Kingdom, which once existed, there are N cities, and some pairs of cities are connected bidirectionally by roads.\nThe following are known about the road network:\n - People traveled between cities only through roads. It was possible to reach any city from any other city, via intermediate cities if necessary.\n - Different roads may have had different lengths, but all the lengths were positive integers.\nSnuke the archeologist found a table with N rows and N columns, A, in the ruin of Takahashi Kingdom.\nHe thought that it represented the shortest distances between the cities along the roads in the kingdom.\nDetermine whether there exists a road network such that for each u and v, the integer A_{u, v} at the u-th row and v-th column of A is equal to the length of the shortest path from City u to City v.\nIf such a network exist, find the shortest possible total length of the roads.\n\n-----Constraints-----\n - 1 \\leq N \\leq 300\n - If i ≠ j, 1 \\leq A_{i, j} = A_{j, i} \\leq 10^9.\n - A_{i, i} = 0\n\n-----Inputs-----\nInput is given from Standard Input in the following format:\nN\nA_{1, 1} A_{1, 2} ... A_{1, N}\nA_{2, 1} A_{2, 2} ... A_{2, N}\n...\nA_{N, 1} A_{N, 2} ... A_{N, N}\n\n-----Outputs-----\nIf there exists no network that satisfies the condition, print -1.\nIf it exists, print the shortest possible total length of the roads.\n\n-----Sample Input-----\n3\n0 1 3\n1 0 2\n3 2 0\n\n-----Sample Output-----\n3\n\nThe network below satisfies the condition:\n - City 1 and City 2 is connected by a road of length 1.\n - City 2 and City 3 is connected by a road of length 2.\n - City 3 and City 1 is not connected by a road.\n    \"\"\"\n",
        "canonical_solution": "from scipy.sparse.csgraph import floyd_warshall\nfrom scipy.sparse import csr_matrix\nimport numpy as np\ndef gAUSL():\n    n = int(input())\n    a = np.array([list(map(int, input().split())) for _ in range(n)])\n    g = csr_matrix(a)\n    dist = floyd_warshall(g)\n    if (dist == a).all():\n        sm = a.sum()\n        INF = 10 ** 18 + 1\n        for i in range(n):\n            a[i, i] = INF\n        for u in range(n):\n            for v in range(n):\n                if u == v:\n                    continue\n                mn = np.min(a[u] + a[v])\n                if mn == a[u, v]:\n                    sm -= a[u, v]\n        ans = sm // 2\n        print(ans)\n    else:\n        print((-1))",
        "inputs": [
            "3\n0 1 3\n1 0 2\n3 2 0\n",
            "3\n0 1 3\n1 0 1\n3 1 0\n",
            "5\n0 21 18 11 28\n21 0 13 10 26\n18 13 0 23 13\n11 10 23 0 17\n28 26 13 17 0\n"
        ],
        "outputs": [
            "3\n",
            "-1\n",
            "82\n"
        ],
        "starter_code": "\ndef gAUSL():\n",
        "scope": [
            [
                "Function Body",
                4,
                24
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "If Statement Body",
                9,
                24
            ],
            [
                "For Loop Body",
                12,
                13
            ],
            [
                "For Loop Body",
                14,
                20
            ],
            [
                "For Loop Body",
                15,
                20
            ],
            [
                "If Statement Body",
                16,
                17
            ],
            [
                "If Statement Body",
                19,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef PnIpN():\n    \"\"\"Dr. S. De teaches computer architecture in NIT Patna. Whenever he comes across any good question(with complexity $k$), he gives that question to students within roll number range $i$ and $j$\nAt the start of semester he assigns score of $10$ to every student in his class if a student submits a question of complexity $k$, his score gets multiplied by $k$\nThis month he gave $M$ questions and he is wondering what will be mean of maximum scores of all the student. He is busy in improving his finger print attendance module, can you help him?\nInput file may be large so try to use fast input output\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a First line of input, two integers $N, M$ i.e. Number of students in the class and number of questions given in this month. \n- Next $M$ lines contains 3 integers -$i, j, k$ i.e. starting roll number, end roll number and complexity of the question\n\n-----Output:-----\nFor each testcase, output in a single line answer - $floor$ value of Mean of maximum possible score for all students.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, M \\leq 10^5$\n- $1 \\leq i \\leq j \\leq N$\n- $1 \\leq k \\leq 100$\n\n-----Subtasks-----\nSubtask1 \n- \n$1 \\leq T \\leq 10$\n- \n$1 \\leq N, M \\leq 10^4$\nSubtask2\n- \nOriginal Constraints \n\n-----Sample Input:-----\n1\n5 3\n1 3 5\n2 5 2\n3 4 7\n\n-----Sample Output:-----\n202\n\n-----EXPLANATION:-----\nInitial score of students will be : $[10, 10, 10, 10, 10]$\nafter solving question 1 scores will be: $[50, 50, 50, 10, 10]$\nafter solving question 2 scores will be: $[50, 100, 100, 20, 20]$\nafter solving question 1 scores will be: $[50, 100, 700, 140, 20]$\nHence after all questions mean of maximum scores will $(50+100+700+140+20)/5 = 202$\n    \"\"\"\n",
        "canonical_solution": "\ndef PnIpN():\n    try:\n     t=int(input())\n     for a in range(t):\n      l=input().split()\n      n=int(l[0])\n      m=int(l[1])\n      d={}\n      s=0\n      for b in range(m):\n       l1=input().split()\n       i=int(l1[0])\n       j=int(l1[1])\n       k=int(l1[2])\n       for c in range(i,j+1):\n        if c not in d:\n         d[c]=10\n       for c in range(i,j+1):\n        d[c]=d[c]*k\n      for i in d:\n       s=s+d[i]\n      print(s//n)\n    except:\n     pass",
        "inputs": [
            "1\n5 3\n1 3 5\n2 5 2\n3 4 7\n"
        ],
        "outputs": [
            "202\n"
        ],
        "starter_code": "\ndef PnIpN():\n",
        "scope": [
            [
                "Function Body",
                2,
                25
            ],
            [
                "Try Block",
                3,
                25
            ],
            [
                "Except Block",
                24,
                25
            ],
            [
                "For Loop Body",
                5,
                23
            ],
            [
                "For Loop Body",
                11,
                20
            ],
            [
                "For Loop Body",
                16,
                18
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "For Loop Body",
                21,
                22
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef CzDrf():\n    \"\"\"A maze is composed of a grid of H \\times W squares - H vertical, W horizontal.\nThe square at the i-th row from the top and the j-th column from the left - (i,j) - is a wall if S_{ij} is # and a road if S_{ij} is ..\nThere is a magician in (C_h,C_w). He can do the following two kinds of moves:\n - Move A: Walk to a road square that is vertically or horizontally adjacent to the square he is currently in.\n - Move B: Use magic to warp himself to a road square in the 5\\times 5 area centered at the square he is currently in.\nIn either case, he cannot go out of the maze.\nAt least how many times does he need to use the magic to reach (D_h, D_w)?\n\n-----Constraints-----\n - 1 \\leq H,W \\leq 10^3\n - 1 \\leq C_h,D_h \\leq H\n - 1 \\leq C_w,D_w \\leq W\n - S_{ij} is # or ..\n - S_{C_h C_w} and S_{D_h D_w} are ..\n - (C_h,C_w) \\neq (D_h,D_w)\n\n-----Input-----\nInput is given from Standard Input in the following format:\nH W\nC_h C_w\nD_h D_w\nS_{11}\\ldots S_{1W}\n\\vdots\nS_{H1}\\ldots S_{HW}\n\n-----Output-----\nPrint the minimum number of times the magician needs to use the magic. If he cannot reach (D_h,D_w), print -1 instead.\n\n-----Sample Input-----\n4 4\n1 1\n4 4\n..#.\n..#.\n.#..\n.#..\n\n-----Sample Output-----\n1\n\nFor example, by walking to (2,2) and then using the magic to travel to (4,4), just one use of magic is enough.\nNote that he cannot walk diagonally.\n    \"\"\"\n",
        "canonical_solution": "from collections import deque\ndef CzDrf():\n    # import numpy as np\n    def solve(): #H, W, CH, CW, DH, DW, S):\n    \tH,W=list(map(int,input().split()))\n    \tCH,CW=list(map(int,input().split()))\n    \tDH,DW=list(map(int,input().split()))\n    \tS=[input() for _ in range(H)]\n    \t# 後の条件分岐を簡略化するためワープしても迷路外に出ないように壁で囲む\n    \tS = ['##{}##'.format(row) for row in S]\n    \tS.insert(0, '##{}##'.format('#' * W))\n    \tS.insert(0, '##{}##'.format('#' * W))\n    \tS.append('##{}##'.format('#' * W))\n    \tS.append('##{}##'.format('#' * W))\n    \tMAX_COST = 10 ** 9\n    \tCost=[ [ MAX_COST for _ in range(W+4)] for _ in range(H+4)]\n    \t# Cost = np.full((H,W),MAX_COST)\n    \t# print(S)\n    \tans = -1\n    \tcost0 = deque()\n    \tcost0.append((CH+1,CW+1,0))\n    \tCost[CH+1][CW+1] = 0;\n    \t# used = set()\n    \twalk=[(1,0),(0,1),(-1,0),(0,-1)]\n    \twarp = [ (i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0, 0)] + walk ]\n    \t# print(warp)\n    \tcost1 = deque()\n    \twhile cost0:\n    \t\th,w,c=cost0.popleft()\n    \t\tcost1.append((h,w,c))\n    \t\tfor i,j in walk:\n    \t\t\tdh = h+i\n    \t\t\tdw = w+j\n    \t\t\tif S[dh][dw] == '.' and c < Cost[dh][dw]:\n    \t\t\t\tCost[dh][dw] = c\n    \t\t\t\t# print(\"updl \", i,j,dh,dw,c)\n    \t\t\t\tcost0.appendleft((dh,dw,Cost[dh][dw]))\n    \t\tif len(cost0) == 0:\n    \t\t\twhile cost1:\n    \t\t\t\th,w,c=cost1.popleft()\n    \t\t\t\t# print(h,w,c)\n    \t\t\t\tfor i,j in warp:\n    \t\t\t\t\tdh = h+i\n    \t\t\t\t\tdw = w+j\n    \t\t\t\t\t# print(i,j)\n    \t\t\t\t\tif S[dh][dw] == '.' and c + 1 < Cost[dh][dw]:\n    \t\t\t\t\t\tCost[dh][dw] = c + 1\n    \t\t\t\t\t\tcost0.append((dh,dw,Cost[dh][dw]))\n    \tif Cost[DH+1][DW+1] == MAX_COST:\n    \t\tprint((-1))\n    \telse:\n    \t\tprint((Cost[DH+1][DW+1]))\n    def __starting_point():\n    \t# S=[input() for _ in range(H)]\n    \tsolve() #H, W, CH, CW, DH, DW, S)\n    __starting_point()",
        "inputs": [
            "4 4\n1 1\n4 4\n..#.\n..#.\n.#..\n.#..\n",
            "4 4\n1 4\n4 1\n.##.\n####\n####\n.##.\n",
            "4 4\n2 2\n3 3\n....\n....\n....\n....\n"
        ],
        "outputs": [
            "1\n",
            "-1\n",
            "0\n"
        ],
        "starter_code": "\ndef CzDrf():\n",
        "scope": [
            [
                "Function Body",
                2,
                56
            ],
            [
                "Function Body",
                4,
                52
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "List Comprehension",
                16,
                16
            ],
            [
                "List Comprehension",
                16,
                16
            ],
            [
                "List Comprehension",
                25,
                25
            ],
            [
                "While Loop Body",
                28,
                48
            ],
            [
                "For Loop Body",
                31,
                37
            ],
            [
                "If Statement Body",
                34,
                37
            ],
            [
                "If Statement Body",
                38,
                48
            ],
            [
                "While Loop Body",
                39,
                48
            ],
            [
                "For Loop Body",
                42,
                48
            ],
            [
                "If Statement Body",
                46,
                48
            ],
            [
                "If Statement Body",
                49,
                52
            ],
            [
                "Function Body",
                53,
                55
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef jmUXl():\n    \"\"\"Alice and Bob play a game. There is a paper strip which is divided into n + 1 cells numbered from left to right starting from 0. There is a chip placed in the n-th cell (the last one).\n\nPlayers take turns, Alice is first. Each player during his or her turn has to move the chip 1, 2 or k cells to the left (so, if the chip is currently in the cell i, the player can move it into cell i - 1, i - 2 or i - k). The chip should not leave the borders of the paper strip: it is impossible, for example, to move it k cells to the left if the current cell has number i < k. The player who can't make a move loses the game.\n\nWho wins if both participants play optimally?\n\nAlice and Bob would like to play several games, so you should determine the winner in each game.\n\n\n-----Input-----\n\nThe first line contains the single integer T (1 ≤ T ≤ 100) — the number of games. Next T lines contain one game per line. All games are independent.\n\nEach of the next T lines contains two integers n and k (0 ≤ n ≤ 10^9, 3 ≤ k ≤ 10^9) — the length of the strip and the constant denoting the third move, respectively.\n\n\n-----Output-----\n\nFor each game, print Alice if Alice wins this game and Bob otherwise.\n\n\n-----Example-----\nInput\n4\n0 3\n3 3\n3 4\n4 4\n\nOutput\nBob\nAlice\nBob\nAlice\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef jmUXl():\n    T = int(sys.stdin.readline().strip())\n    for t in range(0, T):\n        n, k = list(map(int, sys.stdin.readline().strip().split()))\n        if k % 3 != 0:\n            if n % 3 == 0:\n                print(\"Bob\")\n            else:\n                print(\"Alice\")\n        else:\n            n = n % (k + 1)\n            if n == k:\n                print(\"Alice\")\n            elif n % 3 == 0:\n                print(\"Bob\")\n            else:\n                print(\"Alice\")",
        "inputs": [
            "4\n0 3\n3 3\n3 4\n4 4\n",
            "1\n73 18\n",
            "1\n25 6\n"
        ],
        "outputs": [
            "Bob\nAlice\nBob\nAlice\n",
            "Alice\n",
            "Alice\n"
        ],
        "starter_code": "\ndef jmUXl():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "For Loop Body",
                4,
                18
            ],
            [
                "If Statement Body",
                6,
                18
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "If Statement Body",
                13,
                18
            ],
            [
                "If Statement Body",
                15,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef MNien():\n    \"\"\"Walter White and Jesse Pinkman (a drug addict) both love to play with chemicals. One day they were playing with some chemicals to make an energy drink. Unknowingly they made a highly powerful drink. To test the drink on others also they called some of their friends and gave a drop of it to everyone. Now they all were feeling highly energetic and thought of an unique game to play with each other.\nAfter pondering for a while, Jesse came up with an extraordinary idea of competing in a race around a circular globe with N checkpoints each of one unit. Walter and all their other friends agreed with it.They divided themselves in $2$ teams with $N$ teammates in each team.This race has two commencing points $A$ and $B$ strictly facing each other. Walter and his team commences from $A$ point and other team starts from $B$. Both the teams start running at the same time clockwise around the globe. Speed of every player is constant throughout the race. If a player has a speed $X$ then it means that he covers a distance of $X$ units in one second.The race ends when some member of one team overtakes all members of opposite team at any point of time. Now you have to tell if any team will win the race or not.They all are stubborn and can run forever just to win the race. Help them to know if it is possible in anyway that the race will come to an end. \nFor Clarity, you can visualize the path as a circular paths where $A$ and $B$ are opposite ends of diameter. It can be proven that the actual circumference of circle do not affect the answer.\nIt is also possible that someone don't run at all.Keep in mind that the fastest one wins the race so does the code.\n\n-----Input:------\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. \n- The first line of each test case contains a single integer $N$ number of teammates in both team.\n- The second line contains $N$ space-separated integers $A_1, A_2 \\ldots A_N$ denoting speed of A's Team\n- The third line contains $N$ space-separated integers  $B_1, B_2 \\ldots B_N$ denoting speed of B's Team\n\n-----Output:------\nFor each test case, print a single line denoting YES if the race ends at any point of time else NO\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $0 \\leq A_i \\leq 2^{15}$\n- $0 \\leq B_i \\leq 2^{15}$\n\n-----Subtasks-----\nSubtask #1 (30 points): \n- $1 \\le N \\le 20$\n- $0 \\le  A_i  \\le 11$\n- $0 \\le  B_i  \\le 11$\nSubtask #2 (70 points): \n- Original constraints\n\n-----Sample input:-----\n1\n5\n1 2 3 4 5\n2 7 8 9 9\n\n-----Sample output-----\nYES\n\n-----Sample Explanation:------\nTeam B can overtake all members of Team A.\n    \"\"\"\n",
        "canonical_solution": "\ndef MNien():\n    # cook your dish here\n    l1=int(input())\n    for i in range(l1):\n        x=int(input())\n        y=list(map(int,input().split()))\n        z=list(map(int,input().split()))\n        if max(z)!=max(y):\n            print('YES')\n        else:\n            print('NO')",
        "inputs": [
            "1\n5\n1 2 3 4 5\n2 7 8 9 9\n\n"
        ],
        "outputs": [
            "YES\n"
        ],
        "starter_code": "\ndef MNien():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                5,
                12
            ],
            [
                "If Statement Body",
                9,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef tlIda():\n    \"\"\"Today a plane was hijacked by a maniac. All the passengers of the flight are taken as hostage. Chef is also one of them.\nHe invited one of the passengers to play a game with him. If he loses the game, he will release all the passengers, otherwise he will kill all of them. A high risk affair it is.\n\nChef volunteered for this tough task. He was blindfolded by Hijacker. Hijacker brought a big black bag from his pockets. The contents of the bag is not visible. He tells Chef that the bag contains R red, G green and B blue colored balloons.\n\nHijacker now asked Chef to take out some balloons from the box such that there are at least K balloons of the same color and hand him over. If the taken out balloons does not contain at least K balloons of the same color, then the hijacker will shoot everybody. Chef is very scared and wants to leave this game as soon as possible, so he will draw the minimum number of balloons so as to save the passengers. Can you please help scared Chef to find out the minimum number of balloons he should take out.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a three space-separated integers R, G and B. \n\nThe second line contains only one integer K.\n\n-----Output-----\nFor each test case, output a single line containing one integer - the minimum number of balloons Chef need to take out from the bag.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ R, G, B ≤ 109\n- 1 ≤ K ≤ max{R, G, B}\n\n-----Subtasks-----\n- Subtask 1 (44 points): 1 ≤ R, G, B ≤ 10\n- Subtask 2 (56 points):  No additional constraints\n\n-----Example-----\nInput:\n2\n3 3 3\n1\n3 3 3\n2\n\nOutput:\n1\n4\n\n-----Explanation-----\nExample case 2. In the worst-case scenario first three balloons will be of the three different colors and only after fourth balloon Chef will have two balloons of the same color. So, Chef might need to fetch 4 balloons\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef tlIda():\n    test_cases = int(input())\n    for i in range(0,test_cases):\n     count = input().split()\n     #print count\n     count_r = int(count[0])\n     count_g = int(count[1])\n     count_b = int(count[2])\n     k = int(input())\n     if k == 1:\n      total = 1\n     else:   \n      total = 1\n      if count_r < k:\n       total = total + count_r\n      else:\n       total = total + (k-1)\n      if count_g < k:\n       total = total + count_g\n      else:\n       total = total + (k-1) \n      if count_b < k:\n       total = total + count_b\n      else:\n       total = total + (k-1)\n     \n     print(total)",
        "inputs": [
            "2\n3 3 3\n1\n3 3 3\n2\n"
        ],
        "outputs": [
            "1\n4\n"
        ],
        "starter_code": "\ndef tlIda():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "For Loop Body",
                4,
                28
            ],
            [
                "If Statement Body",
                11,
                26
            ],
            [
                "If Statement Body",
                15,
                18
            ],
            [
                "If Statement Body",
                19,
                22
            ],
            [
                "If Statement Body",
                23,
                26
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef XYWky():\n    \"\"\"Takahashi is playing a board game called Sugoroku.\nOn the board, there are N + 1 squares numbered 0 to N. Takahashi starts at Square 0, and he has to stop exactly at Square N to win the game.\nThe game uses a roulette with the M numbers from 1 to M. In each turn, Takahashi spins the roulette. If the number x comes up when he is at Square s, he moves to Square s+x. If this makes him go beyond Square N, he loses the game.\nAdditionally, some of the squares are Game Over Squares. He also loses the game if he stops at one of those squares. You are given a string S of length N + 1, representing which squares are Game Over Squares. For each i (0 \\leq i \\leq N), Square i is a Game Over Square if S[i] = 1 and not if S[i] = 0.\nFind the sequence of numbers coming up in the roulette in which Takahashi can win the game in the fewest number of turns possible. If there are multiple such sequences, find the lexicographically smallest such sequence. If Takahashi cannot win the game, print -1.\n\n-----Constraints-----\n - 1 \\leq N \\leq 10^5\n - 1 \\leq M \\leq 10^5\n - |S| = N + 1\n - S consists of 0 and 1.\n - S[0] = 0\n - S[N] = 0\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nS\n\n-----Output-----\nIf Takahashi can win the game, print the lexicographically smallest sequence among the shortest sequences of numbers coming up in the roulette in which Takahashi can win the game, with spaces in between.\nIf Takahashi cannot win the game, print -1.\n\n-----Sample Input-----\n9 3\n0001000100\n\n-----Sample Output-----\n1 3 2 3\n\nIf the numbers 1, 3, 2, 3 come up in this order, Takahashi can reach Square 9 via Square 1, 4, and 6. He cannot reach Square 9 in three or fewer turns, and this is the lexicographically smallest sequence in which he reaches Square 9 in four turns.\n    \"\"\"\n",
        "canonical_solution": "from bisect import bisect_left\ndef XYWky():\n    N, M = list(map(int, input().split()))\n    S = input()\n    good = []\n    bad = []\n    for i in range(N + 1):\n        if S[i] == \"1\":\n            bad.append(i)\n        else:\n            good.append(i)\n    ans = []\n    cur = N\n    while True:\n        if cur == 0:\n            print((\" \".join(map(str, ans[::-1]))))\n            break\n        idx = bisect_left(good, cur - M)\n        nx = good[idx]\n        ans.append(cur - nx)\n        if cur == nx:\n            print((-1))\n            break\n        cur = nx",
        "inputs": [
            "9 3\n0001000100\n",
            "5 4\n011110\n",
            "6 6\n0101010\n"
        ],
        "outputs": [
            "1 3 2 3\n",
            "-1\n",
            "6\n"
        ],
        "starter_code": "\ndef XYWky():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ],
            [
                "While Loop Body",
                14,
                24
            ],
            [
                "If Statement Body",
                15,
                17
            ],
            [
                "If Statement Body",
                21,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n            \"\"\"n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of passengers will:\n\nTake their own seat if it is still available, \nPick other seats randomly when they find their seat occupied \n\nWhat is the probability that the n-th person can get his own seat?\n \nExample 1:\nInput: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.\nExample 2:\nInput: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n\n \nConstraints:\n\n1 <= n <= 10^5\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        return 1 / min(n, 2.0) \n        \n",
        "inputs": [
            [
                1
            ]
        ],
        "outputs": [
            [
                1.0
            ]
        ],
        "starter_code": "\nclass Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n",
        "scope": [
            [
                "Class Body",
                1,
                3
            ],
            [
                "Function Body",
                2,
                3
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n            \"\"\"Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.\nThe score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\n \nExample 1:\nInput: [8,1,5,2,6]\nOutput: 11\nExplanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n\n \nNote:\n\n2 <= A.length <= 50000\n1 <= A[i] <= 1000\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n        curmaxsight = A[0] - 1\n        curmaxpair = 0\n        for sight in A[1:]:\n            if sight + curmaxsight > curmaxpair:\n                curmaxpair = sight + curmaxsight\n            if sight > curmaxsight:\n                curmaxsight = sight\n            curmaxsight -= 1\n        return curmaxpair\n            \n",
        "inputs": [
            [
                [
                    8,
                    1,
                    5,
                    2,
                    6
                ]
            ]
        ],
        "outputs": [
            [
                11
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                11
            ],
            [
                "Function Body",
                2,
                11
            ],
            [
                "For Loop Body",
                5,
                10
            ],
            [
                "If Statement Body",
                6,
                7
            ],
            [
                "If Statement Body",
                8,
                9
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef MCgkn():\n    \"\"\"You are given an N × N grid initially filled by zeros. Let the rows and columns of the grid be numbered from 1 to N, inclusive. There are two types of operations can be applied to the grid:\n\n- RowAdd R X: all numbers in the row R should be increased by X.\n- ColAdd C X: all numbers in the column C should be increased by X.\n\nNow after performing the sequence of such operations you need to find the maximum element in the grid.\n\n-----Input-----\nThe first line of the input contains two space separated integers N and Q denoting the size of the grid and the number of performed operations respectively. Each of the following Q lines describe an operation in the format described above.\n\n-----Output-----\nOutput a single line containing the maximum number at the grid after performing all the operations.\n\n-----Constraints-----\n- 1 ≤ N ≤ 314159\n- 1 ≤ Q ≤ 314159\n- 1 ≤ X ≤ 3141\n- 1 ≤ R, C ≤ N\n\n-----Example-----\nInput:\n2 4\nRowAdd 1 3\nColAdd 2 1\nColAdd 1 4\nRowAdd 2 1\n\nOutput:\n7\n\n-----Explanation-----\nThe grid changes as follows:\n00  33  34  74  74\n00  00  01  41  52\n\nThe maximum number in the final grid is 7.\n    \"\"\"\n",
        "canonical_solution": "\ndef MCgkn():\n    n,q=map(int,input().split())\n    dr={}\n    dc={}\n    for i in range(1,n+1):\n     dr[i]=0\n     dc[i]=0\n    mer=0\n    mec=0\n    for i in range(q):\n     s,j,k=input().split()\n     j=int(j)\n     k=int(k)\n     if s==\"RowAdd\":\n      dr[j]+=k\n      if dr[j]>mer:\n       mer=dr[j]\n     else:\n      dc[j]+=k\n      if mec<dc[j]:\n       mec=dc[j]\n    # m=max(list(dr.values()))+max(list(dc.values()))\n    \n    # for i in range(n):\n    #     for j in range(n):\n    #         ar[i][j]=dr[i+1]+dc[j+1]\n    #         if ar[i][j]>m:\n    #             m=ar[i][j]\n    \n    print(mer+mec)",
        "inputs": [
            "2 4\nRowAdd 1 3\nColAdd 2 1\nColAdd 1 4\nRowAdd 2 1\n"
        ],
        "outputs": [
            "7\n"
        ],
        "starter_code": "\ndef MCgkn():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "For Loop Body",
                11,
                22
            ],
            [
                "If Statement Body",
                15,
                22
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                21,
                22
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef jMCvr():\n    \"\"\"Not so long ago the Codecraft-17 contest was held on Codeforces. The top 25 participants, and additionally random 25 participants out of those who got into top 500, will receive a Codeforces T-shirt.\n\nUnfortunately, you didn't manage to get into top 25, but you got into top 500, taking place p.\n\nNow the elimination round of 8VC Venture Cup 2017 is being held. It has been announced that the Codecraft-17 T-shirt winners will be chosen as follows. Let s be the number of points of the winner of the elimination round of 8VC Venture Cup 2017. Then the following pseudocode will be executed: \n\ni := (s div 50) mod 475\n\nrepeat 25 times:\n\n    i := (i * 96 + 42) mod 475\n\n    print (26 + i)\n\n\n\nHere \"div\" is the integer division operator, \"mod\" is the modulo (the remainder of division) operator.\n\nAs the result of pseudocode execution, 25 integers between 26 and 500, inclusive, will be printed. These will be the numbers of places of the participants who get the Codecraft-17 T-shirts. It is guaranteed that the 25 printed integers will be pairwise distinct for any value of s.\n\nYou're in the lead of the elimination round of 8VC Venture Cup 2017, having x points. You believe that having at least y points in the current round will be enough for victory.\n\nTo change your final score, you can make any number of successful and unsuccessful hacks. A successful hack brings you 100 points, an unsuccessful one takes 50 points from you. It's difficult to do successful hacks, though.\n\nYou want to win the current round and, at the same time, ensure getting a Codecraft-17 T-shirt. What is the smallest number of successful hacks you have to do to achieve that?\n\n\n-----Input-----\n\nThe only line contains three integers p, x and y (26 ≤ p ≤ 500; 1 ≤ y ≤ x ≤ 20000) — your place in Codecraft-17, your current score in the elimination round of 8VC Venture Cup 2017, and the smallest number of points you consider sufficient for winning the current round.\n\n\n-----Output-----\n\nOutput a single integer — the smallest number of successful hacks you have to do in order to both win the elimination round of 8VC Venture Cup 2017 and ensure getting a Codecraft-17 T-shirt.\n\nIt's guaranteed that your goal is achievable for any valid input data.\n\n\n-----Examples-----\nInput\n239 10880 9889\n\nOutput\n0\n\nInput\n26 7258 6123\n\nOutput\n2\n\nInput\n493 8000 8000\n\nOutput\n24\n\nInput\n101 6800 6500\n\nOutput\n0\n\nInput\n329 19913 19900\n\nOutput\n8\n\n\n\n-----Note-----\n\nIn the first example, there is no need to do any hacks since 10880 points already bring the T-shirt to the 239-th place of Codecraft-17 (that is, you). In this case, according to the pseudocode, the T-shirts will be given to the participants at the following places: \n\n475 422 84 411 453 210 157 294 146 188 420 367 29 356 398 155 102 239 91 133 365 312 449 301 343\n\n\n\nIn the second example, you have to do two successful and one unsuccessful hack to make your score equal to 7408.\n\nIn the third example, you need to do as many as 24 successful hacks to make your score equal to 10400.\n\nIn the fourth example, it's sufficient to do 6 unsuccessful hacks (and no successful ones) to make your score equal to 6500, which is just enough for winning the current round and also getting the T-shirt.\n    \"\"\"\n",
        "canonical_solution": "from math import ceil\ndef jMCvr():\n    p,x,y = map(int, input().split())\n    h = x\n    while h >=y:\n        h-=50\n    h+=50\n    for i in range(h, 10000000000, 50):\n        u = (i//50)%475\n        d = []\n        for j in range(25):\n            u = (u * 96 + 42)%475\n            d.append(26 + u)\n        if p in d:\n            k = i\n            break\n    if k-x>0:\n        print(ceil((k-x)/100))\n    else:\n        print(0)",
        "inputs": [
            "239 10880 9889\n",
            "26 7258 6123\n",
            "493 8000 8000\n"
        ],
        "outputs": [
            "0\n",
            "2\n",
            "24\n"
        ],
        "starter_code": "\ndef jMCvr():\n",
        "scope": [
            [
                "Function Body",
                2,
                20
            ],
            [
                "While Loop Body",
                5,
                6
            ],
            [
                "For Loop Body",
                8,
                16
            ],
            [
                "For Loop Body",
                11,
                13
            ],
            [
                "If Statement Body",
                14,
                16
            ],
            [
                "If Statement Body",
                17,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef PyJcx():\n    \"\"\"Your task is to calculate the number of arrays such that:  each array contains $n$ elements;  each element is an integer from $1$ to $m$;  for each array, there is exactly one pair of equal elements;  for each array $a$, there exists an index $i$ such that the array is strictly ascending before the $i$-th element and strictly descending after it (formally, it means that $a_j < a_{j + 1}$, if $j < i$, and $a_j > a_{j + 1}$, if $j \\ge i$). \n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n \\le m \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nPrint one integer — the number of arrays that meet all of the aforementioned conditions, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 4\n\nOutput\n6\n\nInput\n3 5\n\nOutput\n10\n\nInput\n42 1337\n\nOutput\n806066790\n\nInput\n100000 200000\n\nOutput\n707899035\n\n\n\n-----Note-----\n\nThe arrays in the first example are:  $[1, 2, 1]$;  $[1, 3, 1]$;  $[1, 4, 1]$;  $[2, 3, 2]$;  $[2, 4, 2]$;  $[3, 4, 3]$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef PyJcx():\n    input = sys.stdin.readline\n    n,m=list(map(int,input().split()))\n    mod=998244353\n    FACT=[1]\n    for i in range(1,2*10**5+1):\n        FACT.append(FACT[-1]*i%mod)\n    FACT_INV=[pow(FACT[-1],mod-2,mod)]\n    for i in range(2*10**5,0,-1):\n        FACT_INV.append(FACT_INV[-1]*i%mod)\n    FACT_INV.reverse()\n    def Combi(a,b):\n        if 0<=b<=a:\n            return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n        else:\n            return 0\n    if n==2:\n        print(0)\n    else:\n        print(Combi(m,n-1)*(n-2)*pow(2,n-3,mod)%mod)",
        "inputs": [
            "3 4\n",
            "3 5\n",
            "42 1337\n"
        ],
        "outputs": [
            "6\n",
            "10\n",
            "806066790\n"
        ],
        "starter_code": "\ndef PyJcx():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "Function Body",
                13,
                17
            ],
            [
                "If Statement Body",
                14,
                17
            ],
            [
                "If Statement Body",
                18,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fYwVI():\n    \"\"\"You are given a set of points $x_1$, $x_2$, ..., $x_n$ on the number line.\n\nTwo points $i$ and $j$ can be matched with each other if the following conditions hold:  neither $i$ nor $j$ is matched with any other point;  $|x_i - x_j| \\ge z$. \n\nWhat is the maximum number of pairs of points you can match with each other?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $z$ ($2 \\le n \\le 2 \\cdot 10^5$, $1 \\le z \\le 10^9$) — the number of points and the constraint on the distance between matched points, respectively.\n\nThe second line contains $n$ integers $x_1$, $x_2$, ..., $x_n$ ($1 \\le x_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint one integer — the maximum number of pairs of points you can match with each other.\n\n\n-----Examples-----\nInput\n4 2\n1 3 3 7\n\nOutput\n2\n\nInput\n5 5\n10 9 5 8 7\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, you may match point $1$ with point $2$ ($|3 - 1| \\ge 2$), and point $3$ with point $4$ ($|7 - 3| \\ge 2$).\n\nIn the second example, you may match point $1$ with point $3$ ($|5 - 10| \\ge 5$).\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef fYwVI():\n    n, z = list(map(int, sys.stdin.readline().strip().split()))\n    x = list(map(int, sys.stdin.readline().strip().split()))\n    x.sort()\n    i = 0\n    j = n // 2\n    c = 0\n    while j < n and i < n // 2:\n        if x[j] - x[i] >= z:\n            i = i + 1\n            j = j + 1\n            c = c + 1\n        else:\n            j = j + 1\n    print(c)",
        "inputs": [
            "4 2\n1 3 3 7\n",
            "5 5\n10 9 5 8 7\n",
            "3 2\n1 4 7\n"
        ],
        "outputs": [
            "2\n",
            "1\n",
            "1\n"
        ],
        "starter_code": "\ndef fYwVI():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "While Loop Body",
                9,
                15
            ],
            [
                "If Statement Body",
                10,
                15
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n            \"\"\"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:\n\nYou will pick any pizza slice.\nYour friend Alice will pick next slice in anti clockwise direction of your pick. \nYour friend Bob will pick next slice in clockwise direction of your pick.\nRepeat until there are no more slices of pizzas.\n\nSizes of Pizza slices is represented by circular array slices in clockwise direction.\nReturn the maximum possible sum of slice sizes which you can have.\n \nExample 1:\n\nInput: slices = [1,2,3,4,5,6]\nOutput: 10\nExplanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\nExample 2:\n\nInput: slices = [8,9,8,6,1,1]\nOutput: 16\nOutput: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\nExample 3:\nInput: slices = [4,1,2,5,8,3,1,9,7]\nOutput: 21\n\nExample 4:\nInput: slices = [3,1,2]\nOutput: 3\n\n \nConstraints:\n\n1 <= slices.length <= 500\nslices.length % 3 == 0\n1 <= slices[i] <= 1000\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        a,b,n=[slices[0]],[0],len(slices)\n        for i in range(1,n):\n            a.append(max(a[-1],slices[i]))\n            b.append(max(b[-1],slices[i]))\n        for i in range(2,2*n//3,2):\n            aa,bb=[0]*(n-1),[0]*n\n            for j in range(i,n-1): aa[j]=max(aa[j-1],a[j-2]+slices[j])\n            for j in range(i+1,n): bb[j]=max(bb[j-1],b[j-2]+slices[j])\n            a,b=aa,bb\n        return max(a[-1],b[-1])",
        "inputs": [
            [
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6
                ]
            ]
        ],
        "outputs": [
            [
                10
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                12
            ],
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                4,
                6
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "For Loop Body",
                9,
                9
            ],
            [
                "For Loop Body",
                10,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef hofwq():\n    \"\"\"A new set of desks just arrived, and it's about time! Things were getting quite cramped in the office. You've been put in charge of creating a new seating chart for the engineers. The desks are numbered, and you sent out a survey to the engineering team asking each engineer the number of the desk they currently sit at, and the number of the desk they would like to sit at (which may be the same as their current desk). Each engineer must either remain where they sit, or move to the desired seat they indicated in the survey. No two engineers currently sit at the same desk, nor may any two engineers sit at the same desk in the new seating arrangement.\n\nHow many seating arrangements can you create that meet the specified requirements? The answer may be very large, so compute it modulo 1000000007 = 10^9 + 7.\n\n\n-----Input-----\n\nInput will begin with a line containing N (1 ≤ N ≤ 100000), the number of engineers. \n\nN lines follow, each containing exactly two integers. The i-th line contains the number of the current desk of the i-th engineer and the number of the desk the i-th engineer wants to move to. Desks are numbered from 1 to 2·N. It is guaranteed that no two engineers sit at the same desk.\n\n\n-----Output-----\n\nPrint the number of possible assignments, modulo 1000000007 = 10^9 + 7.\n\n\n-----Examples-----\nInput\n4\n1 5\n5 2\n3 7\n7 3\n\nOutput\n6\n\nInput\n5\n1 10\n2 10\n3 10\n4 10\n5 5\n\nOutput\n5\n\n\n\n-----Note-----\n\nThese are the possible assignments for the first example:   1 5 3 7  1 2 3 7  5 2 3 7  1 5 7 3  1 2 7 3  5 2 7 3\n    \"\"\"\n",
        "canonical_solution": "\ndef hofwq():\n    n = int(input())\n    m = 2 * n + 1\n    u = [[] for i in range(m)]\n    v = [0] * m\n    s = [0] * m\n    d = 10 ** 9 + 7\n    y = 1\n    \n    for j in range(n):\n        a, b = map(int, input().split())\n        v[a] = b\n        if a != b:\n            s[b] += 1\n            u[b].append(a)\n    \n    for b in range(m):\n        if not v[b]:\n            x = 0\n            p = [b]\n            while p:\n                x += 1\n                a = p.pop()\n                s[a] = -1\n                p += u[a]\n            y = (x * y) % d\n    \n    for a in range(m):\n        if s[a] == 0:\n            b = v[a]\n            while s[b] == 1:\n                s[b] = -1\n                b = v[b]\n            s[b] -= 1\n    \n    for a in range(m):\n        if s[a] == 1:\n            y = (2 * y) % d\n            while s[a]:\n                s[a] = 0\n                a = v[a]\n    \n    print(y)",
        "inputs": [
            "4\n1 5\n5 2\n3 7\n7 3\n",
            "5\n1 10\n2 10\n3 10\n4 10\n5 5\n",
            "1\n1 2\n"
        ],
        "outputs": [
            "6\n",
            "5\n",
            "2\n"
        ],
        "starter_code": "\ndef hofwq():\n",
        "scope": [
            [
                "Function Body",
                2,
                44
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                11,
                16
            ],
            [
                "If Statement Body",
                14,
                16
            ],
            [
                "For Loop Body",
                18,
                27
            ],
            [
                "If Statement Body",
                19,
                27
            ],
            [
                "While Loop Body",
                22,
                26
            ],
            [
                "For Loop Body",
                29,
                35
            ],
            [
                "If Statement Body",
                30,
                35
            ],
            [
                "While Loop Body",
                32,
                34
            ],
            [
                "For Loop Body",
                37,
                42
            ],
            [
                "If Statement Body",
                38,
                42
            ],
            [
                "While Loop Body",
                40,
                42
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef flXVi():\n    \"\"\"After playing Neo in the legendary \"Matrix\" trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem.\n\nLet's call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good.\n\nWe are given a string $s$ of length $n$ consisting of only zeroes and ones. We need to cut $s$ into minimal possible number of substrings $s_1, s_2, \\ldots, s_k$ such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings $s_1, s_2, \\ldots, s_k$ such that their concatenation (joining) equals $s$, i.e. $s_1 + s_2 + \\dots + s_k = s$.\n\nFor example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can't cut 110010 to the smaller number of substrings as 110010 isn't good itself. At the same time, cutting of 110010 into 1100 and 10 isn't valid as both strings aren't good. Also, cutting of 110010 into 1, 1, 0010 isn't valid, as it isn't minimal, even though all $3$ strings are good.\n\nCan you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer $n$ ($1\\le n \\le 100$) — the length of the string $s$.\n\nThe second line contains the string $s$ of length $n$ consisting only from zeros and ones.\n\n\n-----Output-----\n\nIn the first line, output a single integer $k$ ($1\\le k$) — a minimal number of strings you have cut $s$ into.\n\nIn the second line, output $k$ strings $s_1, s_2, \\ldots, s_k$ separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to $s$ and all of them have to be good.\n\nIf there are multiple answers, print any.\n\n\n-----Examples-----\nInput\n1\n1\n\nOutput\n1\n1\nInput\n2\n10\n\nOutput\n2\n1 0\nInput\n6\n100011\n\nOutput\n2\n100 011\n\n\n\n-----Note-----\n\nIn the first example, the string 1 wasn't cut at all. As it is good, the condition is satisfied.\n\nIn the second example, 1 and 0 both are good. As 10 isn't good, the answer is indeed minimal.\n\nIn the third example, 100 and 011 both are good. As 100011 isn't good, the answer is indeed minimal.\n    \"\"\"\n",
        "canonical_solution": "\ndef flXVi():\n    n = int(input())\n    s = input().strip()\n    if s.count('0') != s.count('1'):\n      print(1)\n      print(s)\n    else:\n      print(2)\n      print(s[:-1], s[-1])",
        "inputs": [
            "1\n1\n",
            "2\n10\n",
            "6\n100011\n"
        ],
        "outputs": [
            "1\n1",
            "2\n1 0",
            "2\n10001 1"
        ],
        "starter_code": "\ndef flXVi():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "If Statement Body",
                5,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gfZSQ():\n    \"\"\"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.\n\nMeanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.\n\nIf there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.\n\nGiven the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.\n\n\n-----Input-----\n\nThe first line of input will contain an integer n (1 ≤ n ≤ 10^5), the number of events. The next line will contain n space-separated integers.\n\nIf the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.\n\n\n-----Output-----\n\nPrint a single integer, the number of crimes which will go untreated.\n\n\n-----Examples-----\nInput\n3\n-1 -1 1\n\nOutput\n2\n\nInput\n8\n1 -1 1 -1 -1 1 1 1\n\nOutput\n1\n\nInput\n11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n\nOutput\n8\n\n\n\n-----Note-----\n\nLets consider the second example:  Firstly one person is hired.  Then crime appears, the last hired person will investigate this crime.  One more person is hired.  One more crime appears, the last hired person will investigate this crime.  Crime appears. There is no free policeman at the time, so this crime will go untreated.  One more person is hired.  One more person is hired.  One more person is hired. \n\nThe answer is one, as one crime (on step 5) will go untreated.\n    \"\"\"\n",
        "canonical_solution": "\ndef gfZSQ():\n    \"\"\"\n    Codeforces Round 244 Div 1 Problem A\n    \n    Author  : chaotic_iak\n    Language: Python 3.3.4\n    \"\"\"\n    \n    class InputHandlerObject(object):\n        inputs = []\n    \n        def getInput(self, n = 0):\n            res = \"\"\n            inputs = self.inputs\n            if not inputs: inputs.extend(input().split(\" \"))\n            if n == 0:\n                res = inputs[:]\n                inputs[:] = []\n            while n > len(inputs):\n                inputs.extend(input().split(\" \"))\n            if n > 0:\n                res = inputs[:n]\n                inputs[:n] = []\n            return res\n    InputHandler = InputHandlerObject()\n    g = InputHandler.getInput\n    \n    ############################## SOLUTION ##############################\n    n = int(input())\n    a = [int(x) for x in g()]\n    ct = 0\n    res = 0\n    for i in a:\n        ct += i\n        if ct < 0:\n            res += 1\n            ct = 0\n    print(res)",
        "inputs": [
            "3\n-1 -1 1\n",
            "8\n1 -1 1 -1 -1 1 1 1\n",
            "11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n"
        ],
        "outputs": [
            "2\n",
            "1\n",
            "8\n"
        ],
        "starter_code": "\ndef gfZSQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                39
            ],
            [
                "Class Body",
                10,
                25
            ],
            [
                "Function Body",
                13,
                25
            ],
            [
                "If Statement Body",
                16,
                16
            ],
            [
                "If Statement Body",
                17,
                19
            ],
            [
                "While Loop Body",
                20,
                21
            ],
            [
                "If Statement Body",
                22,
                24
            ],
            [
                "List Comprehension",
                31,
                31
            ],
            [
                "For Loop Body",
                34,
                38
            ],
            [
                "If Statement Body",
                36,
                38
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Uqkep():\n    \"\"\"Vus the Cossack holds a programming competition, in which $n$ people participate. He decided to award them all with pens and notebooks. It is known that Vus has exactly $m$ pens and $k$ notebooks.\n\nDetermine whether the Cossack can reward all participants, giving each of them at least one pen and at least one notebook.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, and $k$ ($1 \\leq n, m, k \\leq 100$) — the number of participants, the number of pens, and the number of notebooks respectively.\n\n\n-----Output-----\n\nPrint \"Yes\" if it possible to reward all the participants. Otherwise, print \"No\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5 8 6\n\nOutput\nYes\n\nInput\n3 9 3\n\nOutput\nYes\n\nInput\n8 5 20\n\nOutput\nNo\n\n\n\n-----Note-----\n\nIn the first example, there are $5$ participants. The Cossack has $8$ pens and $6$ notebooks. Therefore, he has enough pens and notebooks.\n\nIn the second example, there are $3$ participants. The Cossack has $9$ pens and $3$ notebooks. He has more than enough pens but only the minimum needed number of notebooks.\n\nIn the third example, there are $8$ participants but only $5$ pens. Since the Cossack does not have enough pens, the answer is \"No\".\n    \"\"\"\n",
        "canonical_solution": "\ndef Uqkep():\n    n, m, k = list(map(int, input().split()))\n    if m >= n and k >= n:\n        print('Yes')\n    else:\n        print('No')\n    ",
        "inputs": [
            "5 8 6\n",
            "3 9 3\n",
            "8 5 20\n"
        ],
        "outputs": [
            "Yes\n",
            "Yes\n",
            "No\n"
        ],
        "starter_code": "\ndef Uqkep():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "If Statement Body",
                4,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n            \"\"\"Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n\n\nFormally the function should:\nReturn true if there exists i, j, k  \nsuch that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 \nelse return false.\n\n\n\nYour algorithm should run in O(n) time complexity and O(1) space complexity.\n\n\nExamples:\nGiven [1, 2, 3, 4, 5],\nreturn true.\n\n\nGiven [5, 4, 3, 2, 1],\nreturn false.\n\n\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def increasingTriplet(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: bool\n         \"\"\"\n         n1 = n2 = float('inf')\n         for n in nums:\n             if n <= n1:\n                 n1 = n\n             elif n <= n2:\n                 n2 = n\n             else:\n                 return True\n         return False",
        "inputs": [
            [
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            ]
        ],
        "outputs": [
            [
                true
            ]
        ],
        "starter_code": "\nclass Solution:\n    def increasingTriplet(self, nums: List[int]) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                15
            ],
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                8,
                14
            ],
            [
                "If Statement Body",
                9,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FRIbQ():\n    \"\"\"Tuzik and Vanya are playing the following game.\nThey have an N × M board and a chip to indicate the current game position. The chip can be placed on any one cell of the game board, each of which is uniquely identified by an ordered pair of positive integers (r, c), where 1 ≤ r ≤ N is the row number and 1 ≤ c ≤ M is the column number.\nInitially, the chip is placed at the cell identified as (1, 1). For his move, a player can move it either 1, 2 or 3 cells up, or 1 or 2 cells to the right. The player who can not move the chip loses. In other words, a player suffers defeat if the chip is placed in the cell (N, M) at the start of his turn.\nTuzik starts the game. You have to determine who will win the game if both players play optimally.\n\n-----Input-----\nThe first line contains an integer T denoting the number of tests. Each of the following T lines contain two integers N and M.\n\n-----Output-----\nFor each test output \"Tuzik\" or \"Vanya\" on a separate line, indicating who will win the game.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M ≤ 106\n\n-----Example-----\nInput:\n2\n4 4\n2 2\n\nOutput:\nTuzik\nVanya\n\n\n-----Explanation-----Test case 1: On his first turn Tuzik moves chip 3 cells up to the cell (4, 1). On his turn Vanya can move chip only right to the cell (4, 2) or to the cell (4, 3) and after that Tuzik moves it to (4, 4) and finishes the game.\n\nTest case 2: On his first Turn Tuzik can move chip to the cell (2, 1) or (1, 2), but on his next turn Vanya moves it to (2, 2) and wins the game.\n    \"\"\"\n",
        "canonical_solution": "\ndef FRIbQ():\n    cases = int(input())\n    for _ in range(cases):\n     rows, cols = map(int, input().split())\n     if (cols - 1) % 3 == 0 and (rows - 1) % 4 == 0: print('Vanya')\n     elif (cols - 1) % 3 != 0 and (rows - 1) % 4 == 0: print('Tuzik')\n     elif (cols - 1) % 3 == 0 and (rows - 1) % 4 != 0: print('Tuzik')\n     else:\n      if (cols - 1) % 3 == 1 and (rows - 1) % 4 == 1: print('Vanya')\n      elif (cols - 1) % 3 == 2 and (rows - 1) % 4 == 2: print('Vanya')\n      else: print('Tuzik')",
        "inputs": [
            "2\n4 4\n2 2\n"
        ],
        "outputs": [
            "Tuzik\nVanya\n"
        ],
        "starter_code": "\ndef FRIbQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                4,
                12
            ],
            [
                "If Statement Body",
                6,
                12
            ],
            [
                "If Statement Body",
                7,
                12
            ],
            [
                "If Statement Body",
                8,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                11,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef NyZpC():\n    \"\"\"Amr loves Chemistry, and specially doing experiments. He is preparing for a new interesting experiment.\n\nAmr has n different types of chemicals. Each chemical i has an initial volume of a_{i} liters. For this experiment, Amr has to mix all the chemicals together, but all the chemicals volumes must be equal first. So his task is to make all the chemicals volumes equal.\n\nTo do this, Amr can do two different kind of operations.   Choose some chemical i and double its current volume so the new volume will be 2a_{i}  Choose some chemical i and divide its volume by two (integer division) so the new volume will be $\\lfloor \\frac{a_{i}}{2} \\rfloor$ \n\nSuppose that each chemical is contained in a vessel of infinite volume. Now Amr wonders what is the minimum number of operations required to make all the chemicals volumes equal?\n\n\n-----Input-----\n\nThe first line contains one number n (1 ≤ n ≤ 10^5), the number of chemicals.\n\nThe second line contains n space separated integers a_{i} (1 ≤ a_{i} ≤ 10^5), representing the initial volume of the i-th chemical in liters.\n\n\n-----Output-----\n\nOutput one integer the minimum number of operations required to make all the chemicals volumes equal.\n\n\n-----Examples-----\nInput\n3\n4 8 2\n\nOutput\n2\nInput\n3\n3 5 6\n\nOutput\n5\n\n\n-----Note-----\n\nIn the first sample test, the optimal solution is to divide the second chemical volume by two, and multiply the third chemical volume by two to make all the volumes equal 4.\n\nIn the second sample test, the optimal solution is to divide the first chemical volume by two, and divide the second and the third chemical volumes by two twice to make all the volumes equal 1.\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\ndef NyZpC():\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    n = int(input())\n    A = list(map(int,input().split()))\n    pattern = set()\n    for a in A:\n        p = []\n        while a > 0:\n            if a in pattern:\n                break\n            p.append(a)\n            a = a//2\n        pattern |= set(p)\n    def check(v):\n        ret = 0\n        for a in A:\n            count = 0\n            while a != 0:\n                if v == a or (v % a == 0 and (v//a)&-(v//a) == v//a):\n                    ret += len(bin(v//a))-3\n                    break\n                if (v%a == 0 and (v//a)&-(v//a) == v//a) and a < v:\n                    return 1e12\n                a = a//2\n                ret += 1\n            else:\n                return 1e12\n        return ret\n    ans = 1e12\n    for p in pattern:\n        ret = check(p)\n        ans = ans if ans < ret else ret\n    print(ans)",
        "inputs": [
            "3\n4 8 2\n",
            "3\n3 5 6\n",
            "2\n50000 100000\n"
        ],
        "outputs": [
            "2",
            "5",
            "1"
        ],
        "starter_code": "\ndef NyZpC():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "For Loop Body",
                8,
                15
            ],
            [
                "While Loop Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "Function Body",
                16,
                30
            ],
            [
                "For Loop Body",
                18,
                29
            ],
            [
                "While Loop Body",
                20,
                29
            ],
            [
                "If Statement Body",
                21,
                23
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "For Loop Body",
                32,
                34
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef duZYp():\n    \"\"\"You are given array a with n elements and the number m. Consider some subsequence of a and the value of least common multiple (LCM) of its elements. Denote LCM as l. Find any longest subsequence of a with the value l ≤ m.\n\nA subsequence of a is an array we can get by erasing some elements of a. It is allowed to erase zero or all elements.\n\nThe LCM of an empty array equals 1.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 10^6) — the size of the array a and the parameter from the problem statement.\n\nThe second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the elements of a.\n\n\n-----Output-----\n\nIn the first line print two integers l and k_{max} (1 ≤ l ≤ m, 0 ≤ k_{max} ≤ n) — the value of LCM and the number of elements in optimal subsequence.\n\nIn the second line print k_{max} integers — the positions of the elements from the optimal subsequence in the ascending order.\n\nNote that you can find and print any subsequence with the maximum length.\n\n\n-----Examples-----\nInput\n7 8\n6 2 9 2 7 2 3\n\nOutput\n6 5\n1 2 4 6 7\n\nInput\n6 4\n2 2 2 3 3 3\n\nOutput\n2 3\n1 2 3\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef duZYp():\n    n, m = [int(x) for x in input().split()]\n    A = [int(x) for x in input().split()]\n    B, C = [0]*(m+1), [0]*(m+1)\n    for a in A:\n        if a <= m: B[a] += 1\n    for i in range(2, m + 1):\n        for j in range(i, m+1, i):\n            C[j] += B[i]\n    k, l = 1, 0\n    for i in range(2, m+1):\n        if C[i] > l:\n            l = C[i]\n            k = i\n    print(k, l + B[1])\n    for i, a in enumerate(A):\n        if k%a == 0: sys.stdout.write(str(i+1) + ' ')",
        "inputs": [
            "7 8\n6 2 9 2 7 2 3\n",
            "6 4\n2 2 2 3 3 3\n",
            "10 50\n39 22 60 88 11 65 41 85 65 100\n"
        ],
        "outputs": [
            "6 5\n1 2 4 6 7\n",
            "2 3\n1 2 3\n",
            "22 2\n2 5\n"
        ],
        "starter_code": "\ndef duZYp():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "List Comprehension",
                3,
                3
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "If Statement Body",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "For Loop Body",
                9,
                10
            ],
            [
                "For Loop Body",
                12,
                15
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "For Loop Body",
                17,
                18
            ],
            [
                "If Statement Body",
                18,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n            \"\"\"Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\n \nExample 1:\nInput: nums = [1,1,2,1,1], k = 3\nOutput: 2\nExplanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\n\nExample 2:\nInput: nums = [2,4,6], k = 1\nOutput: 0\nExplanation: There is no odd numbers in the array.\n\nExample 3:\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\nOutput: 16\n\n \nConstraints:\n\n1 <= nums.length <= 50000\n1 <= nums[i] <= 10^5\n1 <= k <= nums.length\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # save all even subarray's length which between odds\n        edge = []\n        res = 0\n        count = 0\n        for i in nums:\n            # odd\n            if i % 2:\n                # +1 because range from 0 to count when doing combination\n                edge.append(count+1)\n                count = 0\n            # even\n            else:\n                count += 1\n        edge.append(count+1)\n        # no enough odd\n        if len(edge)-1 < k:\n            return 0\n        else:\n            # combination\n            for i in range(len(edge)-k):\n                res += edge[i] * edge[i+k]\n            return res",
        "inputs": [
            [
                [
                    1,
                    1,
                    2,
                    1,
                    1
                ],
                3
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                24
            ],
            [
                "Function Body",
                2,
                24
            ],
            [
                "For Loop Body",
                7,
                15
            ],
            [
                "If Statement Body",
                9,
                15
            ],
            [
                "If Statement Body",
                18,
                24
            ],
            [
                "For Loop Body",
                22,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef QuMxU():\n    \"\"\"Polycarp's workday lasts exactly $n$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $k$ bars at the beginning of the workday.\n\nIn some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $k$ is strictly greater than $1$.\n\nYour task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.\n\nConsider that Polycarp eats a bar in the minute $x$ and the next bar in the minute $y$ ($x < y$). Then the break time is equal to $y - x - 1$ minutes. It is not necessary for Polycarp to eat all bars he has.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($2 \\le n \\le 200\\,000$, $2 \\le k \\le n$) — the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday.\n\nThe second line contains the string with length $n$ consisting of zeros and ones. If the $i$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $i$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $i$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.\n\n\n-----Output-----\n\nPrint the minimum possible break in minutes between eating chocolate bars.\n\n\n-----Examples-----\nInput\n3 3\n010\n\nOutput\n1\n\nInput\n8 3\n01010110\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.\n\nIn the second example Polycarp will eat bars in the minutes $1$ and $8$ anyway, also he needs to eat the chocolate bar in the minute $5$, so that the time of the maximum break will be equal to $3$ minutes.\n    \"\"\"\n",
        "canonical_solution": "\ndef QuMxU():\n    n, k = map(int, input().split())\n    s = input()\n    l, r = int(-1), int(n)\n    \n    while r - l > 1:\n        m = (l+r)//2\n        c, p = 1, 0\n        cond = True\n        while p < n and c < k:\n            i = p + m + 1\n            while i >= p and (i >= n or s[i] == '1'):\n                i = i - 1;\n            if (i == p):\n                break\n            c = c + 1\n            p = i\n        cond = cond and (p == n-1)\n        if cond:\n            r = m\n        else:\n            l = m\n    print(int(r))",
        "inputs": [
            "3 3\n010\n",
            "8 3\n01010110\n",
            "9 5\n001100110\n"
        ],
        "outputs": [
            "1\n",
            "3\n",
            "2\n"
        ],
        "starter_code": "\ndef QuMxU():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "While Loop Body",
                7,
                23
            ],
            [
                "While Loop Body",
                11,
                18
            ],
            [
                "While Loop Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                20,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef EUStA():\n    \"\"\"Chilly Willy loves playing with numbers. He only knows prime numbers that are digits yet. These numbers are 2, 3, 5 and 7. But Willy grew rather bored of such numbers, so he came up with a few games that were connected with them.\n\nChilly Willy wants to find the minimum number of length n, such that it is simultaneously divisible by all numbers Willy already knows (2, 3, 5 and 7). Help him with that.\n\nA number's length is the number of digits in its decimal representation without leading zeros.\n\n\n-----Input-----\n\nA single input line contains a single integer n (1 ≤ n ≤ 10^5).\n\n\n-----Output-----\n\nPrint a single integer — the answer to the problem without leading zeroes, or \"-1\" (without the quotes), if the number that meet the problem condition does not exist.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n-1\n\nInput\n5\n\nOutput\n10080\n    \"\"\"\n",
        "canonical_solution": "import re\nimport itertools\nfrom collections import Counter\ndef EUStA():\n    class Task:\n        n = 0\n        answer = \"\"\n    \t\n        def getData(self):\n            self.n = int(input())\n    \t\n        def solve(self):\n            n = self.n\n            if n < 3:\n                self.answer = \"-1\"\n                return\n            if n == 3:\n                self.answer = \"210\"\n                return\n            tenRemainders = [1, 3, 2, 6, 4, 5]\n            for x in range(0, 100):\n                if (tenRemainders[(n - 1) % 6] + x * 10) % 7 == 0 and \\\n                        (1 + x // 10 + x % 10) % 3 == 0:\n                    self.answer = '1' + '0' * (n - 4)\n                    self.answer += '0' + str(x) if (x < 10) else str(x)\n                    self.answer += '0'\n                    return\n        def printAnswer(self):\n            print(self.answer)\n    task = Task();\n    task.getData();\n    task.solve();\n    task.printAnswer();",
        "inputs": [
            "1\n",
            "5\n",
            "6\n"
        ],
        "outputs": [
            "-1\n",
            "10080",
            "100170"
        ],
        "starter_code": "\ndef EUStA():\n",
        "scope": [
            [
                "Function Body",
                4,
                33
            ],
            [
                "Class Body",
                5,
                29
            ],
            [
                "Function Body",
                9,
                10
            ],
            [
                "Function Body",
                12,
                27
            ],
            [
                "If Statement Body",
                14,
                16
            ],
            [
                "If Statement Body",
                17,
                19
            ],
            [
                "For Loop Body",
                21,
                27
            ],
            [
                "If Statement Body",
                22,
                27
            ],
            [
                "Function Body",
                28,
                29
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def countVowelPermutation(self, n: int) -> int:\n            \"\"\"Given an integer n, your task is to count how many strings of length n can be formed under the following rules:\n\nEach character is a lower case vowel ('a', 'e', 'i', 'o', 'u')\nEach vowel 'a' may only be followed by an 'e'.\nEach vowel 'e' may only be followed by an 'a' or an 'i'.\nEach vowel 'i' may not be followed by another 'i'.\nEach vowel 'o' may only be followed by an 'i' or a 'u'.\nEach vowel 'u' may only be followed by an 'a'.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n \nExample 1:\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n\nExample 2:\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n\nExample 3: \nInput: n = 5\nOutput: 68\n \nConstraints:\n\n1 <= n <= 2 * 10^4\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def countVowelPermutation(self, n: int) -> int:\n        a = 1\n        e = 1\n        i = 1\n        o = 1\n        u = 1\n        res = 0\n        M = 1e9+7\n\n        for x in range(n-1):\n            a1 = e\n            e1 = (a + i) % M\n            i1 = (a + e + u + o) % M\n            o1 = (i + u) % M\n            u1 = a\n            a = a1\n            e = e1\n            i = i1\n            o = o1\n            u = u1\n        \n        res = int((a+e+i+o+u) % M)\n        return res",
        "inputs": [
            [
                1
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def countVowelPermutation(self, n: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                24
            ],
            [
                "Function Body",
                2,
                24
            ],
            [
                "For Loop Body",
                11,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GobWt():\n    \"\"\"Chef loves squares! You are given N points with integers coordinates, Chef asks you to find out how many points he should add to these set of N points, so that one could create at least one square having its vertices from the points of the resulting set. Note that the square created need not to be parallel to the axis.\n\n-----Input-----\nThe first line contains singe integer N. \nEach of next N lines contains two integers Xi and Yi denotine the coordinates of i-th point. \n\n-----Output-----\nIn a single line print single integer - the minimal number of points Chef need to paint to receive at least one square. \n\n-----Constraints-----\n- 0 ≤ N ≤ 2000\n- -10^6 ≤ Xi, Yi ≤ 10^6\n- There are NO coincided points\n\n-----Example-----\nInput:\n3\n0 0\n2 2\n3 3\n\nOutput:\n2\n\nInput:\n5\n0 0\n100 100\n200 200\n100 0\n0 100\n\nOutput:\n0\n\n-----Explanation-----\nFor the first example Chef can add points (2, 0), (0, 2) or (2, 3), (3, 2)\nFor the second example Chef already has square (0, 0), (100, 0), (0, 100), (100, 100).\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport math\ndef GobWt():\n    def main(arr):\n     ans=2\n     if len(arr)<2:\n      return 4-len(arr)\n     set_arr=set(arr)\n     for i in range(len(arr)):\n      for j in range(i+1,len(arr)):\n       need=2\n       x1,y1=arr[i]\n       x2,y2=arr[j]\n       xc = (x1 + x2)/2  ;  yc = (y1 + y2)/2  ;    \n       xd = (x1 - x2)/2  ;  yd = (y1 - y2)/2  ;    \n       x3 = xc - yd  ;  y3 = yc + xd;    \n       x4 = xc + yd  ;  y4 = yc - xd;    \n       if (x3,y3) in set_arr:\n        need-=1 \n       if (x4,y4) in set_arr:\n        need-=1\n       ans=min(ans,need)\n     return ans\n    arr=[]\n    for i in range(int(input())):\n     arr.append(tuple(map(int,input().split())))\n    print(main(arr))\n     \n     \n        ",
        "inputs": [
            "3\n0 0\n2 2\n3 3\n",
            "5\n0 0\n100 100\n200 200\n100 0\n0 100\n"
        ],
        "outputs": [
            "2\n",
            "0\n"
        ],
        "starter_code": "\ndef GobWt():\n",
        "scope": [
            [
                "Function Body",
                3,
                27
            ],
            [
                "Function Body",
                4,
                23
            ],
            [
                "If Statement Body",
                6,
                7
            ],
            [
                "For Loop Body",
                9,
                22
            ],
            [
                "For Loop Body",
                10,
                22
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "For Loop Body",
                25,
                26
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wFKIy():\n    \"\"\"In poker, you have 5 cards. There are 10 kinds of poker hands (from highest to lowest):\n\n-  royal flush - ace, king, queen, jack and ten, all in the same suit\n\n-  straight flush - five cards of the same suit in sequence, such\nas 10,9,8,7,6 of clubs; ace can be counted both as the highest card or as the\nlowest card - A,2,3,4,5 of hearts is a straight flush. But 4,3,2,A,K of hearts is not a straight flush - it's just a flush.\n\n-  four of a kind - four cards of the same rank, such as four kings.\n\n-  full house - three cards of one rank plus two cards of another rank\n\n-  flush - five cards of the same suit (but not a straight flush)\n\n-  straight - five cards in order - just like the straight flush, but mixed suits\n\n-  three of a kind - three cards of one rank and two other cards\n\n-  two pairs - two cards of one rank, two cards of another rank, and one more card\n\n-  pair - two cards of the same rank\n\n-  high card - none of the above\n\nWrite a program that will help you play poker by telling you what kind of hand you have.\n\n-----Input-----\n\nThe first line of input contains the number of test cases (no more than 20). Each test case consists of one line - five space separated cards. Each card is represented by a two-letter (or digit) word. The first character is the rank (A,K,Q,J,T,9,8,7,6,5,4,3 or 2), the second character is the suit (S,H,D,C standing for spades, hearts, diamonds and clubs). The cards can be in any order (but they will not repeat).\n\n-----Output-----\n\nFor each test case output one line describing the type of a hand, exactly like in the list above.\n\n-----Example-----\nInput:\n3\nAH KH QH TH JH\nKH 5S 3C 5C 7D\nQH QD 2S QC 2C\n\nOutput:\nroyal flush\npair\nfull house\n    \"\"\"\n",
        "canonical_solution": "\ndef wFKIy():\n    cards = ['A','2','3','4','5','6','7','8','9','T','J','Q','K']\n    \n    def royal_flush(arr):\n     nonlocal ans, confirm\n     rf_set = 'TJQKA'\n     rf = 1\n     for char in arr:\n      if char[0] not in rf_set:\n       rf = 0\n       break\n     if rf :\n      if len(set(suit)) == 1:\n       ans = 'royal flush'\n       confirm = 1\n    def straight_flush(arr):  # and 'straight'\n     nonlocal ans,confirm\n     sf = 1\n     for i in range(1,5):\n      if arr[i] - arr[i-1] != 1:\n       sf = 0\n       break\n     if sf:\n      if len(set(suit)) == 1 :\n       ans = 'straight flush'\n       confirm = 1\n      else:\n       ans = 'straight'\n       confirm = 1\n    def four(arr):\n     nonlocal ans, confirm\n     f = 0\n     for char in arr:\n      if arr.count(char) == 4:\n       f = 1\n       break\n     if f:\n      confirm = 1\n      ans = 'four of a kind'\n    def full_house(arr): # and three\n     nonlocal ans, confirm\n     fh = 0\n     three = 0\n     two = 0\n     for char in arr:\n      if arr.count(char) == 3:\n       three = 1\n      elif arr.count(char) == 2:\n       two = 1\n     if three and two:\n      confirm = 1\n      ans = 'full house'\n     elif three:\n      confirm = 1\n      ans = 'three of a kind'\n    def two_pairs(arr):\n     nonlocal ans, confirm\n     temp = []\n     for char in arr:\n      if arr.count(char) == 2:\n       if char not in temp:\n        temp.append(char)\n     if len(temp) == 2:\n      confirm = 1\n      ans = 'two pairs'\n     elif len(temp) == 1:\n      confirm = 1\n      ans = 'pair'\n    \n    def idex(char_x):\n     return cards.index(char_x)\n    for _ in range(int(input())):\n     onhand = list(input().split())\n     cards_set = [[],[]]\n     suit = []\n     confirm = 0\n     ans = ''\n     for c in onhand:\n      num = idex(c[0])\n      cards_set[0].append(num)\n      if num == 0:\n       cards_set[1].append(13)\n      else:\n       cards_set[1].append(num)\n      suit.append(c[1])\n     royal_flush(onhand)\n     if not confirm:\n      cards_set[0] = sorted(cards_set[0])\n      cards_set[1] = sorted(cards_set[1])\n      straight_flush(cards_set[0])\n      straight_flush(cards_set[1])\n     if not confirm:\n      four(cards_set[0])\n      four(cards_set[1])\n     if not confirm:\n      full_house(cards_set[0])\n      full_house(cards_set[1])\n     if not confirm:\n      if len(set(suit)) == 1:\n       confirm = 1\n       ans = 'flush'\n     if not confirm:\n      two_pairs(cards_set[0])\n      two_pairs(cards_set[1])\n     print(ans if confirm else 'high card')",
        "inputs": [
            "3\nAH KH QH TH JH\nKH 5S 3C 5C 7D\nQH QD 2S QC 2C\n"
        ],
        "outputs": [
            "royal flush\npair\nfull house\n"
        ],
        "starter_code": "\ndef wFKIy():\n",
        "scope": [
            [
                "Function Body",
                2,
                106
            ],
            [
                "Function Body",
                5,
                16
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                13,
                16
            ],
            [
                "If Statement Body",
                14,
                16
            ],
            [
                "Function Body",
                17,
                30
            ],
            [
                "For Loop Body",
                20,
                23
            ],
            [
                "If Statement Body",
                21,
                23
            ],
            [
                "If Statement Body",
                24,
                30
            ],
            [
                "If Statement Body",
                25,
                30
            ],
            [
                "Function Body",
                31,
                40
            ],
            [
                "For Loop Body",
                34,
                37
            ],
            [
                "If Statement Body",
                35,
                37
            ],
            [
                "If Statement Body",
                38,
                40
            ],
            [
                "Function Body",
                41,
                56
            ],
            [
                "For Loop Body",
                46,
                50
            ],
            [
                "If Statement Body",
                47,
                50
            ],
            [
                "If Statement Body",
                49,
                50
            ],
            [
                "If Statement Body",
                51,
                56
            ],
            [
                "If Statement Body",
                54,
                56
            ],
            [
                "Function Body",
                57,
                69
            ],
            [
                "For Loop Body",
                60,
                63
            ],
            [
                "If Statement Body",
                61,
                63
            ],
            [
                "If Statement Body",
                62,
                63
            ],
            [
                "If Statement Body",
                64,
                69
            ],
            [
                "If Statement Body",
                67,
                69
            ],
            [
                "Function Body",
                71,
                72
            ],
            [
                "For Loop Body",
                73,
                106
            ],
            [
                "For Loop Body",
                79,
                86
            ],
            [
                "If Statement Body",
                82,
                85
            ],
            [
                "If Statement Body",
                88,
                92
            ],
            [
                "If Statement Body",
                93,
                95
            ],
            [
                "If Statement Body",
                96,
                98
            ],
            [
                "If Statement Body",
                99,
                102
            ],
            [
                "If Statement Body",
                100,
                102
            ],
            [
                "If Statement Body",
                103,
                105
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef kbVxM():\n    \"\"\"The Little Elephant from the Zoo of Lviv currently is on the military mission. There are N enemy buildings placed in a row and numbered from left to right strating from 0. Each building i (except the first and the last) has exactly two adjacent buildings with indices i-1 and i+1. The first and the last buildings have just a single adjacent building.\n\nSome of the buildings contain bombs. When bomb explodes in some building it destroys it and all adjacent to it buildings.\n\nYou are given the string S of length N, where Si is 1 if the i-th building contains bomb, 0 otherwise. Find for the Little Elephant the number of buildings that will not be destroyed after all bombs explode. Please note that all bombs explode simultaneously.\n\n-----Input-----\nThe first line contains single integer T - the number of test cases. T test cases follow. The first line of each test case contains the single integer N - the number of buildings. The next line contains the string S of length N consisted only of digits 0 and 1.\n\n-----Output-----\nIn T lines print T inetgers - the answers for the corresponding test cases.\n\n-----Constraints-----\n\n1 <= T <= 100\n\n1 <= N <= 1000\n\n-----Example-----\nInput:\n3\n3\n010\n5\n10001\n7\n0000000\n\nOutput:\n0\n1\n7\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef kbVxM():\n    T = int(sys.stdin.readline().strip())\n    for t in range(T):\n     sys.stdin.readline().strip()\n     st = '0'+sys.stdin.readline().strip()+'0'\n     res = 0\n     for i in range(1,len(st)-1):\n      if st[i] == st[i-1] == st[i+1] == '0':\n       res+=1\n     print(res)",
        "inputs": [
            "3\n3\n010\n5\n10001\n7\n0000000\n"
        ],
        "outputs": [
            "0\n1\n7\n"
        ],
        "starter_code": "\ndef kbVxM():\n",
        "scope": [
            [
                "Function Body",
                2,
                11
            ],
            [
                "For Loop Body",
                4,
                11
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                9,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef NnUGl():\n    \"\"\"You are given $n$ intervals in form $[l; r]$ on a number line.\n\nYou are also given $m$ queries in form $[x; y]$. What is the minimal number of intervals you have to take so that every point (not necessarily integer) from $x$ to $y$ is covered by at least one of them? \n\nIf you can't choose intervals so that every point from $x$ to $y$ is covered, then print -1 for that query.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$) — the number of intervals and the number of queries, respectively.\n\nEach of the next $n$ lines contains two integer numbers $l_i$ and $r_i$ ($0 \\le l_i < r_i \\le 5 \\cdot 10^5$) — the given intervals.\n\nEach of the next $m$ lines contains two integer numbers $x_i$ and $y_i$ ($0 \\le x_i < y_i \\le 5 \\cdot 10^5$) — the queries.\n\n\n-----Output-----\n\nPrint $m$ integer numbers. The $i$-th number should be the answer to the $i$-th query: either the minimal number of intervals you have to take so that every point (not necessarily integer) from $x_i$ to $y_i$ is covered by at least one of them or -1 if you can't choose intervals so that every point from $x_i$ to $y_i$ is covered.\n\n\n-----Examples-----\nInput\n2 3\n1 3\n2 4\n1 3\n1 4\n3 4\n\nOutput\n1\n2\n1\n\nInput\n3 4\n1 3\n1 3\n4 5\n1 2\n1 3\n1 4\n1 5\n\nOutput\n1\n1\n-1\n-1\n\n\n\n-----Note-----\n\nIn the first example there are three queries:\n\n  query $[1; 3]$ can be covered by interval $[1; 3]$;  query $[1; 4]$ can be covered by intervals $[1; 3]$ and $[2; 4]$. There is no way to cover $[1; 4]$ by a single interval;  query $[3; 4]$ can be covered by interval $[2; 4]$. It doesn't matter that the other points are covered besides the given query. \n\nIn the second example there are four queries:\n\n  query $[1; 2]$ can be covered by interval $[1; 3]$. Note that you can choose any of the two given intervals $[1; 3]$;  query $[1; 3]$ can be covered by interval $[1; 3]$;  query $[1; 4]$ can't be covered by any set of intervals;  query $[1; 5]$ can't be covered by any set of intervals. Note that intervals $[1; 3]$ and $[4; 5]$ together don't cover $[1; 5]$ because even non-integer points should be covered. Here $3.5$, for example, isn't covered.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef NnUGl():\n    input = sys.stdin.readline\n    N, M = list(map(int, input().split()))\n    A = []\n    for _ in range(N):\n        l, r = list(map(int, input().split()))\n        A.append([l, r])\n    Z = []\n    for _ in range(M):\n        l, r = list(map(int, input().split()))\n        Z.append([l, r])\n    MA = 5*10**5+1\n    lg = 20\n    X = [[-1]*MA for i in range(lg)]\n    for i in range(N):\n        X[0][A[i][0]] = max(X[0][A[i][0]], A[i][1])\n    for i in range(1, MA):\n        X[0][i] = max(X[0][i], X[0][i-1])\n    for k in range(1, lg):\n        for i in range(MA):\n            a = X[k-1][i]\n            if a >= 0:\n                X[k][i] = X[k-1][a]\n    for a, b in Z:\n        ans = 1\n        for k in range(lg)[::-1]:\n            if X[k][a] < b:\n                a = X[k][a]\n                ans += 2**k\n        print(-1 if X[0][a] < b or ans > MA else ans)",
        "inputs": [
            "2 3\n1 3\n2 4\n1 3\n1 4\n3 4\n",
            "3 4\n1 3\n1 3\n4 5\n1 2\n1 3\n1 4\n1 5\n",
            "3 20\n5 9\n5 9\n9 10\n1 8\n2 7\n1 10\n4 6\n6 9\n6 9\n5 9\n3 6\n1 6\n5 7\n3 7\n0 4\n5 7\n0 10\n5 9\n6 10\n2 3\n8 9\n5 8\n7 8\n"
        ],
        "outputs": [
            "1\n2\n1\n",
            "1\n1\n-1\n-1\n",
            "-1\n-1\n-1\n-1\n1\n1\n1\n-1\n-1\n1\n-1\n-1\n1\n-1\n1\n2\n-1\n1\n1\n1\n"
        ],
        "starter_code": "\ndef NnUGl():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "List Comprehension",
                15,
                15
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                18,
                19
            ],
            [
                "For Loop Body",
                20,
                24
            ],
            [
                "For Loop Body",
                21,
                24
            ],
            [
                "If Statement Body",
                23,
                24
            ],
            [
                "For Loop Body",
                25,
                31
            ],
            [
                "For Loop Body",
                27,
                30
            ],
            [
                "If Statement Body",
                28,
                30
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef itknv():\n    \"\"\"Consider a linear function f(x) = Ax + B. Let's define g^{(0)}(x) = x and g^{(}n)(x) = f(g^{(}n - 1)(x)) for n > 0. For the given integer values A, B, n and x find the value of g^{(}n)(x) modulo 10^9 + 7.\n\n\n-----Input-----\n\nThe only line contains four integers A, B, n and x (1 ≤ A, B, x ≤ 10^9, 1 ≤ n ≤ 10^18) — the parameters from the problem statement.\n\nNote that the given value n can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.\n\n\n-----Output-----\n\nPrint the only integer s — the value g^{(}n)(x) modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n3 4 1 1\n\nOutput\n7\n\nInput\n3 4 2 1\n\nOutput\n25\n\nInput\n3 4 3 1\n\nOutput\n79\n    \"\"\"\n",
        "canonical_solution": "\ndef itknv():\n    a, b, n, x = list(map(int, input().split(' ')))\n    fir = pow(a, n, 10**9+7)*x%(10**9+7)\n    sec = b*(pow(a, n, 10**9+7)-1)*(pow(a-1, 10**9+5, 10**9+7))%(10**9+7)\n    if (a == 1):\n        sec = n * b\n    print((fir+sec)%(10**9+7))\n    ",
        "inputs": [
            "3 4 1 1\n",
            "3 4 2 1\n",
            "3 4 3 1\n"
        ],
        "outputs": [
            "7\n",
            "25\n",
            "79\n"
        ],
        "starter_code": "\ndef itknv():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "If Statement Body",
                6,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef jCkSA():\n    \"\"\"Suppose you are performing the following algorithm. There is an array $v_1, v_2, \\dots, v_n$ filled with zeroes at start. The following operation is applied to the array several times — at $i$-th step ($0$-indexed) you can:   either choose position $pos$ ($1 \\le pos \\le n$) and increase $v_{pos}$ by $k^i$;  or not choose any position and skip this step. \n\nYou can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array $v$ equal to the given array $a$ ($v_j = a_j$ for each $j$) after some step?\n\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 1000$) — the number of test cases. Next $2T$ lines contain test cases — two lines per test case.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 30$, $2 \\le k \\le 100$) — the size of arrays $v$ and $a$ and value $k$ used in the algorithm.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^{16}$) — the array you'd like to achieve.\n\n\n-----Output-----\n\nFor each test case print YES (case insensitive) if you can achieve the array $a$ after some step or NO (case insensitive) otherwise.\n\n\n-----Example-----\nInput\n5\n4 100\n0 0 0 0\n1 2\n1\n3 4\n1 4 1\n3 2\n0 1 3\n3 9\n0 59049 810\n\nOutput\nYES\nYES\nNO\nNO\nYES\n\n\n\n-----Note-----\n\nIn the first test case, you can stop the algorithm before the $0$-th step, or don't choose any position several times and stop the algorithm.\n\nIn the second test case, you can add $k^0$ to $v_1$ and stop the algorithm.\n\nIn the third test case, you can't make two $1$ in the array $v$.\n\nIn the fifth test case, you can skip $9^0$ and $9^1$, then add $9^2$ and $9^3$ to $v_3$, skip $9^4$ and finally, add $9^5$ to $v_2$.\n    \"\"\"\n",
        "canonical_solution": "\ndef jCkSA():\n    t = int(input())\n    for _ in range(t):\n        n,k = list(map(int,input().split()))\n        a = list(map(int,input().split()))\n        for i in range(60, -1, -1):\n            m = k ** i\n            for j in range(n):\n                if a[j] >= m:\n                    a[j] -= m\n                    break\n        if all(i == 0 for i in a):\n            print('YES')\n        else:\n            print('NO')\n    ",
        "inputs": [
            "5\n4 100\n0 0 0 0\n1 2\n1\n3 4\n1 4 1\n3 2\n0 1 3\n3 9\n0 59049 810\n",
            "3\n5 2\n1 2 4 8 17\n2 3\n1 2\n4 3\n10 4 13 12\n",
            "1\n1 10\n10000000000000000\n"
        ],
        "outputs": [
            "YES\nYES\nNO\nNO\nYES\n",
            "NO\nNO\nNO\n",
            "YES\n"
        ],
        "starter_code": "\ndef jCkSA():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                4,
                16
            ],
            [
                "For Loop Body",
                7,
                12
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                13,
                16
            ],
            [
                "Generator Expression",
                13,
                13
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef HCPEb():\n    \"\"\"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first n. He writes down the following sequence of numbers: firstly all odd integers from 1 to n (in ascending order), then all even integers from 1 to n (also in ascending order). Help our hero to find out which number will stand at the position number k.\n\n\n-----Input-----\n\nThe only line of input contains integers n and k (1 ≤ k ≤ n ≤ 10^12).\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint the number that will stand at the position number k after Volodya's manipulations.\n\n\n-----Examples-----\nInput\n10 3\n\nOutput\n5\nInput\n7 7\n\nOutput\n6\n\n\n-----Note-----\n\nIn the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.\n    \"\"\"\n",
        "canonical_solution": "\ndef HCPEb():\n    N,K=input().split()\n    N,K=int(N),int(K)\n    \n    if(N%2==0):\n        if(K<=N//2):\n            print(2*K-1)\n        else:\n            K-=N//2\n            print(2*K)\n    \n    else:\n        if(K<=N//2+1):\n            print(2*K-1)\n        else:\n            K-=N//2+1\n            print(2*K)\n    \n    ",
        "inputs": [
            "10 3\n",
            "7 7\n",
            "7 1\n"
        ],
        "outputs": [
            "5",
            "6",
            "1"
        ],
        "starter_code": "\ndef HCPEb():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "If Statement Body",
                6,
                18
            ],
            [
                "If Statement Body",
                7,
                11
            ],
            [
                "If Statement Body",
                14,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef KMnTZ():\n    \"\"\"Henry and Derek are waiting on a room, eager to join the Snackdown 2016 Qualifier Round. They decide to pass the time by playing a game.  \nIn this game's setup, they write N positive integers on a blackboard. Then the players take turns, starting with Henry. In a turn, a player selects one of the integers, divides it by 2, 3, 4, 5 or 6, and then takes the floor to make it an integer again. If the integer becomes 0, it is erased from the board. The player who makes the last move wins.  \n\nHenry and Derek are very competitive, so aside from wanting to win Snackdown, they also want to win this game. Assuming they play with the optimal strategy, your task is to predict who wins the game.  \n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N denoting the number of integers they wrote on the board. The second line contains N space-separated integers A1, A2, ..., AN denoting the integers themselves.\n\n-----Output-----\nFor each test case, output a single line containing either “Henry” or “Derek” (without quotes), denoting the winner of the game.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 100\n- 1 ≤ Ai ≤ 1018\n\n-----Example-----\nInput:2\n2\n3 4\n3\n1 3 5\n\nOutput:Henry\nDerek\n\n-----Explanation-----\nExample case 1. In this test case, the numbers on the board are [3,4]. Henry can win by selecting 4 and then dividing it by 2. The integers on the board are now [3,2]. Derek now has a couple of choices:\n- Derek can divide 2 by 3, 4, 5 or 6, making it 0 and removing it. Now only one integer remains on the board, 3, and Henry can just divide it by 6 to finish, and win, the game.\n- Derek can divide 3 by 4, 5 or 6, making it 0 and removing it. Now only one integer remains on the board, 2, and Henry can just divide it by 6 to finish, and win, the game.\n- Derek can divide 2 by 2. Now the integers are [1,3]. Henry can respond by dividing 3 by 3. The integers are now [1,1]. Now Derek has no choice but to divide 1 by 2, 3, 4, 5 or 6 and remove it (because it becomes 0). Henry can respond by dividing the remaining 1 by 2 to finish, and win, the game.\n- Derek can divide 3 by 2 or 3. Now the integers are [1,2]. Henry can respond by dividing 2 by 2. The integers are now [1,1]. This leads to a situation as in the previous case and Henry wins.\n    \"\"\"\n",
        "canonical_solution": "\ndef KMnTZ():\n    gb = [0, 1, 2, 2, 3, 3]\n    ga = [0 for x in range(70)]\n    gag = [0 for x in range(70)]\n    ga[0] = 1\n    gag[0] = 0\n    \n    for i in range(1, 70):\n     if i % 4 == 0:\n      ga[i] = 1.5 * ga[i-1]\n      gag[i] = 0\n     else:\n      ga[i] = 2 * ga[i-1]\n      gag[i] = gag[i-1] + 1\n    \n    \n    def g(n):\n     if n < 6:\n      return gb[n]\n     else:\n      x = n / 6\n      a = 0\n      for i, k in enumerate(ga):\n       if k <= x:\n        a = i\n       else:\n        break\n      return gag[a]\n    \n    \n    t = int(input())\n    for q in range(t):\n     n = int(input())\n     a = list(map(int, input().split()))\n    \n     res = g(a[0])\n     for i in range(1, n):\n      res ^= g(a[i])\n    \n     if res == 0:\n      print(\"Derek\")\n     else:\n      print(\"Henry\")\n    ",
        "inputs": [
            "2\n2\n3 4\n3\n1 3 5\n"
        ],
        "outputs": [
            "Henry\nDerek\n"
        ],
        "starter_code": "\ndef KMnTZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                44
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                9,
                15
            ],
            [
                "If Statement Body",
                10,
                15
            ],
            [
                "Function Body",
                18,
                29
            ],
            [
                "If Statement Body",
                19,
                29
            ],
            [
                "For Loop Body",
                24,
                28
            ],
            [
                "If Statement Body",
                25,
                28
            ],
            [
                "For Loop Body",
                33,
                44
            ],
            [
                "For Loop Body",
                38,
                39
            ],
            [
                "If Statement Body",
                41,
                44
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GWtwb():\n    \"\"\"You are given an integer sequence of length N. The i-th term in the sequence is a_i.\nIn one operation, you can select a term and either increment or decrement it by one.\nAt least how many operations are necessary to satisfy the following conditions?\n - For every i (1≤i≤n), the sum of the terms from the 1-st through i-th term is not zero.\n - For every i (1≤i≤n-1), the sign of the sum of the terms from the 1-st through i-th term, is different from the sign of the sum of the terms from the 1-st through (i+1)-th term.\n\n-----Constraints-----\n - 2 ≤ n ≤ 10^5\n - |a_i| ≤ 10^9\n - Each a_i is an integer.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nn\na_1 a_2 ... a_n\n\n-----Output-----\nPrint the minimum necessary count of operations.\n\n-----Sample Input-----\n4\n1 -3 1 0\n\n-----Sample Output-----\n4\n\nFor example, the given sequence can be transformed into 1, -2, 2, -2 by four operations. The sums of the first one, two, three and four terms are 1, -1, 1 and -1, respectively, which satisfy the conditions.\n    \"\"\"\n",
        "canonical_solution": "\ndef GWtwb():\n    N = int(input())\n    A = [int(_) for _ in input().split()]\n    \n    def calc(A, y):\n        result = abs(A[0] - y)\n        t = y\n        if t == 0:\n            return 10**30\n        for a in A[1:N]:\n            tt = t + a\n            if t * tt >= 0:\n                m =  -t // abs(t)\n                result += abs(m - tt)\n                tt = m\n            t = tt\n        return result\n    \n    result = min(calc(A, A[0]), calc(A, -1),  calc(A, +1))\n    \n    print(result)\n    ",
        "inputs": [
            "4\n1 -3 1 0\n",
            "5\n3 -6 4 -5 7\n",
            "6\n-1 4 3 2 -5 4\n"
        ],
        "outputs": [
            "4\n",
            "0\n",
            "8\n"
        ],
        "starter_code": "\ndef GWtwb():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "Function Body",
                6,
                18
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "For Loop Body",
                11,
                17
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef yODmc():\n    \"\"\"\tA valid parentheses sequence is a non-empty string where each character is either '(' or ')', which satisfies the following constraint:\n\nYou can find a way to repeat erasing adjacent pairs of parentheses '()' until it becomes empty.\n\n\tFor example, '(())' and '()((()()))' are valid parentheses sequences, but ')()(' and '(()' are not.\n\n\tMike has a valid parentheses sequence. He really likes everything about his sequence, except the fact that it is quite long. So Mike has recently decided that he will replace his parentheses sequence with a new one in the near future. But not every valid parentheses sequence will satisfy him. To help you understand his requirements we'll introduce the pseudocode of function F(S):\n\n\tFUNCTION F( S - a valid parentheses sequence )\n\tBEGIN\n\t\tbalance = 0\n\t\tmax_balance = 0\n\t\tFOR index FROM 1 TO LENGTH(S)\n\t\tBEGIN\n\t\t\tif S[index] == '(' then balance = balance + 1\n\t\t\tif S[index] == ')' then balance = balance - 1\n\t\t\tmax_balance = max( max_balance, balance )\n\t\tEND\n\t\tRETURN max_balance\n\tEND\n\n\tIn other words, F(S) is equal to the maximal balance over all prefixes of S.\n\n\tLet's denote A as Mike's current parentheses sequence, and B as a candidate for a new one. Mike is willing to replace A with B if F(A) is equal to F(B). He would also like to choose B with the minimal possible length amongst ones satisfying the previous condition. If there are several such strings with the minimal possible length, then Mike will choose the least one lexicographically, considering '(' to be less than ')'.\n\n\tHelp Mike!\n\n-----Input-----\n\n\tThe first line of the input contains one integer T denoting the number of testcases to process.\n\n\tThe only line of each testcase contains one string A denoting Mike's parentheses sequence. It is guaranteed that A only consists of the characters '(' and ')'. It is also guaranteed that A is a valid parentheses sequence.\n\n-----Output-----\n\n\tThe output should contain exactly T lines, one line per each testcase in the order of their appearance. The only line of each testcase should contain one string B denoting the valid parentheses sequence that should be chosen by Mike to replace A.\n\n-----Constraints-----\n1 ≤ T ≤ 5;\n1 ≤ |A| ≤ 100000(105).\n\n-----Example-----\nInput:\n1\n()((()()))\n\nOutput:\n((()))\n    \"\"\"\n",
        "canonical_solution": "\ndef yODmc():\n    try:\n        for i in range(int(input())):\n            s=input()\n            balance=0\n            max_balance=0\n            for i in s:\n                if i=='(':balance+=1\n                else:\n                    balance-=1\n                max_balance=max(max_balance,balance)\n            print('('*max_balance,')'*max_balance,sep=\"\")\n    except Exception as e:\n        print(e)\n            ",
        "inputs": [
            "1\n()((()()))\n\n\n"
        ],
        "outputs": [
            "((()))\n"
        ],
        "starter_code": "\ndef yODmc():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "Try Block",
                3,
                15
            ],
            [
                "Except Block",
                14,
                15
            ],
            [
                "For Loop Body",
                4,
                13
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "If Statement Body",
                9,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Ytwcp():\n    \"\"\"The kingdom of Lazyland is the home to $n$ idlers. These idlers are incredibly lazy and create many problems to their ruler, the mighty King of Lazyland. \n\nToday $k$ important jobs for the kingdom ($k \\le n$) should be performed. Every job should be done by one person and every person can do at most one job. The King allowed every idler to choose one job they wanted to do and the $i$-th idler has chosen the job $a_i$. \n\nUnfortunately, some jobs may not be chosen by anyone, so the King has to persuade some idlers to choose another job. The King knows that it takes $b_i$ minutes to persuade the $i$-th idler. He asked his minister of labour to calculate the minimum total time he needs to spend persuading the idlers to get all the jobs done. Can you help him? \n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^5$) — the number of idlers and the number of jobs.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le k$) — the jobs chosen by each idler.\n\nThe third line of the input contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\le b_i \\le 10^9$) — the time the King needs to spend to persuade the $i$-th idler.\n\n\n-----Output-----\n\nThe only line of the output should contain one number — the minimum total time the King needs to spend persuading the idlers to get all the jobs done.\n\n\n-----Examples-----\nInput\n8 7\n1 1 3 1 5 3 7 1\n5 7 4 8 1 3 5 2\n\nOutput\n10\n\nInput\n3 3\n3 1 2\n5 3 4\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example the optimal plan is to persuade idlers 1, 6, and 8 to do jobs 2, 4, and 6.\n\nIn the second example each job was chosen by some idler, so there is no need to persuade anyone.\n    \"\"\"\n",
        "canonical_solution": "\ndef Ytwcp():\n    n, k = list(map(int, input().strip().split()))\n    \n    jobs = list(map(int, input().strip().split()))\n    times = list(map(int, input().strip().split()))\n    \n    counts_jobs = {}\n    for job in jobs:\n        if job in counts_jobs:\n            counts_jobs[job] += 1\n        else:\n            counts_jobs[job] = 1\n    \n    times_i = []\n    for i, time in enumerate(times):\n        times_i.append((time, i))\n    \n    times_i.sort()\n    jobs_left = k-len(counts_jobs.keys())\n    \n    ans = 0\n    for time, i in times_i:\n        if jobs_left == 0:\n            break\n        if counts_jobs[jobs[i]] > 1:\n            ans += time\n            jobs_left -= 1\n            counts_jobs[jobs[i]] -= 1\n    \n    print(ans)",
        "inputs": [
            "8 7\n1 1 3 1 5 3 7 1\n5 7 4 8 1 3 5 2\n",
            "3 3\n3 1 2\n5 3 4\n",
            "14 6\n2 3 6 6 6 2 5 3 5 5 5 6 5 5\n56 41 19 81 19 32 99 37 97 20 90 44 19 79\n"
        ],
        "outputs": [
            "10\n",
            "0\n",
            "38\n"
        ],
        "starter_code": "\ndef Ytwcp():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                10,
                13
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                23,
                29
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "If Statement Body",
                26,
                29
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef BxTQV():\n    \"\"\"You like tracking airplane flights a lot. Specifically, you maintain history of an airplane’s flight at several instants and record them in your notebook. Today, you have recorded N such records h1, h2, ..., hN, denoting the heights of some airplane at several instants. These records mean that airplane was first flying on height h1, then started changing its height to h2, then from h2 to h3 and so on. The airplanes are usually on cruise control while descending or ascending, so \nyou can assume that plane will smoothly increase/decrease its height from hi to hi + 1 with a constant speed. You can see that during this period, the airplane will cover all possible heights in the range [min(hi, hi+1), max(hi, hi+1)] (both inclusive). It is easy to see that the plane will be at all possible heights in the range exactly a single instant of time during this ascend/descend.\n\nYou are interested in finding the maximum integer K such that the plane was at some height exactly K times during the flight.\n\n-----Input-----\nThere is a single test case.\nFirst line of the input contains an integer N denoting the number of records of heights of the plane.\nSecond line contains N space separated integers denoting h1, h2, ..., hN.\n\n-----Output-----\nOutput a single maximum integer K in one line, such that the plane was at some height exactly K times during the flight.\n\n-----Constraints-----\n- hi ≠ hi+1\n\n-----Subtasks-----\nSubtask #1: (30 points)\n- 1 ≤ N ≤ 1000\n- 1 ≤ hi ≤ 1000\n\nSubtask #2: (70 points)\n- 1 ≤ N ≤ 105\n- 1 ≤ hi ≤ 109\n\n-----Example-----\nInput:\n5\n1 2 3 2 3\n\nOutput:\n3\n\n-----Explanation-----\n\nThe flight can be draw as:\n\n3  /\\/\n2 /\n1\n\nThere are infinitely many heights at which the plane was 3 times during the flight, for example 2.5, 2.1. Notice that the plane was only 2 times at height 2. Moreover, there are no height at which the plane was more than 3 times, so the answer is 3.\n    \"\"\"\n",
        "canonical_solution": "\ndef BxTQV():\n    def f(n):\n    \n     s = list(map(int, input().split()))\n     low = []\n     high = []\n    \n     for i in range(n - 1):\n      low.append(min(s[i], s[i+1]))\n      high.append(max(s[i], s[i+1]))\n     low.sort()\n     high.sort()\n     curr = mx = 0\n     i = j = 0\n     n -= 1\n     while i < n and j < n:\n      if low[i] < high[j]:\n       i += 1\n       curr += 1\n      else:\n       j += 1\n       curr -= 1\n      mx = max(mx, curr)\n    \n     return mx \n     \n    n = int(input())\n    print(f(n))",
        "inputs": [
            "5\n1 2 3 2 3\n"
        ],
        "outputs": [
            "3\n"
        ],
        "starter_code": "\ndef BxTQV():\n",
        "scope": [
            [
                "Function Body",
                2,
                29
            ],
            [
                "Function Body",
                3,
                26
            ],
            [
                "For Loop Body",
                9,
                11
            ],
            [
                "While Loop Body",
                17,
                24
            ],
            [
                "If Statement Body",
                18,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef uzYFN():\n    \"\"\"Alice and Brown loves games. Today, they will play the following game.\nIn this game, there are two piles initially consisting of X and Y stones, respectively.\nAlice and Bob alternately perform the following operation, starting from Alice:\n - Take 2i stones from one of the piles. Then, throw away i of them, and put the remaining i in the other pile. Here, the integer i (1≤i) can be freely chosen as long as there is a sufficient number of stones in the pile.\nThe player who becomes unable to perform the operation, loses the game.\nGiven X and Y, determine the winner of the game, assuming that both players play optimally.\n\n-----Constraints-----\n - 0 ≤ X, Y ≤ 10^{18}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nX Y\n\n-----Output-----\nPrint the winner: either Alice or Brown.\n\n-----Sample Input-----\n2 1\n\n-----Sample Output-----\nBrown\n\nAlice can do nothing but taking two stones from the pile containing two stones. As a result, the piles consist of zero and two stones, respectively. Then, Brown will take the two stones, and the piles will consist of one and zero stones, respectively. Alice will be unable to perform the operation anymore, which means Brown's victory.\n    \"\"\"\n",
        "canonical_solution": "\ndef uzYFN():\n    X,Y=map(int,input().split())\n    print('Alice' if abs(X-Y) > 1 else 'Brown')",
        "inputs": [
            "2 1\n",
            "5 0\n",
            "0 0\n"
        ],
        "outputs": [
            "Brown\n",
            "Alice\n",
            "Brown\n"
        ],
        "starter_code": "\ndef uzYFN():\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Wclhr():\n    \"\"\"Maheshmati and Sangu are playing a game. First, Maheshmati gives Sangu a sequence of $N$ distinct integers $a_1, a_2, \\dots, a_N$ (not necessarily sorted) and an integer $K$. Sangu has to create all subsequences of this sequence with length $K$. For each subsequence, he has to write down the product of $K-2$ integers: all elements of this subsequence except the minimum and maximum element.\nSangu wins the game if he is able to write down all these numbers and tell Maheshmati their product (modulo $10^9+7$, since it can be very large). However, Sangu is a very lazy child and thus wants you to help him win this game. Compute the number Sangu should tell Maheshmati!\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $a_1, a_2, \\dots, a_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the product of all numbers written down by Sangu modulo $10^9+7$.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $3 \\le N \\le 5,000$\n- $3 \\le K \\le N$\n- $1 \\le a_i \\le 10,000$ for each valid $i$\n- the numbers $a_1, a_2, \\dots, a_N$ are pairwise distinct\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le N \\le 10$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n1\n4 3 \n1 2 3 4 \n\n-----Example Output-----\n36\n\n-----Explanation-----\nExample case 1: There are four possible subsequences:\n- $[1, 2, 3]$ (Sangu should write down $2$.)\n- $[1, 3, 4]$ (Sangu should write down $3$.)\n- $[1, 2, 4]$ (Sangu should write down $2$.)\n- $[2, 3, 4]$ (Sangu should write down $3$.)\nThe required product is $2 \\cdot 3 \\cdot 2 \\cdot 3 = 36$.\n    \"\"\"\n",
        "canonical_solution": "\ndef Wclhr():\n    f = 5003*[0]\n    modn = 1000000007\n    \n    \n    def qPow(a, b):\n     nonlocal modn\n     res = 1\n     while b > 0:\n      if (b & 1) == 1:\n       res = res * a % modn\n      a = a * a % modn\n      b = b >> 1\n     return res\n    \n    \n    def getF():\n     nonlocal f\n     f[0] = 1\n     for i in range(1, 5001):\n      f[i] = f[i-1] * i\n    \n    \n    def __starting_point():\n     getF()\n     T = int(input())\n     while T > 0:\n      T = T - 1\n      n, k = list(map(int,input().split()))\n      lis = list(map(int, input().split()))\n      lis = sorted(lis)\n      res = 1\n      for i in range(n):\n       zhi = f[n-1]//f[k-1]//f[n-k]\n       if i >= k-1:\n        zhi = zhi - f[i]//f[k-1]//f[i+1-k]\n       if n-i-1 >= k-1:\n        zhi = zhi - f[n-i-1]//f[k-1]//f[n-i-k]\n       zhi = zhi % (modn-1)\n       # print(zhi)\n       res = res * qPow(lis[i], zhi) % modn\n      print(res)\n    \n    __starting_point()",
        "inputs": [
            "1\n4 3\n1 2 3 4\n"
        ],
        "outputs": [
            "36\n"
        ],
        "starter_code": "\ndef Wclhr():\n",
        "scope": [
            [
                "Function Body",
                2,
                45
            ],
            [
                "Function Body",
                7,
                15
            ],
            [
                "While Loop Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "Function Body",
                18,
                22
            ],
            [
                "For Loop Body",
                21,
                22
            ],
            [
                "Function Body",
                25,
                43
            ],
            [
                "While Loop Body",
                28,
                43
            ],
            [
                "For Loop Body",
                34,
                42
            ],
            [
                "If Statement Body",
                36,
                37
            ],
            [
                "If Statement Body",
                38,
                39
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef eDlhX():\n    \"\"\"The cities of Byteland and Berland are located on the axis $Ox$. In addition, on this axis there are also disputed cities, which belong to each of the countries in their opinion. Thus, on the line $Ox$ there are three types of cities:  the cities of Byteland,  the cities of Berland,  disputed cities. \n\nRecently, the project BNET has been launched — a computer network of a new generation. Now the task of the both countries is to connect the cities so that the network of this country is connected.\n\nThe countries agreed to connect the pairs of cities with BNET cables in such a way that:  If you look at the only cities of Byteland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables,  If you look at the only cities of Berland and the disputed cities, then in the resulting set of cities, any city should be reachable from any other one by one or more cables. \n\nThus, it is necessary to choose a set of pairs of cities to connect by cables in such a way that both conditions are satisfied simultaneously. Cables allow bi-directional data transfer. Each cable connects exactly two distinct cities.\n\nThe cost of laying a cable from one city to another is equal to the distance between them. Find the minimum total cost of laying a set of cables so that two subsets of cities (Byteland and disputed cities, Berland and disputed cities) are connected.\n\nEach city is a point on the line $Ox$. It is technically possible to connect the cities $a$ and $b$ with a cable so that the city $c$ ($a < c < b$) is not connected to this cable, where $a$, $b$ and $c$ are simultaneously coordinates of the cities $a$, $b$ and $c$.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\le n \\le 2 \\cdot 10^{5}$) — the number of cities.\n\nThe following $n$ lines contains an integer $x_i$ and the letter $c_i$ ($-10^{9} \\le x_i \\le 10^{9}$) — the coordinate of the city and its type. If the city belongs to Byteland, $c_i$ equals to 'B'. If the city belongs to Berland, $c_i$ equals to «R». If the city is disputed, $c_i$ equals to 'P'. \n\nAll cities have distinct coordinates. Guaranteed, that the cities are given in the increasing order of their coordinates.\n\n\n-----Output-----\n\nPrint the minimal total length of such set of cables, that if we delete all Berland cities ($c_i$='R'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables. Similarly, if we delete all Byteland cities ($c_i$='B'), it will be possible to find a way from any remaining city to any other remaining city, moving only by cables.\n\n\n-----Examples-----\nInput\n4\n-5 R\n0 P\n3 P\n7 B\n\nOutput\n12\n\nInput\n5\n10 R\n14 B\n16 B\n21 R\n32 R\n\nOutput\n24\n\n\n\n-----Note-----\n\nIn the first example, you should connect the first city with the second, the second with the third, and the third with the fourth. The total length of the cables will be $5 + 3 + 4 = 12$.\n\nIn the second example there are no disputed cities, so you need to connect all the neighboring cities of Byteland and all the neighboring cities of Berland. The cities of Berland have coordinates $10, 21, 32$, so to connect them you need two cables of length $11$ and $11$. The cities of Byteland have coordinates $14$ and $16$, so to connect them you need one cable of length $2$. Thus, the total length of all cables is $11 + 11 + 2 = 24$.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin, stdout\ndef eDlhX():\n    input, print = stdin.readline, stdout.write\n    n = int(input())\n    r, g, b = [], [], []\n    ans = 0\n    for i in range(n):\n        x, t = [i for i in input().split()]\n        x = int(x)\n        if t == 'P':\n            g.append(x)\n        elif t == 'R':\n            r.append(x)\n        else:\n            b.append(x)\n            \n    if len(g) == 0:\n        if len(r):\n            ans += r[-1] - r[0]\n        if len(b):\n            ans += b[-1] - b[0]\n        print(str(ans))\n        return\n        \n    if not len(r):\n        r.append(g[0])\n    if not len(b):\n        b.append(g[0])\n    if r[0] < g[0]:\n        ans += g[0] - r[0]\n    if b[0] < g[0]:\n        ans += g[0] - b[0]\n    if r[-1] > g[-1]:\n        ans += r[-1] - g[-1]\n    if b[-1] > g[-1]:\n        ans += b[-1] - g[-1]\n    bi, ri = 0, 0\n    for i in range(len(g) - 1):\n        while bi < len(b) - 1 and b[bi] < g[i]:\n            bi += 1\n        while ri < len(r) - 1 and r[ri] < g[i]:\n            ri += 1\n        a1, a2 = (g[i + 1] - g[i]) * 3, (g[i + 1] - g[i]) * 2\n        mr, mb, cbi, cri = r[ri] - g[i], b[bi] - g[i], bi, ri\n        while cbi + 1 < len(b) and b[cbi + 1] < g[i + 1]:\n            mb = max(mb, b[cbi + 1] - b[cbi])\n            cbi += 1\n        mb = max(mb, g[i + 1] - b[cbi])\n        while cri + 1 < len(r) and r[cri + 1] < g[i + 1]:\n            mr = max(mr, r[cri + 1] - r[cri])\n            cri += 1\n        mr = max(mr, g[i + 1] - r[cri])\n           \n        if b[bi] < g[i] or b[bi] > g[i + 1]:\n            a2 = 100000000000000\n            a1 -= g[i + 1] - g[i]\n            mb = 0\n        if r[ri] < g[i] or r[ri] > g[i + 1]:\n            a2 = 100000000000000\n            a1 -= g[i + 1] - g[i]\n            mr = 0\n            \n        ans += min(a1 - mr - mb, a2)\n        \n    print(str(ans))",
        "inputs": [
            "4\n-5 R\n0 P\n3 P\n7 B\n",
            "5\n10 R\n14 B\n16 B\n21 R\n32 R\n",
            "10\n66 R\n67 R\n72 R\n73 R\n76 R\n78 B\n79 B\n83 B\n84 B\n85 P\n"
        ],
        "outputs": [
            "12\n",
            "24\n",
            "26\n"
        ],
        "starter_code": "\ndef eDlhX():\n",
        "scope": [
            [
                "Function Body",
                2,
                65
            ],
            [
                "For Loop Body",
                7,
                15
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "If Statement Body",
                10,
                15
            ],
            [
                "If Statement Body",
                12,
                15
            ],
            [
                "If Statement Body",
                17,
                23
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "If Statement Body",
                27,
                28
            ],
            [
                "If Statement Body",
                29,
                30
            ],
            [
                "If Statement Body",
                31,
                32
            ],
            [
                "If Statement Body",
                33,
                34
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "For Loop Body",
                38,
                63
            ],
            [
                "While Loop Body",
                39,
                40
            ],
            [
                "While Loop Body",
                41,
                42
            ],
            [
                "While Loop Body",
                45,
                47
            ],
            [
                "While Loop Body",
                49,
                51
            ],
            [
                "If Statement Body",
                54,
                57
            ],
            [
                "If Statement Body",
                58,
                61
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef WETeM():\n    \"\"\"People in the Tomskaya region like magic formulas very much. You can see some of them below.\n\nImagine you are given a sequence of positive integer numbers p_1, p_2, ..., p_{n}. Lets write down some magic formulas:$q_{i} = p_{i} \\oplus(i \\operatorname{mod} 1) \\oplus(i \\operatorname{mod} 2) \\oplus \\cdots \\oplus(i \\operatorname{mod} n)$$Q = q_{1} \\oplus q_{2} \\oplus \\ldots \\oplus q_{n}$\n\nHere, \"mod\" means the operation of taking the residue after dividing.\n\nThe expression $x \\oplus y$ means applying the bitwise xor (excluding \"OR\") operation to integers x and y. The given operation exists in all modern programming languages. For example, in languages C++ and Java it is represented by \"^\", in Pascal — by \"xor\".\n\nPeople in the Tomskaya region like magic formulas very much, but they don't like to calculate them! Therefore you are given the sequence p, calculate the value of Q.\n\n\n-----Input-----\n\nThe first line of the input contains the only integer n (1 ≤ n ≤ 10^6). The next line contains n integers: p_1, p_2, ..., p_{n} (0 ≤ p_{i} ≤ 2·10^9).\n\n\n-----Output-----\n\nThe only line of output should contain a single integer — the value of Q.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n\nOutput\n3\n    \"\"\"\n",
        "canonical_solution": "\ndef WETeM():\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    s = [0] * n\n    for i in range(1,n):\n        s[i] = s[i-1] ^ i\n    q = 0\n    for i in range(n):\n        q = q ^ p[i]\n        if (n // (i+1)) % 2 == 1:\n            q = q ^ s[i]\n        q = q ^ s[n % (i+1)]\n    print(q)\n    ",
        "inputs": [
            "3\n1 2 3\n",
            "1\n0\n",
            "2\n65535 0\n"
        ],
        "outputs": [
            "3\n",
            "0\n",
            "65534\n"
        ],
        "starter_code": "\ndef WETeM():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                11,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef nAPSq():\n    \"\"\"On each of the following $N$ days (numbered $1$ through $N$), Chef is planning to cook either pizza or broccoli. He wrote down a string $A$ with length $N$, where for each valid $i$, if the character $A_i$ is '1', then he will cook pizza on the $i$-th day, while if $A_i$ is '0', he will cook broccoli on this day.\nChefu, his son, loves pizza but hates broccoli ― just like most kids. He wants to select a substring of $A$ with length $K$ and change each character '0' in this substring to '1'. Afterwards, let's define pizza time as the maximum number of consecutive days where Chef will cook pizza. Find the maximum pizza time Chefu can achieve.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$. \n- The second line contains a string $A$ with length $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum pizza time.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le K \\le N \\le 10^5$\n- $A$ contains only characters '0' and '1'\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- $N \\le 10^3$\n- the sum of $N$ over all test cases does not exceed $10^4$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n2\n13 2\n0101110000101\n6 3\n100001\n\n-----Example Output-----\n5\n4\n\n-----Explanation-----\nExample case 1: Chefu can choose the substring $A[2, 3]$ = \"10\", and change the third character of $A$ to '1'. Then, the pizza time is $5$ days: from day $2$ to day $6$.\nExample case 2: Chefu can choose the substring $A[2, 4]$ = \"000\". Then, the pizza time is $4$ days: from day $1$ to day $4$.\n    \"\"\"\n",
        "canonical_solution": "\ndef nAPSq():\n    for _ in range(int(input())):\n    \n     n, k = map(int, input().split())\n     l = [*map(int, input())]\n    \n     count = [0] * (n + 1)\n    \n     for i in range(n - 1, -1, -1):\n      if l[i] == 1:\n       count[i] = count[i + 1] + 1\n    \n     x,y = 0,0\n     for i in range(n):\n      if l[i] == 1:\n       x += 1\n      else:\n       try:\n        y = max(y, x + k + count[i + k])\n    \n       except:\n        y = max(y, x + min(k, n - i))\n       x = 0\n      y = max(y,x)\n     print(y)",
        "inputs": [
            "2\n13 2\n0101110000101\n6 3\n100001\n"
        ],
        "outputs": [
            "5\n4\n"
        ],
        "starter_code": "\ndef nAPSq():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "For Loop Body",
                3,
                26
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "For Loop Body",
                15,
                25
            ],
            [
                "If Statement Body",
                16,
                24
            ],
            [
                "Try Block",
                19,
                23
            ],
            [
                "Except Block",
                22,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef dhkgl():\n    \"\"\"Sometimes it is not easy to come to an agreement in a bargain. Right now Sasha and Vova can't come to an agreement: Sasha names a price as high as possible, then Vova wants to remove as many digits from the price as possible. In more details, Sasha names some integer price $n$, Vova removes a non-empty substring of (consecutive) digits from the price, the remaining digits close the gap, and the resulting integer is the price.\n\nFor example, is Sasha names $1213121$, Vova can remove the substring $1312$, and the result is $121$.\n\nIt is allowed for result to contain leading zeros. If Vova removes all digits, the price is considered to be $0$.\n\nSasha wants to come up with some constraints so that Vova can't just remove all digits, but he needs some arguments supporting the constraints. To start with, he wants to compute the sum of all possible resulting prices after Vova's move.\n\nHelp Sasha to compute this sum. Since the answer can be very large, print it modulo $10^9 + 7$.\n\n\n-----Input-----\n\nThe first and only line contains a single integer $n$ ($1 \\le n < 10^{10^5}$).\n\n\n-----Output-----\n\nIn the only line print the required sum modulo $10^9 + 7$.\n\n\n-----Examples-----\nInput\n107\n\nOutput\n42\n\nInput\n100500100500\n\nOutput\n428101984\n\n\n\n-----Note-----\n\nConsider the first example.\n\nVova can choose to remove $1$, $0$, $7$, $10$, $07$, or $107$. The results are $07$, $17$, $10$, $7$, $1$, $0$. Their sum is $42$.\n    \"\"\"\n",
        "canonical_solution": "\ndef dhkgl():\n    s=input();M=10**9+7;o=u=v=0;n=len(s)\n    for i in range(n):c=int(s[i]);u+=v;v=(10*v+c)%M;o+=pow(10,n-i-1,M)*((i*i+i)//2*c+u)\n    print(o%M)",
        "inputs": [
            "107\n",
            "100500100500\n",
            "1\n"
        ],
        "outputs": [
            "42\n",
            "428101984\n",
            "0\n"
        ],
        "starter_code": "\ndef dhkgl():\n",
        "scope": [
            [
                "Function Body",
                2,
                5
            ],
            [
                "For Loop Body",
                4,
                4
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef QlqrV():\n    \"\"\"You have $n \\times n$ square grid and an integer $k$. Put an integer in each cell while satisfying the conditions below.  All numbers in the grid should be between $1$ and $k$ inclusive.  Minimum number of the $i$-th row is $1$ ($1 \\le i \\le n$).  Minimum number of the $j$-th column is $1$ ($1 \\le j \\le n$). \n\nFind the number of ways to put integers in the grid. Since the answer can be very large, find the answer modulo $(10^{9} + 7)$. [Image] These are the examples of valid and invalid grid when $n=k=2$. \n\n\n-----Input-----\n\nThe only line contains two integers $n$ and $k$ ($1 \\le n \\le 250$, $1 \\le k \\le 10^{9}$).\n\n\n-----Output-----\n\nPrint the answer modulo $(10^{9} + 7)$.\n\n\n-----Examples-----\nInput\n2 2\n\nOutput\n7\n\nInput\n123 456789\n\nOutput\n689974806\n\n\n\n-----Note-----\n\nIn the first example, following $7$ cases are possible. [Image] \n\nIn the second example, make sure you print the answer modulo $(10^{9} + 7)$.\n    \"\"\"\n",
        "canonical_solution": "\ndef QlqrV():\n    fa = [1]\n    m = 251\n    P = 10**9+7\n    for i in range(1, m+1): fa.append(fa[-1] * i % P)\n    fainv = [pow(fa[m], P-2, P)]\n    for i in range(1, m+1)[::-1]: fainv.append(fainv[-1] * i % P)\n    fainv = fainv[::-1]\n    def C(a, b): return fa[a] * fainv[a-b] * fainv[b] % P\n    \n    N, K = list(map(int, input().split()))\n    poK = [1]\n    for i in range(251): poK.append(poK[-1] * K % P)\n    poK1 = [1]\n    for i in range(251): poK1.append(poK1[-1] * (K-1) % P)\n    \n    dpC = [[C(i, j) for j in range(i+1)] for i in range(N+1)]\n    dpCpoK = [[C(i, j) * poK[j] % P for j in range(i+1)] for i in range(N+1)]\n    \n    DP = [[0] * (N+1) for _ in range(N+1)]\n    DP[0][0] = 1\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            for k in range(j+1):\n                if k < j:\n                    DP[i][j] = (DP[i][j] + DP[i-1][k] * dpCpoK[j][k]) % P\n                else:\n                    DP[i][j] = (DP[i][j] + DP[i-1][k] * dpC[j][k] % P * (poK[k] - poK1[k])) % P\n        for j in range(1, N+1):\n            DP[i][j] = DP[i][j] * poK1[N-j] % P\n    \n    print(DP[N][N])\n    \n    ",
        "inputs": [
            "2 2\n",
            "123 456789\n",
            "250 1000000000\n"
        ],
        "outputs": [
            "7\n",
            "689974806\n",
            "770503193\n"
        ],
        "starter_code": "\ndef QlqrV():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "For Loop Body",
                6,
                6
            ],
            [
                "For Loop Body",
                8,
                8
            ],
            [
                "Function Body",
                10,
                10
            ],
            [
                "For Loop Body",
                14,
                14
            ],
            [
                "For Loop Body",
                16,
                16
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "List Comprehension",
                21,
                21
            ],
            [
                "For Loop Body",
                23,
                31
            ],
            [
                "For Loop Body",
                24,
                29
            ],
            [
                "For Loop Body",
                25,
                29
            ],
            [
                "If Statement Body",
                26,
                29
            ],
            [
                "For Loop Body",
                30,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gMFHn():\n    \"\"\"Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:\nGiven N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ … An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.\nYou are friends with Kabir, help him to solve the problem for Tara.\n\n-----Input:-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. \n- First line of each test case contains N$N$, the number of elements in the sequence.\n- Second line contains N space separated elements A1$A_1$,A2$A_2$ … An$A_n$.\n\n-----Output:-----\n- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤N≤105$1 \\leq N \\leq 10^5$\n- 2≤A[i]≤105$2 \\leq A[i] \\leq 10^5$\n\n-----Sample Input:-----\n1\n7\n\n3 2 15 6 8 5 10\n\n-----Sample Output:-----\n5\n\n-----EXPLANATION:-----\nThe largest prime factors of numbers are:\n3 2  5  3  2  5  5 , of which 5 is most frequent.\n    \"\"\"\n",
        "canonical_solution": "\ndef gMFHn():\n    # cook your dish here\n    store=[0]*(10**5+1)\n    def sieve():\n    \tfor i in range(2,10**5+1):\n    \t\tif(store[i]==0):\n    \t\t\tstore[i]=1\n    \t\t\tfor j in range(i,10**5+1,i):\n    \t\t\t\tstore[j]=i\n    sieve()\n    # print(store)\n    for _ in range(int(input())):\n    \t\n    \tn=int(input())\n    \tli=[int(x) for x in input().split()]\n    \n    \tdp=[0]*(10**5+1)\n    \tfor i in li:\n    \t\tdp[store[i]]+=1\n    \tmax_re=0\n    \tres=0\n    \tfor i in li:\n    \t\tif(dp[store[i]]==max_re):\n    \t\t\tif(store[i]>res):\n    \t\t\t\tres=store[i]\n    \t\telif(dp[store[i]]>max_re):\n    \t\t\tmax_re=dp[store[i]]\n    \t\t\tres=store[i]\n    \t\n    \tprint(res)\n    \n    \n    \n    ",
        "inputs": [
            "1\n7\n3 2 15 6 8 5 10\n"
        ],
        "outputs": [
            "5\n"
        ],
        "starter_code": "\ndef gMFHn():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                5,
                10
            ],
            [
                "For Loop Body",
                6,
                10
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "For Loop Body",
                9,
                10
            ],
            [
                "For Loop Body",
                13,
                31
            ],
            [
                "List Comprehension",
                16,
                16
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "For Loop Body",
                23,
                29
            ],
            [
                "If Statement Body",
                24,
                29
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "If Statement Body",
                27,
                29
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef SLfln():\n    \"\"\"Sheldon is a little geek living in Texas. While his friends like to play outside, little Sheldon likes to play around with ICs and lasers in his house. He decides to build N clap activated toggle machines each with one power inlet and one outlet. Each machine works when its power source inlet is receiving power. When the machine is in 'ON' state and is receiving power at its inlet, it makes power available at its power outlet to which a bulb or another ToGgLe machine could be attached.\n\nSuppose Sheldon attached 2 such machines to one another with the power inlet of the first machine attached to a power source at his house and the outlet of the second machine to a bulb. Initially both machines are in 'OFF' state and power source to first machine is off too. Now the power source is switched on. The first machine receives power but being in the 'OFF' state it does not transmit any power. Now on clapping the first ToGgLe machine toggles to 'ON' and the second machine receives power. On clapping once more the first toggles to 'OFF' and the second toggles to 'ON'. But since the second ToGgLe machine receives no power the bulb does not light up yet. On clapping once more, the first machine which is still receiving power from the source toggles to 'ON' and the second which was already 'ON' does not toggle since it was not receiving power. So both the machine are in 'ON' state and the bulb lights up and little Sheldon is happy.\n\nBut when Sheldon goes out for a while, his evil twin sister attaches N such ToGgLe machines (after making sure they were all in 'OFF' state) and attaches the first to a power source (the power source is initially switched off) and the last ToGgLe machine to a bulb. Sheldon is horrified to find that his careful arrangement has been disturbed.\n\nCoders, help the poor boy by finding out if clapping k times for the N ToGgLe machines (all in 'OFF' state with the first one connected to a switched off power source and last one to a bulb) would light the bulb. Hurry before Sheldon has a nervous breakdown!\n\n-----Input-----\nFirst line has number of test cases, T.\n\nFollowing T lines have N, k separated by a single space where N is the number of \nToGgLe machines and k is the number of times Sheldon clapped.\n\n-----Output-----\nT lines with cach line of the form: \"ON\" (just the word on without the double quotes) if the bulb is 'ON' for the \ntest case numbered n and \"OFF\" (just the word off without the double quotes) if the bulb is 'OFF' for the test case numbered n.\n\n\n-----Example-----\nInput:\n4\n4 0\n4 47\n1 0\n1 1\n\nOutput:\nOFF\nON\nOFF\nON\n    \"\"\"\n",
        "canonical_solution": "\ndef SLfln():\n    n=int(input())\n    while n>0:\n     i=1\n     a,b=(int(i) for i in input().split())\n     if (b+1)%(i<<a)==0:\n      print(\"ON\")\n     else:\n      print(\"OFF\")\n     n=n-1\n    ",
        "inputs": [
            "4\n4 0\n4 47\n1 0\n1 1\n"
        ],
        "outputs": [
            "OFF\nON\nOFF\nON\n"
        ],
        "starter_code": "\ndef SLfln():\n",
        "scope": [
            [
                "Function Body",
                2,
                11
            ],
            [
                "While Loop Body",
                4,
                11
            ],
            [
                "Generator Expression",
                6,
                6
            ],
            [
                "If Statement Body",
                7,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef xVCXa():\n    \"\"\"Let's define a periodic infinite sequence S$S$ (0$0$-indexed) with period K$K$ using the formula Si=(i%K)+1$S_i = (i \\% K) + 1$.\nChef has found a sequence of positive integers A$A$ with length N$N$ buried underground. He suspects that it is a contiguous subsequence of some periodic sequence. Unfortunately, some elements of A$A$ are unreadable. Can you tell Chef the longest possible period K$K$ of an infinite periodic sequence which contains A$A$ (after suitably filling in the unreadable elements) as a contiguous subsequence?\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains a single integer N$N$. \n- The second line contains N$N$ space-separated integers A1,A2,…,AN$A_1, A_2, \\dots, A_N$. Unreadable elements are denoted by −1$-1$.\n\n-----Output-----\nFor each test case, print a single line.\n- If the period can be arbitrarily large, this line should contain a single string \"inf\".\n- Otherwise, if A$A$ cannot be a contiguous subsequence of a periodic sequence, it should contain a single string \"impossible\".\n- Otherwise, it should contain a single integer — the maximum possible period.\n\n-----Constraints-----\n- 1≤T≤100$1 \\le T \\le 100$\n- 2≤N≤105$2 \\le N \\le 10^5$\n- the sum of N$N$ over all test cases does not exceed 106$10^6$\n- for each valid i$i$, 1≤Ai≤106$1 \\le A_i \\le 10^6$ or Ai=−1$A_i = -1$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- 2≤N≤1,000$2 \\le N \\le 1,000$\n- the sum of N$N$ over all test cases does not exceed 10,000$10,000$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n3\n3\n-1 -1 -1\n5\n1 -1 -1 4 1\n4\n4 6 7 -1\n\n-----Example Output-----\ninf\n4\nimpossible\n    \"\"\"\n",
        "canonical_solution": "from math import gcd\ndef xVCXa():\n    # cook your dish here\n    for _ in range(int(input())):\n        n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \n        for j in range(n):\n         if(a[j] != -1):break            \n        for i in range(j,n):\n         if min_k==0:min_k,e = a[i],a[i]+1 \n         else:\n          if min_k < a[i]:min_k = a[i]                \n          if(a[i] == -1):pass\n          else:\n           if(a[i] == e):pass\n           else:\n            if( k == 0):k = e-a[i]\n            else:\n             new_k = e-a[i]\n             if(new_k < 0):k = -1\n             else:k = gcd(k,new_k)\n            if(k<min_k or k<0): k = -1; break\n          if k != 0 and a[i]!=-1: e = a[i]%k+1\n          else:e += 1             \n        if(k == -1):print(\"impossible\")\n        elif k == 0 :print(\"inf\")\n        else:print(k)  ",
        "inputs": [
            "3\n3\n-1 -1 -1\n5\n1 -1 -1 4 1\n4\n4 6 7 -1\n"
        ],
        "outputs": [
            "inf\n4\nimpossible\n"
        ],
        "starter_code": "\ndef xVCXa():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "For Loop Body",
                4,
                26
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "If Statement Body",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                23
            ],
            [
                "If Statement Body",
                9,
                23
            ],
            [
                "If Statement Body",
                11,
                11
            ],
            [
                "If Statement Body",
                12,
                21
            ],
            [
                "If Statement Body",
                14,
                21
            ],
            [
                "If Statement Body",
                16,
                20
            ],
            [
                "If Statement Body",
                19,
                20
            ],
            [
                "If Statement Body",
                21,
                21
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "If Statement Body",
                24,
                26
            ],
            [
                "If Statement Body",
                25,
                26
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef JfYEb():\n    \"\"\"Skier rides on a snowy field. Its movements can be described by a string of characters 'S', 'N', 'W', 'E' (which correspond to $1$ meter movement in the south, north, west or east direction respectively).\n\nIt is known that if he moves along a previously unvisited segment of a path (i.e. this segment of the path is visited the first time), then the time of such movement is $5$ seconds. If he rolls along previously visited segment of a path (i.e., this segment of the path has been covered by his path before), then it takes $1$ second.\n\nFind the skier's time to roll all the path.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach set is given by one nonempty string of the characters 'S', 'N', 'W', 'E'. The length of the string does not exceed $10^5$ characters.\n\nThe sum of the lengths of $t$ given lines over all test cases in the input does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the desired path time in seconds.\n\n\n-----Example-----\nInput\n5\nNNN\nNS\nWWEN\nWWEE\nNWNWS\n\nOutput\n15\n6\n16\n12\n25\n    \"\"\"\n",
        "canonical_solution": "\ndef JfYEb():\n    DIR = {\"N\": (0, 1), \"S\": (0, -1), \"W\": (-1, 0), \"E\": (1, 0)}\n    \n    for t in range(int(input())):\n       path = input()\n       tracks = set()\n       x, y = 0, 0\n       time = 0\n       for char in path:\n          x1 = x + DIR[char][0]\n          y1 = y + DIR[char][1]\n          if (x, y, x1, y1) in tracks or (x1, y1, x, y) in tracks:\n             time += 1\n          else:\n             time += 5\n             tracks.add((x, y, x1, y1))\n          x, y = x1, y1\n       print(time)\n    ",
        "inputs": [
            "5\nNNN\nNS\nWWEN\nWWEE\nNWNWS\n"
        ],
        "outputs": [
            "15\n6\n16\n12\n25\n"
        ],
        "starter_code": "\ndef JfYEb():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "For Loop Body",
                5,
                19
            ],
            [
                "For Loop Body",
                10,
                18
            ],
            [
                "If Statement Body",
                13,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef utneb():\n    \"\"\"Chef bought a huge (effectively infinite) planar island and built $N$ restaurants (numbered $1$ through $N$) on it. For each valid $i$, the Cartesian coordinates of restaurant $i$ are $(X_i, Y_i)$.\nNow, Chef wants to build $N-1$ straight narrow roads (line segments) on the island. The roads may have arbitrary lengths; restaurants do not have to lie on the roads. The slope of each road must be $1$ or $-1$, i.e. for any two points $(x_1, y_1)$ and $(x_2, y_2)$ on the same road, $|x_1-x_2| = |y_1-y_2|$ must hold.\nLet's denote the minimum distance Chef has to walk from restaurant $i$ to reach a road by $D_i$. Then, let's denote $a = \\mathrm{max}\\,(D_1, D_2, \\ldots, D_N)$; Chef wants this distance to be minimum possible.\nChef is a busy person, so he decided to give you the job of building the roads. You should find a way to build them that minimises $a$ and compute $a \\cdot \\sqrt{2}$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains two space-separated integers $X_i$ and $Y_i$.\n\n-----Output-----\nFor each test case, print a single line containing one real number — the minimum distance $a$ multiplied by $\\sqrt{2}$. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $2 \\le N \\le 10^4$\n- $|X_i|, |Y_i| \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (10 points):\n- $1 \\le T \\le 10$\n- $2 \\le N \\le 5$\n- $|X_i|, |Y_i| \\le 10$ for each valid $i$\n- $a \\cdot \\sqrt{2}$ is an integer\nSubtask #2 (90 points): original constraints\n\n-----Example Input-----\n2\n3\n0 0\n0 1\n0 -1\n3\n0 1\n1 0\n-1 0\n\n-----Example Output-----\n0.5\n0\n\n-----Explanation-----\nExample case 1: We should build roads described by equations $y-x+0.5 = 0$ and $y-x-0.5 = 0$.\nExample case 2: We should build roads described by equations $y-x-1 = 0$ and $y+x-1 = 0$.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef utneb():\n    def input():    return sys.stdin.readline().strip()\n    def iinput():   return int(input())\n    def rinput():   return list(map(int, sys.stdin.readline().strip().split())) \n    def get_list(): return list(map(int, sys.stdin.readline().strip().split()))\n    t=iinput()\n    for _ in range(t):\n     n=iinput()\n     p=[]\n     mi=[]\n     for i in range(n):\n      x,y=rinput()\n      p.append(x+y)\n      mi.append(x-y)\n     p.sort()\n     mi.sort()\n     m=float('inf')\n     for i in range(1,n):\n      if(p[i]-p[i-1]<m):\n       m=p[i]-p[i-1]\n      if(mi[i]-mi[i-1]<m):\n       m=mi[i]-mi[i-1]\n     if m%2==0:\n      print(m//2)\n     else:\n      print(m/2)",
        "inputs": [
            "2\n3\n0 0\n0 1\n0 -1\n3\n0 1\n1 0\n-1 0\n"
        ],
        "outputs": [
            "0.5\n0\n"
        ],
        "starter_code": "\ndef utneb():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                3,
                3
            ],
            [
                "Function Body",
                4,
                4
            ],
            [
                "Function Body",
                5,
                5
            ],
            [
                "Function Body",
                6,
                6
            ],
            [
                "For Loop Body",
                8,
                27
            ],
            [
                "For Loop Body",
                12,
                15
            ],
            [
                "For Loop Body",
                19,
                23
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "If Statement Body",
                24,
                27
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ngFCQ():\n    \"\"\"This problem differs from the previous one only in the absence of the constraint on the equal length of all numbers $a_1, a_2, \\dots, a_n$.\n\nA team of SIS students is going to make a trip on a submarine. Their target is an ancient treasure in a sunken ship lying on the bottom of the Great Rybinsk sea. Unfortunately, the students don't know the coordinates of the ship, so they asked Meshanya (who is a hereditary mage) to help them. He agreed to help them, but only if they solve his problem.\n\nLet's denote a function that alternates digits of two numbers $f(a_1 a_2 \\dots a_{p - 1} a_p, b_1 b_2 \\dots b_{q - 1} b_q)$, where $a_1 \\dots a_p$ and $b_1 \\dots b_q$ are digits of two integers written in the decimal notation without leading zeros.\n\nIn other words, the function $f(x, y)$ alternately shuffles the digits of the numbers $x$ and $y$ by writing them from the lowest digits to the older ones, starting with the number $y$. The result of the function is also built from right to left (that is, from the lower digits to the older ones). If the digits of one of the arguments have ended, then the remaining digits of the other argument are written out. Familiarize with examples and formal definitions of the function below.\n\nFor example: $$f(1111, 2222) = 12121212$$ $$f(7777, 888) = 7787878$$ $$f(33, 44444) = 4443434$$ $$f(555, 6) = 5556$$ $$f(111, 2222) = 2121212$$\n\nFormally,  if $p \\ge q$ then $f(a_1 \\dots a_p, b_1 \\dots b_q) = a_1 a_2 \\dots a_{p - q + 1} b_1 a_{p - q + 2} b_2 \\dots a_{p - 1} b_{q - 1} a_p b_q$;  if $p < q$ then $f(a_1 \\dots a_p, b_1 \\dots b_q) = b_1 b_2 \\dots b_{q - p} a_1 b_{q - p + 1} a_2 \\dots a_{p - 1} b_{q - 1} a_p b_q$. \n\nMishanya gives you an array consisting of $n$ integers $a_i$, your task is to help students to calculate $\\sum_{i = 1}^{n}\\sum_{j = 1}^{n} f(a_i, a_j)$ modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer $n$ ($1 \\le n \\le 100\\,000$) — the number of elements in the array. The second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — the elements of the array.\n\n\n-----Output-----\n\nPrint the answer modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n3\n12 3 45\n\nOutput\n12330\nInput\n2\n123 456\n\nOutput\n1115598\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin, stdout, exit\ndef ngFCQ():\n    mod = 998244353\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ans = 0\n    def l(x):\n        if x == 0:\n            return 0\n        return 1 + l(x//10)\n    lens = [0]*15\n    for x in a:\n        lens[l(x)] += 1\n    def space_out(x, l):\n        ans = []\n        for i,c in enumerate(reversed(str(x))):\n            ans.append(c)\n            if i < l:\n                ans.append(\"0\")\n        return int(''.join(reversed(ans))) \n    for i in range(n):\n        x = a[i]\n        cur_head = x//10\n        cur = x\n        prev = x\n        for l in range(11):\n    #        print(cur, cur_head)\n            if l > 0:\n                ans += lens[l]*(cur+10*prev)#space_out(x,l)\n                ans %= mod\n            prev = cur\n            cur -= cur_head*10**(2*l+1)\n            cur += cur_head*10**(2*l+2)\n            cur_head //=10\n    stdout.write(str(ans) + \"\\n\")",
        "inputs": [
            "3\n12 3 45\n",
            "2\n123 456\n",
            "20\n80 9 55 1 98 29 81 10 96 100 70 87 86 12 58 82 10 22 59 13\n"
        ],
        "outputs": [
            "12330",
            "1115598",
            "2248760"
        ],
        "starter_code": "\ndef ngFCQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "Function Body",
                7,
                10
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "For Loop Body",
                12,
                13
            ],
            [
                "Function Body",
                14,
                20
            ],
            [
                "For Loop Body",
                16,
                19
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "For Loop Body",
                21,
                34
            ],
            [
                "For Loop Body",
                26,
                34
            ],
            [
                "If Statement Body",
                28,
                30
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RirJG():\n    \"\"\"Valera is a collector. Once he wanted to expand his collection with exactly one antique item.\n\nValera knows n sellers of antiques, the i-th of them auctioned k_{i} items. Currently the auction price of the j-th object of the i-th seller is s_{ij}. Valera gets on well with each of the n sellers. He is perfectly sure that if he outbids the current price of one of the items in the auction (in other words, offers the seller the money that is strictly greater than the current price of the item at the auction), the seller of the object will immediately sign a contract with him.\n\nUnfortunately, Valera has only v units of money. Help him to determine which of the n sellers he can make a deal with.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers n, v (1 ≤ n ≤ 50; 10^4 ≤ v ≤ 10^6) — the number of sellers and the units of money the Valera has.\n\nThen n lines follow. The i-th line first contains integer k_{i} (1 ≤ k_{i} ≤ 50) the number of items of the i-th seller. Then go k_{i} space-separated integers s_{i}1, s_{i}2, ..., s_{ik}_{i} (10^4 ≤ s_{ij} ≤ 10^6) — the current prices of the items of the i-th seller. \n\n\n-----Output-----\n\nIn the first line, print integer p — the number of sellers with who Valera can make a deal.\n\nIn the second line print p space-separated integers q_1, q_2, ..., q_{p} (1 ≤ q_{i} ≤ n) — the numbers of the sellers with who Valera can make a deal. Print the numbers of the sellers in the increasing order. \n\n\n-----Examples-----\nInput\n3 50000\n1 40000\n2 20000 60000\n3 10000 70000 190000\n\nOutput\n3\n1 2 3\n\nInput\n3 50000\n1 50000\n3 100000 120000 110000\n3 120000 110000 120000\n\nOutput\n0\n\n\n\n\n-----Note-----\n\nIn the first sample Valera can bargain with each of the sellers. He can outbid the following items: a 40000 item from the first seller, a 20000 item from the second seller, and a 10000 item from the third seller.\n\nIn the second sample Valera can not make a deal with any of the sellers, as the prices of all items in the auction too big for him.\n    \"\"\"\n",
        "canonical_solution": "\ndef RirJG():\n    n, v = map(int, input().split())\n    ans = []\n    for i in range(n):\n        a = list(map(int, input().split()))[1:]\n        if v > min(a):\n            ans.append(i + 1)\n    print(len(ans))\n    print(*ans)",
        "inputs": [
            "3 50000\n1 40000\n2 20000 60000\n3 10000 70000 190000\n",
            "3 50000\n1 50000\n3 100000 120000 110000\n3 120000 110000 120000\n",
            "2 100001\n1 895737\n1 541571\n"
        ],
        "outputs": [
            "3\n1 2 3\n",
            "0\n\n",
            "0\n\n"
        ],
        "starter_code": "\ndef RirJG():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "If Statement Body",
                7,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n    \"\"\"Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.\n \nExample 1:\n\nInput: nums = [1,0,0,0,1,0,0,1], k = 2\nOutput: true\nExplanation: Each of the 1s are at least 2 places away from each other.\n\nExample 2:\n\nInput: nums = [1,0,0,1,0,1], k = 2\nOutput: false\nExplanation: The second 1 and third 1 are only one apart from each other.\nExample 3:\nInput: nums = [1,1,1,1,1], k = 0\nOutput: true\n\nExample 4:\nInput: nums = [0,1,0,1], k = 1\nOutput: true\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= k <= nums.length\nnums[i] is 0 or 1\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        \n        if nums.count(0) == len(nums):\n            return True\n        \n        idx = nums.index(1)\n        ctr = 0\n        for num in nums[idx+1:]:\n            if num == 1:\n                if ctr < k:\n                    return False\n                ctr = 0\n            else:\n                ctr+=1\n                \n        return True\n                \n                \n",
        "inputs": [
            [
                [
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1
                ],
                2
            ]
        ],
        "outputs": [
            [
                true
            ]
        ],
        "starter_code": "\nclass Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                17
            ],
            [
                "Function Body",
                2,
                17
            ],
            [
                "If Statement Body",
                4,
                5
            ],
            [
                "For Loop Body",
                9,
                15
            ],
            [
                "If Statement Body",
                10,
                15
            ],
            [
                "If Statement Body",
                11,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef MpyWj():\n    \"\"\"A permutation of length n is an array containing each integer from 1 to n exactly once. For example, q = [4, 5, 1, 2, 3] is a permutation. For the permutation q the square of permutation is the permutation p that p[i] = q[q[i]] for each i = 1... n. For example, the square of q = [4, 5, 1, 2, 3] is p = q^2 = [2, 3, 4, 5, 1].\n\nThis problem is about the inverse operation: given the permutation p you task is to find such permutation q that q^2 = p. If there are several such q find any of them.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 10^6) — the number of elements in permutation p.\n\nThe second line contains n distinct integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the elements of permutation p.\n\n\n-----Output-----\n\nIf there is no permutation q such that q^2 = p print the number \"-1\".\n\nIf the answer exists print it. The only line should contain n different integers q_{i} (1 ≤ q_{i} ≤ n) — the elements of the permutation q. If there are several solutions print any of them.\n\n\n-----Examples-----\nInput\n4\n2 1 4 3\n\nOutput\n3 4 2 1\n\nInput\n4\n2 1 3 4\n\nOutput\n-1\n\nInput\n5\n2 3 4 5 1\n\nOutput\n4 5 1 2 3\n    \"\"\"\n",
        "canonical_solution": "import math\nimport sys\ndef MpyWj():\n    input = sys.stdin.readline\n    n = int(input())\n    a = [int(_) - 1 for _ in input().split()]\n    vis = [False] * n\n    cycles = [[] for _ in range(n + 1)]\n    for i in range(n):\n        if vis[i]: continue\n        cur = i\n        cycle = []\n        while not vis[cur]:\n            vis[cur] = True\n            cycle.append(cur)\n            cur = a[cur]\n        cycles[len(cycle)].append(cycle)\n    p = [0] * n\n    for i in range(n + 1):\n        if i % 2 == 1:\n            for j in cycles[i]:\n                for k in range(i):\n                    p[j[k]] = j[(k + (i + 1) // 2) % i]\n        else:\n            if len(cycles[i]) % 2 == 1:\n                print(-1)\n                return\n            for j in range(0, len(cycles[i]), 2):\n                for k in range(i):\n                    p[cycles[i][j][k]] = cycles[i][j + 1][k] \n                    p[cycles[i][j + 1][k]] = cycles[i][j][(k + 1) % i]\n    print(' '.join([str(i + 1) for i in p]))",
        "inputs": [
            "4\n2 1 4 3\n",
            "4\n2 1 3 4\n",
            "5\n2 3 4 5 1\n"
        ],
        "outputs": [
            "3 4 2 1\n",
            "-1\n",
            "4 5 1 2 3\n"
        ],
        "starter_code": "\ndef MpyWj():\n",
        "scope": [
            [
                "Function Body",
                3,
                32
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "For Loop Body",
                9,
                17
            ],
            [
                "If Statement Body",
                10,
                10
            ],
            [
                "While Loop Body",
                13,
                16
            ],
            [
                "For Loop Body",
                19,
                31
            ],
            [
                "If Statement Body",
                20,
                31
            ],
            [
                "For Loop Body",
                21,
                23
            ],
            [
                "For Loop Body",
                22,
                23
            ],
            [
                "If Statement Body",
                25,
                27
            ],
            [
                "For Loop Body",
                28,
                31
            ],
            [
                "For Loop Body",
                29,
                31
            ],
            [
                "List Comprehension",
                32,
                32
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef iQBjH():\n    \"\"\"There are n shovels in Polycarp's shop. The i-th shovel costs i burles, that is, the first shovel costs 1 burle, the second shovel costs 2 burles, the third shovel costs 3 burles, and so on. Polycarps wants to sell shovels in pairs.\n\nVisitors are more likely to buy a pair of shovels if their total cost ends with several 9s. Because of this, Polycarp wants to choose a pair of shovels to sell in such a way that the sum of their costs ends with maximum possible number of nines. For example, if he chooses shovels with costs 12345 and 37454, their total cost is 49799, it ends with two nines.\n\nYou are to compute the number of pairs of shovels such that their total cost ends with maximum possible number of nines. Two pairs are considered different if there is a shovel presented in one pair, but not in the other.\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 10^9) — the number of shovels in Polycarp's shop.\n\n\n-----Output-----\n\nPrint the number of pairs of shovels such that their total cost ends with maximum possible number of nines. \n\nNote that it is possible that the largest number of 9s at the end is 0, then you should count all such ways.\n\nIt is guaranteed that for every n ≤ 10^9 the answer doesn't exceed 2·10^9.\n\n\n-----Examples-----\nInput\n7\n\nOutput\n3\n\nInput\n14\n\nOutput\n9\n\nInput\n50\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example the maximum possible number of nines at the end is one. Polycarp cah choose the following pairs of shovels for that purpose:  2 and 7;  3 and 6;  4 and 5. \n\nIn the second example the maximum number of nines at the end of total cost of two shovels is one. The following pairs of shovels suit Polycarp:  1 and 8;  2 and 7;  3 and 6;  4 and 5;  5 and 14;  6 and 13;  7 and 12;  8 and 11;  9 and 10. \n\nIn the third example it is necessary to choose shovels 49 and 50, because the sum of their cost is 99, that means that the total number of nines is equal to two, which is maximum possible for n = 50.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin as cin\nfrom sys import stdout as cout\ndef iQBjH():\n    def main():\n        n = int(cin.readline())\n        o = 0\n        for x in range(9, 0, -1):\n            if 10 ** x // 2 <= n:\n                ##print(x)\n                for i in range(9):\n                    q = 10 ** x * (i + 1) // 2 - 1\n                    if q <= n:\n                        o += min(q, n - q)\n                print(o)\n                return\n        print(n * (n - 1) // 2)\n    main()",
        "inputs": [
            "7\n",
            "14\n",
            "50\n"
        ],
        "outputs": [
            "3\n",
            "9\n",
            "1\n"
        ],
        "starter_code": "\ndef iQBjH():\n",
        "scope": [
            [
                "Function Body",
                3,
                17
            ],
            [
                "Function Body",
                4,
                16
            ],
            [
                "For Loop Body",
                7,
                15
            ],
            [
                "If Statement Body",
                8,
                15
            ],
            [
                "For Loop Body",
                10,
                13
            ],
            [
                "If Statement Body",
                12,
                13
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef DCYGS():\n    \"\"\"Leonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular w mm  ×  h mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.\n\nIn order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.\n\nAfter each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.\n\nLeonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?\n\n\n-----Input-----\n\nThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).\n\nNext n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.\n\n\n-----Output-----\n\nAfter each cut print on a single line the area of the maximum available glass fragment in mm^2.\n\n\n-----Examples-----\nInput\n4 3 4\nH 2\nV 2\nV 3\nV 1\n\nOutput\n8\n4\n4\n2\n\nInput\n7 6 5\nH 4\nV 3\nV 5\nH 2\nV 1\n\nOutput\n28\n16\n12\n6\n4\n\n\n\n-----Note-----\n\nPicture for the first sample test:  [Image]  Picture for the second sample test:  $\\square$\n    \"\"\"\n",
        "canonical_solution": "\ndef DCYGS():\n    def main():\n        w, h, n = list(map(int, input().split()))\n        res, vrt, hor = [], [], []\n        vh = (vrt, hor)\n        for i in range(n):\n            s = input()\n            x = int(s[2:])\n            flag = s[0] == 'V'\n            vh[flag].append(i)\n            res.append([x, flag])\n        dim = []\n        for tmp, m in zip(vh, (h, w)):\n            tmp.sort(key=lambda e: res[e][0])\n            u = [None, [0]]\n            dim.append(u)\n            j = z = 0\n            for i in tmp:\n                x = res[i][0]\n                if z < x - j:\n                    z = x - j\n                j = x\n                v = [u, res[i]]\n                u.append(v)\n                u = v\n                res[i].append(u)\n            v = [u, [m], None]\n            u.append(v)\n            dim.append(v)\n            if z < m - j:\n                z = m - j\n            dim.append(z)\n        l, r, wmax, u, d, hmax = dim\n        whmax = [wmax, hmax]\n        for i in range(n - 1, -1, -1):\n            x, flag, link = res[i]\n            u = whmax[flag]\n            res[i] = u * whmax[not flag]\n            link[0][2] = link[2]\n            link[2][0] = link[0]\n            v = link[2][1][0] - link[0][1][0]\n            if u < v:\n                whmax[flag] = v\n        print('\\n'.join(map(str, res)))\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "4 3 4\nH 2\nV 2\nV 3\nV 1\n",
            "7 6 5\nH 4\nV 3\nV 5\nH 2\nV 1\n",
            "2 2 1\nV 1\n"
        ],
        "outputs": [
            "8\n4\n4\n2\n",
            "28\n16\n12\n6\n4\n",
            "2\n"
        ],
        "starter_code": "\ndef DCYGS():\n",
        "scope": [
            [
                "Function Body",
                2,
                51
            ],
            [
                "Function Body",
                3,
                45
            ],
            [
                "For Loop Body",
                7,
                12
            ],
            [
                "For Loop Body",
                14,
                33
            ],
            [
                "Lambda Expression",
                15,
                15
            ],
            [
                "For Loop Body",
                19,
                27
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "If Statement Body",
                31,
                32
            ],
            [
                "For Loop Body",
                36,
                44
            ],
            [
                "If Statement Body",
                43,
                44
            ],
            [
                "Function Body",
                48,
                49
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef TqFyh():\n    \"\"\"Array of integers is unimodal, if:\n\n  it is strictly increasing in the beginning;  after that it is constant;  after that it is strictly decreasing. \n\nThe first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.\n\nFor example, the following three arrays are unimodal: [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], but the following three are not unimodal: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6].\n\nWrite a program that checks if an array is unimodal.\n\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 100) — the number of elements in the array.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1 000) — the elements of the array.\n\n\n-----Output-----\n\nPrint \"YES\" if the given array is unimodal. Otherwise, print \"NO\".\n\nYou can output each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n6\n1 5 5 5 4 2\n\nOutput\nYES\n\nInput\n5\n10 20 30 20 10\n\nOutput\nYES\n\nInput\n4\n1 2 1 2\n\nOutput\nNO\n\nInput\n7\n3 3 3 3 3 3 3\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).\n    \"\"\"\n",
        "canonical_solution": "\ndef TqFyh():\n    n = int(input())\n    L = list(map(int, input().split()))\n    i = 0\n    a = 0\n    while i < n and L[i] > a:\n        a = L[i]\n        i += 1\n    while i < n and L[i] == a:\n        i += 1\n    while i < n and L[i] < a:\n        a = L[i]\n        i += 1\n    if i == n:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    ",
        "inputs": [
            "6\n1 5 5 5 4 2\n",
            "5\n10 20 30 20 10\n",
            "4\n1 2 1 2\n"
        ],
        "outputs": [
            "YES\n",
            "YES\n",
            "NO\n"
        ],
        "starter_code": "\ndef TqFyh():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "While Loop Body",
                7,
                9
            ],
            [
                "While Loop Body",
                10,
                11
            ],
            [
                "While Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                15,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef oTzay():\n    \"\"\"One evening Rainbow Dash and Fluttershy have come up with a game. Since the ponies are friends, they have decided not to compete in the game but to pursue a common goal. \n\nThe game starts on a square flat grid, which initially has the outline borders built up. Rainbow Dash and Fluttershy have flat square blocks with size $1\\times1$, Rainbow Dash has an infinite amount of light blue blocks, Fluttershy has an infinite amount of yellow blocks. \n\nThe blocks are placed according to the following rule: each newly placed block must touch the built on the previous turns figure by a side (note that the outline borders of the grid are built initially). At each turn, one pony can place any number of blocks of her color according to the game rules.\n\nRainbow and Fluttershy have found out that they can build patterns on the grid of the game that way. They have decided to start with something simple, so they made up their mind to place the blocks to form a chess coloring. Rainbow Dash is well-known for her speed, so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring, covering the whole grid with blocks. Please help her find that number!\n\nSince the ponies can play many times on different boards, Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games.\n\nThe chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors.\n\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 100$): the number of grids of the games. \n\nEach of the next $T$ lines contains a single integer $n$ ($1 \\le n \\le 10^9$): the size of the side of the grid of the game. \n\n\n-----Output-----\n\nFor each grid of the game print the minimum number of turns required to build a chess coloring pattern out of blocks on it.\n\n\n-----Example-----\nInput\n2\n3\n4\n\nOutput\n2\n3\n\n\n\n-----Note-----\n\nFor $3\\times3$ grid ponies can make two following moves: [Image]\n    \"\"\"\n",
        "canonical_solution": "\ndef oTzay():\n    for _ in range(int(input())):\n        n = int(input())\n        print(n // 2 + 1)\n    ",
        "inputs": [
            "2\n3\n4\n",
            "1\n10000001\n",
            "1\n69\n"
        ],
        "outputs": [
            "2\n3\n",
            "5000001\n",
            "35\n"
        ],
        "starter_code": "\ndef oTzay():\n",
        "scope": [
            [
                "Function Body",
                2,
                5
            ],
            [
                "For Loop Body",
                3,
                5
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RFyNv():\n    \"\"\"Mr. Kitayuta has kindly given you a string s consisting of lowercase English letters. You are asked to insert exactly one lowercase English letter into s to make it a palindrome. A palindrome is a string that reads the same forward and backward. For example, \"noon\", \"testset\" and \"a\" are all palindromes, while \"test\" and \"kitayuta\" are not.\n\nYou can choose any lowercase English letter, and insert it to any position of s, possibly to the beginning or the end of s. You have to insert a letter even if the given string is already a palindrome.\n\nIf it is possible to insert one lowercase English letter into s so that the resulting string will be a palindrome, print the string after the insertion. Otherwise, print \"NA\" (without quotes, case-sensitive). In case there is more than one palindrome that can be obtained, you are allowed to print any of them.\n\n\n-----Input-----\n\nThe only line of the input contains a string s (1 ≤ |s| ≤ 10). Each character in s is a lowercase English letter.\n\n\n-----Output-----\n\nIf it is possible to turn s into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print \"NA\" (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted. \n\n\n-----Examples-----\nInput\nrevive\n\nOutput\nreviver\n\nInput\nee\n\nOutput\neye\nInput\nkitayuta\n\nOutput\nNA\n\n\n\n-----Note-----\n\nFor the first sample, insert 'r' to the end of \"revive\" to obtain a palindrome \"reviver\".\n\nFor the second sample, there is more than one solution. For example, \"eve\" will also be accepted.\n\nFor the third sample, it is not possible to turn \"kitayuta\" into a palindrome by just inserting one letter.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef RFyNv():\n    s = input().strip()\n    def isPalin(n):\n        if n[::-1] == n:\n            return True\n        return False\n    for i in range(len(s)+1):\n        for j in \"abcdefghijklmnopqrstuvwxyz\":\n            if isPalin(s[:i] + j + s[i:]):\n                print(s[:i] + j + s[i:])\n                return\n    print(\"NA\")",
        "inputs": [
            "revive\n",
            "ee\n",
            "kitayuta\n"
        ],
        "outputs": [
            "reviver\n",
            "eee\n",
            "NA\n"
        ],
        "starter_code": "\ndef RFyNv():\n",
        "scope": [
            [
                "Function Body",
                2,
                13
            ],
            [
                "Function Body",
                4,
                7
            ],
            [
                "If Statement Body",
                5,
                6
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef sxtpY():\n    \"\"\"Two positive integers a and b have a sum of s and a bitwise XOR of x. How many possible values are there for the ordered pair (a, b)?\n\n\n-----Input-----\n\nThe first line of the input contains two integers s and x (2 ≤ s ≤ 10^12, 0 ≤ x ≤ 10^12), the sum and bitwise xor of the pair of positive integers, respectively.\n\n\n-----Output-----\n\nPrint a single integer, the number of solutions to the given conditions. If no solutions exist, print 0.\n\n\n-----Examples-----\nInput\n9 5\n\nOutput\n4\n\nInput\n3 3\n\nOutput\n2\n\nInput\n5 2\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample, we have the following solutions: (2, 7), (3, 6), (6, 3), (7, 2).\n\nIn the second sample, the only solutions are (1, 2) and (2, 1).\n    \"\"\"\n",
        "canonical_solution": "\ndef sxtpY():\n    s, x = list(map(int, input().split()))\n    rem = int(s == x) * 2\n    p, t, cur = [], 0, 1\n    for i in range(64):\n        if x % 2:\n            t += 1\n            s -= cur\n        else:\n            p.append(cur * 2)\n        cur *= 2\n        x //= 2\n    for i in p[::-1]:\n        if s >= i: s -= i\n    ans = 0 if s else 2 ** t - rem\n    print(ans)\n    ",
        "inputs": [
            "9 5\n",
            "3 3\n",
            "5 2\n"
        ],
        "outputs": [
            "4\n",
            "2\n",
            "0\n"
        ],
        "starter_code": "\ndef sxtpY():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "For Loop Body",
                6,
                13
            ],
            [
                "If Statement Body",
                7,
                11
            ],
            [
                "For Loop Body",
                14,
                15
            ],
            [
                "If Statement Body",
                15,
                15
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef iwDPC():\n    \"\"\"ZCO is approaching, and you want to be well prepared!  \nThere are $N$ topics to cover and the $i^{th}$ topic takes $H_i$ hours to prepare (where $1 \\le i \\le N$). You have only $M$ days left to prepare, and you want to utilise this time wisely. You know that you can't spend more than $S$ hours in a day preparing, as you get tired after that. You don't want to study more than one topic in a day, and also, don't want to spend more than two days on any topic, as you feel that this is inefficient.  \nGiven these constraints, can you find the maximum number of topics you can prepare, if you choose the topics wisely?\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- The first line of each test case contains three space-separated integers: $N$, $M$ and $S$, denoting the number of topics, the number of days remaining and the number of hours you can study in a day.  \n- The second line of each test case contains $N$ space-separated integers $H_i$, denoting the number of hours needed to prepare for the $i^{th}$ topic.\n\n-----Output:-----\nFor each testcase, output in a single line: the maximum number of topics you can prepare.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq M \\leq 10^5$\n- $1 \\leq S \\leq 16$\n- $1 \\leq H_i \\leq 50$\n\n-----Subtasks-----\n- 30 points : Every topic takes the same number of hours to prepare (i.e. all $H_i$ are equal).\n- 70 points : Original constraints.\n\n-----Sample Input:-----\n2\n5 4 10\n10 24 30 19 40\n5 4 16\n7 16 35 10 15\n\n-----Sample Output:-----\n2\n4\n\n-----Explanation:-----\nTestcase 1:\n\nYou can choose topics $1$ and $4$. Topic $1$ will consume a single day , while topic $4$ will consume two days.  Thus, you'll be able to prepare these two topics within the 4 remaining days. But you can check that you cannot do any better.\nTestcase 2:\n\nYou can choose topics $1$, $2$, $4$, and $5$. Each of them will consume one day each. Thus you'll be able to cover $4$ topics.\n    \"\"\"\n",
        "canonical_solution": "import math\ndef iwDPC():\n    T=int(input())\n    for i in range(T):\n     N,M,S=input().split()\n     N=int(N)\n     M=int(M)\n     S=int(S)\n     ls=list(map(int,input().split()))\n     maxx=max(ls)\n     if S<17 and maxx<=50:\n      ls.sort()\n      total_sum = M * S\n      count = 0\n      sum = 0\n      for i in ls:\n       if i / S > 2:\n        continue\n       else:\n        sum = sum + math.ceil(i / S) * S\n        if sum <= total_sum:\n         count = count + 1\n      print(count)\n    # cook your dish here",
        "inputs": [
            "2\n5 4 10\n10 24 30 19 40\n5 4 16\n7 16 35 10 15\n"
        ],
        "outputs": [
            "2\n4\n"
        ],
        "starter_code": "\ndef iwDPC():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "For Loop Body",
                4,
                23
            ],
            [
                "If Statement Body",
                11,
                23
            ],
            [
                "For Loop Body",
                16,
                22
            ],
            [
                "If Statement Body",
                17,
                22
            ],
            [
                "If Statement Body",
                21,
                22
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef SWMvC():\n    \"\"\"Mr. Wire Less is not that good at implementing circuit in a breadboard. In his Digital Logic Design course, he has to implement several boolean functions using the breadboard. In a breadboard, inputs are given through the switches and outputs are taken through the LEDs. Each input switch can be either in ground state or in high state. So, if he wishes to implement a boolean function, f(x1, x2, .., xn) that takes n boolean values as input and returns m boolean values as output, he will use n switches and m LEDs. \nMr. Wire Less can quickly assemble the necessary ICs and wires, but the key problem is testing. While testing he has to check with all possible input combination, to make sure whether the output of LED corresponds to the expected output or not. This is taking too long for him, as most of the switches are jammed and difficult to toggle. \nMr. Wire Less is asking for help to minimize his time of testing. So, your task is to minimize the total number of switch-toggle throughout the testing.\nFor example, if Mr. Wire Less has to test a function f(x0, x1) of two variables, he may choose this switching-sequence for testing 00, 11, 10, 01. In this case, the total number of switch-toggle will be 2+1+2 = 5. But if he tests in this sequence 00, 10, 11, 01 total number of toggle will be 1+1+1 = 3.\nGiven n, you have to output the minimum number of toggle needed for complete testing. Though it seems impractical, he wants you to solve the problem for a very large value of n. But, then the toggle value can be quite big. So, he is completely okay with the toggle value modulo 8589934592 (233).  \n\n-----Input-----\nThe first line of the input contains a positive integer T(T ≤ 105), denoting the number of test-case. Each of the following T lines contains a single non-negative integer n(n ≤ 1020).\n\n-----Output-----\nFor every test-case, output a single containing test-case number and the minimum number of switch-toggle modulo 8589934592 (233).\n\n-----Sample----- \nInput   \n2\n1\n2\n\nOutput\nCase 1: 1\nCase 2: 3\n    \"\"\"\n",
        "canonical_solution": "\ndef SWMvC():\n    # cook your dish here\n    mod=8589934592\n    list1=[]\n    for i in range(int(input())):\n        x=int(input())\n        ans=(pow(2,x,mod)-1)%mod\n        list1.append((i+1,ans))\n    for i in list1:\n        print(f'Case {i[0]}: {i[1]}')",
        "inputs": [
            "2\n1\n2\n\n\n"
        ],
        "outputs": [
            "Case 1: 1\nCase 2: 3\n"
        ],
        "starter_code": "\ndef SWMvC():\n",
        "scope": [
            [
                "Function Body",
                2,
                11
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "For Loop Body",
                10,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef KYxZn():\n    \"\"\"You are given a string $s=s_1s_2\\dots s_n$ of length $n$, which only contains digits $1$, $2$, ..., $9$.\n\nA substring $s[l \\dots r]$ of $s$ is a string $s_l s_{l + 1} s_{l + 2} \\ldots s_r$. A substring $s[l \\dots r]$ of $s$ is called even if the number represented by it is even. \n\nFind the number of even substrings of $s$. Note, that even if some substrings are equal as strings, but have different $l$ and $r$, they are counted as different substrings.\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 65000$) — the length of the string $s$.\n\nThe second line contains a string $s$ of length $n$. The string $s$ consists only of digits $1$, $2$, ..., $9$.\n\n\n-----Output-----\n\nPrint the number of even substrings of $s$.\n\n\n-----Examples-----\nInput\n4\n1234\n\nOutput\n6\nInput\n4\n2244\n\nOutput\n10\n\n\n-----Note-----\n\nIn the first example, the $[l, r]$ pairs corresponding to even substrings are:   $s[1 \\dots 2]$\n\n $s[2 \\dots 2]$\n\n $s[1 \\dots 4]$\n\n $s[2 \\dots 4]$\n\n $s[3 \\dots 4]$\n\n $s[4 \\dots 4]$ \n\nIn the second example, all $10$ substrings of $s$ are even substrings. Note, that while substrings $s[1 \\dots 1]$ and $s[2 \\dots 2]$ both define the substring \"2\", they are still counted as different substrings.\n    \"\"\"\n",
        "canonical_solution": "\ndef KYxZn():\n    n = int(input())\n    s = input()\n    r = 0\n    for i in range(n):\n        if s[i] in '2468':\n            r += i + 1\n    print(r)",
        "inputs": [
            "4\n1234\n",
            "4\n2244\n",
            "1\n3\n"
        ],
        "outputs": [
            "6",
            "10",
            "0"
        ],
        "starter_code": "\ndef KYxZn():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "If Statement Body",
                7,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef SaCcO():\n    \"\"\"Given an array A of length N, your task is to find the element which repeats in A maximum number of times as well as the corresponding count. In case of ties, choose the smaller element first.\n\n-----Input-----\nFirst line of input contains an integer T, denoting the number of test cases. Then follows description of T cases. Each case begins with a single integer N, the length of A. Then follow N space separated integers in next line.  Assume that 1 <= T <= 100, 1 <= N <= 100 and for all i in [1..N] : 1 <= A[i] <= 10000\n\n-----Output-----\nFor each test case, output two space separated integers V & C. V is the value which occurs maximum number of times and C is its count.\n\n-----Example-----\nInput:\n2\n5\n1 2 3 2 5\n6\n1 2 2 1 1 2\n\nOutput:\n2 2\n1 3\n\nDescription:\nIn first case 2 occurs twice whereas all other elements occur only once. \nIn second case, both 1 and 2 occur 3 times but 1 is smaller than 2.\n    \"\"\"\n",
        "canonical_solution": "\ndef SaCcO():\n    t = input();\n    \n    a = [0 for i in range(10001)]\n    \n    i = 0;\n    \n    while i < int(t):\n    \n    \tn = input();\n    \n    \tk = input();\n    \n    \tassert(len(k.split(' ')) == int(n));\n    \n    \tfor each in k.split(' '):\n    \n    \t\ta[int(each)] += 1;\n    \n    \n    \tV = 0;\n    \n    \tC = a[V];\n    \n    \tfor j in range(10001):\n    \n    \t\tif C < a[j]:\n    \n    \t\t\tV = j;\n    \n    \t\t\tC = a[V];\n    \n    \t\ta[j] = 0;\n    \n    \ti += 1;\n    \n    \tprint(V, C);\n    ",
        "inputs": [
            "2\n5\n1 2 3 2 5\n6\n1 2 2 1 1 2\n\n\n"
        ],
        "outputs": [
            "2 2\n1 3\n"
        ],
        "starter_code": "\ndef SaCcO():\n",
        "scope": [
            [
                "Function Body",
                2,
                38
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "While Loop Body",
                9,
                38
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "For Loop Body",
                26,
                34
            ],
            [
                "If Statement Body",
                28,
                32
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef NrZRg():\n    \"\"\"There are n cities in Bearland, numbered 1 through n. Cities are arranged in one long row. The distance between cities i and j is equal to |i - j|.\n\nLimak is a police officer. He lives in a city a. His job is to catch criminals. It's hard because he doesn't know in which cities criminals are. Though, he knows that there is at most one criminal in each city.\n\nLimak is going to use a BCD (Bear Criminal Detector). The BCD will tell Limak how many criminals there are for every distance from a city a. After that, Limak can catch a criminal in each city for which he is sure that there must be a criminal.\n\nYou know in which cities criminals are. Count the number of criminals Limak will catch, after he uses the BCD.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and a (1 ≤ a ≤ n ≤ 100) — the number of cities and the index of city where Limak lives.\n\nThe second line contains n integers t_1, t_2, ..., t_{n} (0 ≤ t_{i} ≤ 1). There are t_{i} criminals in the i-th city.\n\n\n-----Output-----\n\nPrint the number of criminals Limak will catch.\n\n\n-----Examples-----\nInput\n6 3\n1 1 1 0 1 0\n\nOutput\n3\n\nInput\n5 2\n0 0 0 1 0\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first sample, there are six cities and Limak lives in the third one (blue arrow below). Criminals are in cities marked red.\n\n [Image] \n\nUsing the BCD gives Limak the following information:\n\n  There is one criminal at distance 0 from the third city — Limak is sure that this criminal is exactly in the third city.  There is one criminal at distance 1 from the third city — Limak doesn't know if a criminal is in the second or fourth city.  There are two criminals at distance 2 from the third city — Limak is sure that there is one criminal in the first city and one in the fifth city.  There are zero criminals for every greater distance. \n\nSo, Limak will catch criminals in cities 1, 3 and 5, that is 3 criminals in total.\n\nIn the second sample (drawing below), the BCD gives Limak the information that there is one criminal at distance 2 from Limak's city. There is only one city at distance 2 so Limak is sure where a criminal is.\n\n [Image]\n    \"\"\"\n",
        "canonical_solution": "\ndef NrZRg():\n    n, a = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    \n    a -= 1\n    \n    result = x[a]\n    \n    for i in range(1, n + 1):\n        le = a - i\n        rg = a + i\n    \n        le_i = le >= 0 and le < n\n        rg_i = rg >= 0 and rg < n\n        if not le_i and not rg_i:\n            break\n    \n        if le_i and not rg_i:\n            result += x[le]\n        elif not le_i and rg_i:\n            result += x[rg]\n        else:\n            if x[le] == x[rg] == 1:\n                result += 2\n    \n    print(result)\n    ",
        "inputs": [
            "6 3\n1 1 1 0 1 0\n",
            "5 2\n0 0 0 1 0\n",
            "1 1\n1\n"
        ],
        "outputs": [
            "3\n",
            "1\n",
            "1\n"
        ],
        "starter_code": "\ndef NrZRg():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "For Loop Body",
                10,
                25
            ],
            [
                "If Statement Body",
                16,
                17
            ],
            [
                "If Statement Body",
                19,
                25
            ],
            [
                "If Statement Body",
                21,
                25
            ],
            [
                "If Statement Body",
                24,
                25
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef OITDm():\n    \"\"\"Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. \n\nThe beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: \n\n\"May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!\"\n\nDistinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.\n\n\n-----Input-----\n\nThe single line contains the magic integer n, 0 ≤ n.\n\n  to get 20 points, you need to solve the problem with constraints: n ≤ 10^6 (subproblem C1);  to get 40 points, you need to solve the problem with constraints: n ≤ 10^12 (subproblems C1+C2);  to get 100 points, you need to solve the problem with constraints: n ≤ 10^18 (subproblems C1+C2+C3). \n\n\n-----Output-----\n\nPrint a single integer — the minimum number of subtractions that turns the magic number to a zero.\n\n\n-----Examples-----\nInput\n24\n\nOutput\n5\n\n\n-----Note-----\n\nIn the first test sample the minimum number of operations can be reached by the following sequence of subtractions: \n\n 24 → 20 → 18 → 10 → 9 → 0\n    \"\"\"\n",
        "canonical_solution": "\ndef OITDm():\n    start = input()\n    counter = 0\n    sInt = int(start)\n    while sInt!=0:\n    \tsInt-=max([int(c) for c in start])\n    \tstart=str(sInt)\n    \tcounter+=1\n    print(counter)",
        "inputs": [
            "24\n",
            "0\n",
            "3\n"
        ],
        "outputs": [
            "5",
            "0",
            "1"
        ],
        "starter_code": "\ndef OITDm():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "While Loop Body",
                6,
                9
            ],
            [
                "List Comprehension",
                7,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef HGUji():\n    \"\"\"You are given a string S of length N consisting of ( and ). Your task is to insert some number of ( and ) into S to obtain a correct bracket sequence.\n\nHere, a correct bracket sequence is defined as follows:  \n - () is a correct bracket sequence.\n - If X is a correct bracket sequence, the concatenation of (, X and ) in this order is also a correct bracket sequence.\n - If X and Y are correct bracket sequences, the concatenation of X and Y in this order is also a correct bracket sequence.\n - Every correct bracket sequence can be derived from the rules above.\nFind the shortest correct bracket sequence that can be obtained. If there is more than one such sequence, find the lexicographically smallest one.\n\n-----Constraints-----\n - The length of S is N.\n - 1 ≤ N ≤ 100\n - S consists of ( and ).\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nS\n\n-----Output-----\nPrint the lexicographically smallest string among the shortest correct bracket sequences that can be obtained by inserting some number of ( and ) into S.\n\n-----Sample Input-----\n3\n())\n\n-----Sample Output-----\n(())\n\n    \"\"\"\n",
        "canonical_solution": "\ndef HGUji():\n    n=int(input())\n    S=input()\n    x=y=0\n    for i,s in enumerate(S):\n      y=y-1 if s=='(' else y+1\n      x=max(x,y)\n    print('('*x+S+')'*(x-y))",
        "inputs": [
            "3\n())\n",
            "6\n)))())\n",
            "8\n))))((((\n"
        ],
        "outputs": [
            "(())\n",
            "(((()))())\n",
            "(((())))(((())))\n"
        ],
        "starter_code": "\ndef HGUji():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                6,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GnHlK():\n    \"\"\"Once N boys and M girls attended a party. You are given a matrix A of N rows and M columns where Aij is 1 if the i-th boy likes the j-th girl, otherwise it will be 0. Note that it is not necessary that if a boy x likes girl y, then girl y should like boy x.\nYou know that if there are two different boys x and y, who both like girl z, then there will be a collision.\nCan you calculate the number of different collisions at this party? Note that order of boys in the collision doesn't matter.\n\n-----Input-----\nThe first line contains a single integer T denoting the number of test cases. Then T test cases follow.\nThe first line of each test case contains two space separated integers N, M denoting the number of boys and girls, respectively.\nEach of the following N lines contain M characters, each of them is either '0' or '1'.\n\n-----Output-----\nFor each test case output a single line containing an integer corresponding to the number of collisions at the party.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M ≤ 10\n\n-----Example-----\nInput:\n2\n4 3\n111\n100\n110\n000\n2 2\n10\n01\n\nOutput:\n4\n0\n\n-----Explanation-----\nExample Case 1. All three boys like the first girl, so there are (1, 2, 1), (1, 3, 1), (2, 3, 1) collisions with her. Boys 1 and 3 both like the second girl so this is one more collision. Only one boy likes the third girl, so there are no collisions with her and thus we have 4 collisions total.\nExample Case 2. For each girl there is only one boy who likes her, so there are no collisions at all.\n    \"\"\"\n",
        "canonical_solution": "\ndef GnHlK():\n    for i in range(int(input())):\n     n,k=map(int,input().split())\n     m=[]\n     for j in range(n):\n      l=list(input())\n      m.append(l)\n     a=0\n     for k in range(k):\n      b=0\n      for p in range(n):\n       if m[p][k]=='1':\n        b+=1\n      if b>1:\n       a+=((b*(b-1))//2)\n     print(a)",
        "inputs": [
            "2\n4 3\n111\n100\n110\n000\n2 2\n10\n01\n"
        ],
        "outputs": [
            "4\n0\n"
        ],
        "starter_code": "\ndef GnHlK():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "For Loop Body",
                3,
                17
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "For Loop Body",
                10,
                16
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef nNWsr():\n    \"\"\"Imagine a city with n horizontal streets crossing m vertical streets, forming an (n - 1) × (m - 1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.\n\n [Image] \n\nThe mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.\n\n\n-----Input-----\n\nThe first line of input contains two integers n and m, (2 ≤ n, m ≤ 20), denoting the number of horizontal streets and the number of vertical streets.\n\nThe second line contains a string of length n, made of characters '<' and '>', denoting direction of each horizontal street. If the i-th character is equal to '<', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.\n\nThe third line contains a string of length m, made of characters '^' and 'v', denoting direction of each vertical street. If the i-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.\n\n\n-----Output-----\n\nIf the given pattern meets the mayor's criteria, print a single line containing \"YES\", otherwise print a single line containing \"NO\".\n\n\n-----Examples-----\nInput\n3 3\n><>\nv^v\n\nOutput\nNO\n\nInput\n4 6\n<><>\nv^v^v^\n\nOutput\nYES\n\n\n\n-----Note-----\n\nThe figure above shows street directions in the second sample test case.\n    \"\"\"\n",
        "canonical_solution": "\ndef nNWsr():\n    a, b = list(map(int, input().split(' ')))\n    hor = input()\n    ver = input()\n    if (hor[0], ver[0]) == ('>', 'v') or (hor[0], ver[-1]) == ('<', 'v'):\n        print(\"NO\")\n    elif (hor[-1], ver[0]) == ('>', '^') or (hor[-1], ver[-1]) == ('<', '^'):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n    ",
        "inputs": [
            "3 3\n><>\nv^v\n",
            "4 6\n<><>\nv^v^v^\n",
            "2 2\n<>\nv^\n"
        ],
        "outputs": [
            "NO\n",
            "YES\n",
            "YES\n"
        ],
        "starter_code": "\ndef nNWsr():\n",
        "scope": [
            [
                "Function Body",
                2,
                11
            ],
            [
                "If Statement Body",
                6,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wcUbG():\n    \"\"\"Your friend has n cards.\n\nYou know that each card has a lowercase English letter on one side and a digit on the other.\n\nCurrently, your friend has laid out the cards on a table so only one side of each card is visible.\n\nYou would like to know if the following statement is true for cards that your friend owns: \"If a card has a vowel on one side, then it has an even digit on the other side.\" More specifically, a vowel is one of 'a', 'e', 'i', 'o' or 'u', and even digit is one of '0', '2', '4', '6' or '8'.\n\nFor example, if a card has 'a' on one side, and '6' on the other side, then this statement is true for it. Also, the statement is true, for example, for a card with 'b' and '4', and for a card with 'b' and '3' (since the letter is not a vowel). The statement is false, for example, for card with 'e' and '5'. You are interested if the statement is true for all cards. In particular, if no card has a vowel, the statement is true.\n\nTo determine this, you can flip over some cards to reveal the other side. You would like to know what is the minimum number of cards you need to flip in the worst case in order to verify that the statement is true.\n\n\n-----Input-----\n\nThe first and only line of input will contain a string s (1 ≤ |s| ≤ 50), denoting the sides of the cards that you can see on the table currently. Each character of s is either a lowercase English letter or a digit.\n\n\n-----Output-----\n\nPrint a single integer, the minimum number of cards you must turn over to verify your claim.\n\n\n-----Examples-----\nInput\nee\n\nOutput\n2\n\nInput\nz\n\nOutput\n0\n\nInput\n0ay1\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, we must turn over both cards. Note that even though both cards have the same letter, they could possibly have different numbers on the other side.\n\nIn the second sample, we don't need to turn over any cards. The statement is vacuously true, since you know your friend has no cards with a vowel on them.\n\nIn the third sample, we need to flip the second and fourth cards.\n    \"\"\"\n",
        "canonical_solution": "\ndef wcUbG():\n    x = input()\n    c = 0\n    for i in x:\n    \tif i in \"aeiou13579\":\n    \t\tc+=1\n    print(c)\n    ",
        "inputs": [
            "ee\n",
            "z\n",
            "0ay1\n"
        ],
        "outputs": [
            "2\n",
            "0\n",
            "2\n"
        ],
        "starter_code": "\ndef wcUbG():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "If Statement Body",
                6,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef yZAXg():\n    \"\"\"Chefland is a grid with N$N$ rows and M$M$ columns. Each cell of this grid is either empty or contains a house. The distance between a pair of houses is the Manhattan distance between the cells containing them.\nFor each d$d$ between 1$1$ and N+M−2$N+M-2$ inclusive, Chef wants to calculate the number of unordered pairs of distinct houses with distance equal to d$d$. Please help him!\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and M$M$.\n- N$N$ lines follow. For each i$i$ (1≤i≤N$1 \\le i \\le N$), the i$i$-th of these lines contains a binary string with length M$M$; for each j$j$ (1≤j≤M$1 \\le j \\le M$), the j$j$-th character of this string is '1' if the cell in the i$i$-th row and j$j$-th column contains a house or '0' if it is empty.\n\n-----Output-----\nFor each test case, print a single line containing N+M−2$N+M-2$ space-separated integers. For each valid i$i$, the i$i$-th integer should denote the number of pairs with distance i$i$.\n\n-----Constraints-----\n- 1≤T≤3$1 \\le T \\le 3$\n- 2≤N,M≤300$2 \\le N, M \\le 300$\n\n-----Subtasks-----\nSubtask #1 (50 points): N,M≤50$N, M \\le 50$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n1\n3 4\n0011\n0000\n0100\n\n-----Example Output-----\n1 0 1 1 0\n    \"\"\"\n",
        "canonical_solution": "\ndef yZAXg():\n    # cook your dish here\n    for a in range(int(input())):\n        N,M=map(int,input().split())\n        b=[]\n        for o in range(N):\n         b.append(input())\n        c=[]\n        for d in b:\n         f=[]\n         for e in range(len(d)):\n          if d[e]=='1':\n           f.append(e)\n         c.append(f)\n        i=[]\n        for g in range(len(c)):\n         for h in range(len(c[g])):\n          for j in range(len(c)):\n           for k in range(len(c[j])):\n            if (j>g) or(j==g and k>h):\n             if c[g][h]-c[j][k]>=0:\n              i.append(c[g][h]-c[j][k]+j-g)\n             else:\n              i.append(-1*(c[g][h]-c[j][k])+j-g)\n        l=[m for m in range(1,N+M-1)]\n        for n in l:\n         print(i.count(n),end=' ')",
        "inputs": [
            "1\n3 4\n0011\n0000\n0100\n"
        ],
        "outputs": [
            "1 0 1 1 0\n"
        ],
        "starter_code": "\ndef yZAXg():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "For Loop Body",
                4,
                28
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "For Loop Body",
                10,
                15
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "For Loop Body",
                17,
                25
            ],
            [
                "For Loop Body",
                18,
                25
            ],
            [
                "For Loop Body",
                19,
                25
            ],
            [
                "For Loop Body",
                20,
                25
            ],
            [
                "If Statement Body",
                21,
                25
            ],
            [
                "If Statement Body",
                22,
                25
            ],
            [
                "List Comprehension",
                26,
                26
            ],
            [
                "For Loop Body",
                27,
                28
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef BfItw():\n    \"\"\"The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.\n\nThe city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with n other locations, the i-th one has coordinates (x_{i}, y_{i}) with the population of k_{i} people. You can widen the city boundaries to a circle of radius r. In such case all locations inside the circle and on its border are included into the city.\n\nYour goal is to write a program that will determine the minimum radius r, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and s (1 ≤ n ≤ 10^3; 1 ≤ s < 10^6) — the number of locatons around Tomsk city and the population of the city. Then n lines follow. The i-th line contains three integers — the x_{i} and y_{i} coordinate values of the i-th location and the number k_{i} of people in it (1 ≤ k_{i} < 10^6). Each coordinate is an integer and doesn't exceed 10^4 in its absolute value.\n\nIt is guaranteed that no two locations are at the same point and no location is at point (0; 0).\n\n\n-----Output-----\n\nIn the output, print \"-1\" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.\n\nThe answer is considered correct if the absolute or relative error don't exceed 10^{ - 6}.\n\n\n-----Examples-----\nInput\n4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n\nOutput\n2.8284271\n\nInput\n4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n\nOutput\n1.4142136\n\nInput\n2 1\n1 1 999997\n2 2 1\n\nOutput\n-1\n    \"\"\"\n",
        "canonical_solution": "\ndef BfItw():\n    n, s = map(int, input().split())\n    c = []\n    for i in range(n):\n        x, y, z = map(int, input().split())\n        c.append((x, y, z))\n    minans = 10**20\n    for i in range(n):\n        nc = 0\n        total = s\n        for j in range(n):\n            if c[j][0] ** 2 + c[j][1] ** 2 <= c[i][0] ** 2 + c[i][1] ** 2:\n                total += c[j][2]\n        if total >= 10**6 and c[i][0] ** 2 + c[i][1] ** 2 < minans:\n            minans = c[i][0] ** 2 + c[i][1] ** 2\n    if minans != 10**20:\n        print(minans ** 0.5)\n    else:\n        print(-1)",
        "inputs": [
            "4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n",
            "4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n",
            "2 1\n1 1 999997\n2 2 1\n"
        ],
        "outputs": [
            "2.8284271247461903\n",
            "1.4142135623730951\n",
            "-1"
        ],
        "starter_code": "\ndef BfItw():\n",
        "scope": [
            [
                "Function Body",
                2,
                20
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "For Loop Body",
                9,
                16
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                17,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FUpNR():\n    \"\"\"Given a square matrix of size N×N, calculate the absolute difference between the sums of its diagonals. \n\n-----Input-----\nThe first line contains a single integer N. The next N lines denote the matrix's rows, with each line containing N space-separated integers describing the columns.\n\n-----Output-----\nPrint the absolute difference between the two sums of the matrix's diagonals as a single integer.\n\n-----Constraints-----\n1<=N<=10\n\n-----Example-----\nInput:\n3\n11 2 4\n4 5 6\n10 8 -12\n\nOutput:\n15\n\n-----Explanation-----\nThe primary diagonal is: \n11\n5\n-12\nSum across the primary diagonal: 11 + 5 - 12 = 4\nThe secondary diagonal is:\n4\n5\n10\nSum across the secondary diagonal: 4 + 5 + 10 = 19 \nDifference: |4 - 19| = 15\n    \"\"\"\n",
        "canonical_solution": "\ndef FUpNR():\n    def diagonal_difference(matrix):\n     l = sum(matrix[i][i] for i in range(N))\n     r = sum(matrix[i][N-i-1] for i in range(N))\n     return abs(l - r)\n    \n    matrix = []\n    N = eval(input())\n    for _ in range(N):\n     matrix.append(list(map(int, input().split())))\n    \n    print(diagonal_difference(matrix))",
        "inputs": [
            "3\n11 2 4\n4 5 6\n10 8 -12\n"
        ],
        "outputs": [
            "15\n"
        ],
        "starter_code": "\ndef FUpNR():\n",
        "scope": [
            [
                "Function Body",
                2,
                13
            ],
            [
                "Function Body",
                3,
                6
            ],
            [
                "Generator Expression",
                4,
                4
            ],
            [
                "Generator Expression",
                5,
                5
            ],
            [
                "For Loop Body",
                10,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef CibLG():\n    \"\"\"Manao is taking part in a quiz. The quiz consists of n consecutive questions. A correct answer gives one point to the player. The game also has a counter of consecutive correct answers. When the player answers a question correctly, the number on this counter increases by 1. If the player answers a question incorrectly, the counter is reset, that is, the number on it reduces to 0. If after an answer the counter reaches the number k, then it is reset, and the player's score is doubled. Note that in this case, first 1 point is added to the player's score, and then the total score is doubled. At the beginning of the game, both the player's score and the counter of consecutive correct answers are set to zero.\n\nManao remembers that he has answered exactly m questions correctly. But he does not remember the order in which the questions came. He's trying to figure out what his minimum score may be. Help him and compute the remainder of the corresponding number after division by 1000000009 (10^9 + 9).\n\n\n-----Input-----\n\nThe single line contains three space-separated integers n, m and k (2 ≤ k ≤ n ≤ 10^9; 0 ≤ m ≤ n).\n\n\n-----Output-----\n\nPrint a single integer — the remainder from division of Manao's minimum possible score in the quiz by 1000000009 (10^9 + 9).\n\n\n-----Examples-----\nInput\n5 3 2\n\nOutput\n3\n\nInput\n5 4 2\n\nOutput\n6\n\n\n\n-----Note-----\n\nSample 1. Manao answered 3 questions out of 5, and his score would double for each two consecutive correct answers. If Manao had answered the first, third and fifth questions, he would have scored as much as 3 points.\n\nSample 2. Now Manao answered 4 questions. The minimum possible score is obtained when the only wrong answer is to the question 4.\n\nAlso note that you are asked to minimize the score and not the remainder of the score modulo 1000000009. For example, if Manao could obtain either 2000000000 or 2000000020 points, the answer is 2000000000 mod 1000000009, even though 2000000020 mod 1000000009 is a smaller number.\n    \"\"\"\n",
        "canonical_solution": "\ndef CibLG():\n    MOD = 1000000009\n    \n    n,m,k = [int(x) for x in input().split()]\n    \n    num0 = n-m\n    num1fin = num0*(k-1)\n    if num1fin >= m:\n        print(m)\n    else:\n        num1open = m-num1fin\n        sets = num1open//k\n        rem = num1open%k\n        print(((pow(2,sets,MOD)-1)*2*k+rem+num1fin)%MOD)\n    ",
        "inputs": [
            "5 3 2\n",
            "5 4 2\n",
            "300 300 3\n"
        ],
        "outputs": [
            "3\n",
            "6\n",
            "17717644\n"
        ],
        "starter_code": "\ndef CibLG():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "If Statement Body",
                9,
                15
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef VBHLl():\n    \"\"\"There are $n$ chips arranged in a circle, numbered from $1$ to $n$. \n\nInitially each chip has black or white color. Then $k$ iterations occur. During each iteration the chips change their colors according to the following rules. For each chip $i$, three chips are considered: chip $i$ itself and two its neighbours. If the number of white chips among these three is greater than the number of black chips among these three chips, then the chip $i$ becomes white. Otherwise, the chip $i$ becomes black. \n\nNote that for each $i$ from $2$ to $(n - 1)$ two neighbouring chips have numbers $(i - 1)$ and $(i + 1)$. The neighbours for the chip $i = 1$ are $n$ and $2$. The neighbours of $i = n$ are $(n - 1)$ and $1$.\n\nThe following picture describes one iteration with $n = 6$. The chips $1$, $3$ and $4$ are initially black, and the chips $2$, $5$ and $6$ are white. After the iteration $2$, $3$ and $4$ become black, and $1$, $5$ and $6$ become white.\n\n [Image] \n\nYour task is to determine the color of each chip after $k$ iterations.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ $(3 \\le n \\le 200\\,000, 1 \\le k \\le 10^{9})$ — the number of chips and the number of iterations, respectively.\n\nThe second line contains a string consisting of $n$ characters \"W\" and \"B\". If the $i$-th character is \"W\", then the $i$-th chip is white initially. If the $i$-th character is \"B\", then the $i$-th chip is black initially.\n\n\n-----Output-----\n\nPrint a string consisting of $n$ characters \"W\" and \"B\". If after $k$ iterations the $i$-th chip is white, then the $i$-th character should be \"W\". Otherwise the $i$-th character should be \"B\".\n\n\n-----Examples-----\nInput\n6 1\nBWBBWW\n\nOutput\nWBBBWW\n\nInput\n7 3\nWBWBWBW\n\nOutput\nWWWWWWW\n\nInput\n6 4\nBWBWBW\n\nOutput\nBWBWBW\n\n\n\n-----Note-----\n\nThe first example is described in the statement.\n\nThe second example: \"WBWBWBW\" $\\rightarrow$ \"WWBWBWW\" $\\rightarrow$ \"WWWBWWW\" $\\rightarrow$ \"WWWWWWW\". So all chips become white.\n\nThe third example: \"BWBWBW\" $\\rightarrow$ \"WBWBWB\" $\\rightarrow$ \"BWBWBW\" $\\rightarrow$ \"WBWBWB\" $\\rightarrow$ \"BWBWBW\".\n    \"\"\"\n",
        "canonical_solution": "\ndef VBHLl():\n    n, k = map(int, input().split())\n    a = list(input()) * 2\n    \n    iter1 = [0] * (2 * n)\n    iter2 = [0] * (2 * n)\n    changes = 0\n    for i in range(1, 2 * n):\n        if a[i] != a[i - 1]:\n            changes += 1\n        else:\n            changes = 0\n        iter1[i] = changes\n    changes = 0\n    for i in range(2 * n - 2, -1, -1):\n        if a[i] != a[i + 1]:\n            changes += 1\n        else:\n            changes = 0\n        iter2[i] = changes\n    \n    iters = [min(iter1[n + i], iter2[i]) for i in range(n)]\n    for i in range(n):\n        if iters[i] > n // 2:\n            iters[i] = 10 ** 9 + 1\n        it = min(iters[i], k)\n        if it % 2 != 0:\n            if a[i] == \"B\":\n                a[i] = \"W\"\n            else:\n                a[i] = \"B\"\n    print(\"\".join(a[:n]))",
        "inputs": [
            "6 1\nBWBBWW\n",
            "7 3\nWBWBWBW\n",
            "6 4\nBWBWBW\n"
        ],
        "outputs": [
            "WBBBWW\n",
            "WWWWWWW\n",
            "BWBWBW\n"
        ],
        "starter_code": "\ndef VBHLl():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "For Loop Body",
                9,
                14
            ],
            [
                "If Statement Body",
                10,
                13
            ],
            [
                "For Loop Body",
                16,
                21
            ],
            [
                "If Statement Body",
                17,
                20
            ],
            [
                "List Comprehension",
                23,
                23
            ],
            [
                "For Loop Body",
                24,
                32
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "If Statement Body",
                28,
                32
            ],
            [
                "If Statement Body",
                29,
                32
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wTGUl():\n    \"\"\"You are given a string $S$ and an integer $L$. A operation is described as :- \"You are allowed to pick any substring from first $L$ charcaters of $S$, and place it at the end of the string $S$. \nA string $A$ is a substring of an string $B$ if $A$ can be obtained from $B$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) elements from the end.\nFind the lexographically smallest string after performing this opertaion any number of times (possibly zero).\nFor example $S$ = \"codechef\" and $L=4$. Then, we can take substring \"ode\" from S[0-3] and place it at end of the string $S$ = \"cchefode\".\n\n-----Input:-----\n- First line will contain $T$, number of testcases. \n- Then each of the N lines contain an integer $L$ and a string $S$. \n\n-----Output:-----\nFor each testcase, output in a single line answer lexographically smallest string.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^4$\n- $2 \\leq |S| \\leq 10^3$\n- $1 \\leq L \\leq N $\n\n-----Sample Input:-----\n2\n1 rga\n2 cab\n\n-----Sample Output:-----\narg\nabc\n\n-----EXPLANATION:-----\nIn the first testcase:\nsubstring 'r' is picked and placed at the end of the string. rga -> gar\nThen performing same operation gives :- gar -> arg\n    \"\"\"\n",
        "canonical_solution": "\ndef wTGUl():\n    def least_rotation(S: str) -> int:\r\n        \"\"\"Booth's algorithm.\"\"\"\r\n        f = [-1] * len(S)  # Failure function\r\n        k = 0  # Least rotation of string found so far\r\n        for j in range(1, len(S)):\r\n            sj = S[j]\r\n            i = f[j - k - 1]\r\n            while i != -1 and sj != S[k + i + 1]:\r\n                if sj < S[k + i + 1]:\r\n                    k = j - i - 1\r\n                i = f[i]\r\n            if sj != S[k + i + 1]:  # if sj != S[k+i+1], then i == -1\r\n                if sj < S[k]:  # k+i+1 = k\r\n                    k = j\r\n                f[j - k] = -1\r\n            else:\r\n                f[j - k] = i + 1\r\n        return k\r\n    \r\n    \r\n    for _ in range(int(input())):\r\n        l, s = input().split()\r\n        if int(l) == 1:\r\n            l = len(s)\r\n            s += s\r\n            k = least_rotation(s)\r\n            print(s[k:k+l])\r\n        else:\r\n            print(''.join(sorted(s)))",
        "inputs": [
            "2\n1 rga\n2 cab\n"
        ],
        "outputs": [
            "arg\nabc\n"
        ],
        "starter_code": "\ndef wTGUl():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                3,
                20
            ],
            [
                "For Loop Body",
                7,
                19
            ],
            [
                "While Loop Body",
                10,
                13
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "If Statement Body",
                14,
                19
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "For Loop Body",
                23,
                31
            ],
            [
                "If Statement Body",
                25,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ShDWV():\n    \"\"\"Chef has many friends, but his best friend is Hemant. They both love to watch anime.\nIn fact, their weekends are meant for that only. Also, Hemant is highly into games, of which Chef is unaware. Hemant once gave a game to Chef and asked him to determine the winner of the game. Since the Chef is busy, and you are also his friend, he asked you to help him.\nThe Game is played between two players, $A$ and $B$. There are $N$ marbles. $A$ and $B$ plays alternately, and $A$ goes first. Each player can choose $1$ marble or $even$ number of marbles in his turn. The player who is not able to choose any marbles loses the game.\n\n-----Input:-----\n- The first line consists of a single integer $T$ denoting the number of test cases.\n- The Second line contains an integers $N$, denoting the number of marbles.\n\n-----Output:-----\nFor each test case, print the name of the player who loses the game.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^9$\n\n-----Sample Input:-----\n3\n1 \n3\n7 \n\n-----Sample Output:-----\nB\nA\nB\n    \"\"\"\n",
        "canonical_solution": "\ndef ShDWV():\n    \n    for _ in range(int(input())):\n        n=int(input())\n        if(n<3):\n            print(\"B\")\n        else:\n            if(n==3):\n                print(\"A\")\n            elif(n%2):\n                print(\"B\")\n            else:\n                print(\"B\")\n    \n    \n    \n    \n    \n    \n    \n    \n    ",
        "inputs": [
            "3\n1\n3\n7\n"
        ],
        "outputs": [
            "B\nA\nB\n"
        ],
        "starter_code": "\ndef ShDWV():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                4,
                14
            ],
            [
                "If Statement Body",
                6,
                14
            ],
            [
                "If Statement Body",
                9,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef cVBJx():\n    \"\"\"You're given a list of n strings a_1, a_2, ..., a_{n}. You'd like to concatenate them together in some order such that the resulting string would be lexicographically smallest.\n\nGiven the list of strings, output the lexicographically smallest concatenation.\n\n\n-----Input-----\n\nThe first line contains integer n — the number of strings (1 ≤ n ≤ 5·10^4).\n\nEach of the next n lines contains one string a_{i} (1 ≤ |a_{i}| ≤ 50) consisting of only lowercase English letters. The sum of string lengths will not exceed 5·10^4.\n\n\n-----Output-----\n\nPrint the only string a — the lexicographically smallest string concatenation.\n\n\n-----Examples-----\nInput\n4\nabba\nabacaba\nbcd\ner\n\nOutput\nabacabaabbabcder\n\nInput\n5\nx\nxx\nxxa\nxxaa\nxxaaa\n\nOutput\nxxaaaxxaaxxaxxx\n\nInput\n3\nc\ncb\ncba\n\nOutput\ncbacbc\n    \"\"\"\n",
        "canonical_solution": "from functools import cmp_to_key\ndef cVBJx():\n    #!/usr/bin/env python3\n    def cmpEqLen(a, b):\n        if a < b:\n            return -1\n        elif a > b:\n            return 1\n        else:\n            return 0\n    def compare(a, b):\n        alen = len(a)\n        blen = len(b)\n        if alen == blen:\n            return cmpEqLen(a, b)\n        l = min(alen, blen)\n        c = cmpEqLen(a[:l], b[:l])\n        if c != 0:\n            return c\n        if alen > blen:\n            return -compare(a[:l], a[l:])\n        else:\n            return compare(b[:l], b[l:])\n    N = int(input())\n    arr = [input() for _ in range(N)]\n    arr.sort(key=cmp_to_key(compare))\n    print(''.join(arr))",
        "inputs": [
            "4\nabba\nabacaba\nbcd\ner\n",
            "5\nx\nxx\nxxa\nxxaa\nxxaaa\n",
            "3\nc\ncb\ncba\n"
        ],
        "outputs": [
            "abacabaabbabcder\n",
            "xxaaaxxaaxxaxxx\n",
            "cbacbc\n"
        ],
        "starter_code": "\ndef cVBJx():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                4,
                10
            ],
            [
                "If Statement Body",
                5,
                10
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "Function Body",
                11,
                23
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "If Statement Body",
                20,
                23
            ],
            [
                "List Comprehension",
                25,
                25
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef oHERm():\n    \"\"\"Boboniu likes bit operations. He wants to play a game with you.\n\nBoboniu gives you two sequences of non-negative integers $a_1,a_2,\\ldots,a_n$ and $b_1,b_2,\\ldots,b_m$.\n\nFor each $i$ ($1\\le i\\le n$), you're asked to choose a $j$ ($1\\le j\\le m$) and let $c_i=a_i\\& b_j$, where $\\&$ denotes the bitwise AND operation. Note that you can pick the same $j$ for different $i$'s.\n\nFind the minimum possible $c_1 | c_2 | \\ldots | c_n$, where $|$ denotes the bitwise OR operation.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1\\le n,m\\le 200$).\n\nThe next line contains $n$ integers $a_1,a_2,\\ldots,a_n$ ($0\\le a_i < 2^9$).\n\nThe next line contains $m$ integers $b_1,b_2,\\ldots,b_m$ ($0\\le b_i < 2^9$).\n\n\n-----Output-----\n\nPrint one integer: the minimum possible $c_1 | c_2 | \\ldots | c_n$.\n\n\n-----Examples-----\nInput\n4 2\n2 6 4 0\n2 4\n\nOutput\n2\nInput\n7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\n\nOutput\n0\nInput\n8 5\n179 261 432 162 82 43 10 38\n379 357 202 184 197\n\nOutput\n147\n\n\n-----Note-----\n\nFor the first example, we have $c_1=a_1\\& b_2=0$, $c_2=a_2\\& b_1=2$, $c_3=a_3\\& b_1=0$, $c_4 = a_4\\& b_1=0$.Thus $c_1 | c_2 | c_3 |c_4 =2$, and this is the minimal answer we can get.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef oHERm():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    possible = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(m):\n            possible[i].append(a[i] & b[j])\n    for answer in range(2 ** 9):\n        answer_flag = 1\n        for i in range(n):\n            flag = 0\n            for x in possible[i]:\n                if answer | x == answer:\n                    flag = 1\n                    break\n            if flag == 0:\n                answer_flag = 0\n                break\n        if answer_flag:\n            print(answer)\n            return",
        "inputs": [
            "4 2\n2 6 4 0\n2 4\n",
            "7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\n",
            "8 5\n179 261 432 162 82 43 10 38\n379 357 202 184 197\n"
        ],
        "outputs": [
            "2",
            "0",
            "147"
        ],
        "starter_code": "\ndef oHERm():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                9
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "For Loop Body",
                10,
                23
            ],
            [
                "For Loop Body",
                12,
                20
            ],
            [
                "For Loop Body",
                14,
                17
            ],
            [
                "If Statement Body",
                15,
                17
            ],
            [
                "If Statement Body",
                18,
                20
            ],
            [
                "If Statement Body",
                21,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Liptk():\n    \"\"\"You are given two integers $n$ and $m$ ($m < n$). Consider a convex regular polygon of $n$ vertices. Recall that a regular polygon is a polygon that is equiangular (all angles are equal in measure) and equilateral (all sides have the same length). [Image] Examples of convex regular polygons \n\nYour task is to say if it is possible to build another convex regular polygon with $m$ vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.\n\nThe next $t$ lines describe test cases. Each test case is given as two space-separated integers $n$ and $m$ ($3 \\le m < n \\le 100$) — the number of vertices in the initial polygon and the number of vertices in the polygon you want to build.\n\n\n-----Output-----\n\nFor each test case, print the answer — \"YES\" (without quotes), if it is possible to build another convex regular polygon with $m$ vertices such that its center coincides with the center of the initial polygon and each of its vertices is some vertex of the initial polygon and \"NO\" otherwise.\n\n\n-----Example-----\nInput\n2\n6 3\n7 3\n\nOutput\nYES\nNO\n\n\n\n-----Note----- $0$ The first test case of the example \n\nIt can be shown that the answer for the second test case of the example is \"NO\".\n    \"\"\"\n",
        "canonical_solution": "\ndef Liptk():\n    t = int(input())\n    for tt in range(t):\n    \tx, y = map(int, input().split())\n    \tprint('YES' if x % y == 0 else \"NO\")",
        "inputs": [
            "2\n6 3\n7 3\n",
            "1\n69 68\n",
            "2\n69 68\n11 9\n"
        ],
        "outputs": [
            "YES\nNO\n",
            "NO\n",
            "NO\nNO\n"
        ],
        "starter_code": "\ndef Liptk():\n",
        "scope": [
            [
                "Function Body",
                2,
                6
            ],
            [
                "For Loop Body",
                4,
                6
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef TkvBO():\n    \"\"\"Mahmoud has n line segments, the i-th of them has length a_{i}. Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle. Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge. Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.\n\nMahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length. A non-degenerate triangle is a triangle with positive area.\n\n\n-----Input-----\n\nThe first line contains single integer n (3 ≤ n ≤ 10^5) — the number of line segments Mahmoud has.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — the lengths of line segments Mahmoud has.\n\n\n-----Output-----\n\nIn the only line print \"YES\" if he can choose exactly three line segments and form a non-degenerate triangle with them, and \"NO\" otherwise.\n\n\n-----Examples-----\nInput\n5\n1 5 3 2 4\n\nOutput\nYES\n\nInput\n3\n4 1 2\n\nOutput\nNO\n\n\n\n-----Note-----\n\nFor the first example, he can use line segments with lengths 2, 4 and 5 to form a non-degenerate triangle.\n    \"\"\"\n",
        "canonical_solution": "\ndef TkvBO():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ok = False\n    for i in range(n - 2):\n    \tif a[i] + a[i + 1] > a[i + 2]:\n    \t\tok = True\n    print((\"NO\", \"YES\")[ok])",
        "inputs": [
            "5\n1 5 3 2 4\n",
            "3\n4 1 2\n",
            "30\n197 75 517 39724 7906061 1153471 3 15166 168284 3019844 272293 316 16 24548 42 118 5792 5 9373 1866366 4886214 24 2206 712886 104005 1363 836 64273 440585 3576\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef TkvBO():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "For Loop Body",
                7,
                9
            ],
            [
                "If Statement Body",
                8,
                9
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef uFwvb():\n    \"\"\"Find the number of integers between 1 and N (inclusive) that contains exactly K non-zero digits when written in base ten.\n\n-----Constraints-----\n - 1 \\leq N < 10^{100}\n - 1 \\leq K \\leq 3\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nK\n\n-----Output-----\nPrint the count.\n\n-----Sample Input-----\n100\n1\n\n-----Sample Output-----\n19\n\nThe following 19 integers satisfy the condition:\n - 1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef uFwvb():\n    sys.setrecursionlimit(10000)\n    n = input()\n    k = int(input())\n    m = {}\n    def doit(n, k):\n        if len(n) == 0:\n            return k == 0\n        d = int(n[0])\n        if (n, k) not in m:\n            ret = 0\n            for i in range(d + 1):\n                if i == d:\n                    ret += doit(n[1:], k - 1 if i > 0 else k)\n                else:\n                    ret += doit('9' * (len(n) - 1), k - 1 if i > 0 else k)\n            m[(n, k)] = ret\n        return m[(n, k)]\n    print((doit(n, k)))",
        "inputs": [
            "100\n1\n",
            "25\n2\n",
            "314159\n2\n"
        ],
        "outputs": [
            "19\n",
            "14\n",
            "937\n"
        ],
        "starter_code": "\ndef uFwvb():\n",
        "scope": [
            [
                "Function Body",
                2,
                20
            ],
            [
                "Function Body",
                7,
                19
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "If Statement Body",
                11,
                18
            ],
            [
                "For Loop Body",
                13,
                17
            ],
            [
                "If Statement Body",
                14,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef HfXjm():\n    \"\"\"In distant future on Earth day lasts for n hours and that's why there are n timezones. Local times in adjacent timezones differ by one hour. For describing local time, hours numbers from 1 to n are used, i.e. there is no time \"0 hours\", instead of it \"n hours\" is used. When local time in the 1-st timezone is 1 hour, local time in the i-th timezone is i hours.\n\nSome online programming contests platform wants to conduct a contest that lasts for an hour in such a way that its beginning coincides with beginning of some hour (in all time zones). The platform knows, that there are a_{i} people from i-th timezone who want to participate in the contest. Each person will participate if and only if the contest starts no earlier than s hours 00 minutes local time and ends not later than f hours 00 minutes local time. Values s and f are equal for all time zones. If the contest starts at f hours 00 minutes local time, the person won't participate in it.\n\nHelp platform select such an hour, that the number of people who will participate in the contest is maximum. \n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 100 000) — the number of hours in day.\n\nThe second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10 000), where a_{i} is the number of people in the i-th timezone who want to participate in the contest.\n\nThe third line contains two space-separated integers s and f (1 ≤ s < f ≤ n).\n\n\n-----Output-----\n\nOutput a single integer — the time of the beginning of the contest (in the first timezone local time), such that the number of participants will be maximum possible. If there are many answers, output the smallest among them.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n1 3\n\nOutput\n3\n\nInput\n5\n1 2 3 4 1\n1 3\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example, it's optimal to start competition at 3 hours (in first timezone). In this case, it will be 1 hour in the second timezone and 2 hours in the third timezone. Only one person from the first timezone won't participate.\n\nIn second example only people from the third and the fourth timezones will participate.\n    \"\"\"\n",
        "canonical_solution": "\ndef HfXjm():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    s, f = [int(i) for i in input().split()]\n    a = a + a\n    ln = f - s\n    ans = sum(a[:ln])\n    mx = ans\n    h = s\n    for i in range(n - 1):\n        ans = ans - a[i] + a[i + ln]\n        if ans > mx:\n            ans = mx\n            k = s + (n - (i + 2) + 1)\n            if k > n:\n                k -= n  \n            h = k\n        elif ans == mx:\n            k = s + (n - (i + 2) + 1)\n            if k > n:\n                k -= n    \n            h = min(h, k)\n    print(h)\n    ",
        "inputs": [
            "3\n1 2 3\n1 3\n",
            "5\n1 2 3 4 1\n1 3\n",
            "2\n5072 8422\n1 2\n"
        ],
        "outputs": [
            "3\n",
            "4\n",
            "2\n"
        ],
        "starter_code": "\ndef HfXjm():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                11,
                23
            ],
            [
                "If Statement Body",
                13,
                23
            ],
            [
                "If Statement Body",
                16,
                17
            ],
            [
                "If Statement Body",
                19,
                23
            ],
            [
                "If Statement Body",
                21,
                22
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Zxofj():\n    \"\"\"An n × n table a is defined as follows:\n\n  The first row and the first column contain ones, that is: a_{i}, 1 = a_{1, }i = 1 for all i = 1, 2, ..., n.  Each of the remaining numbers in the table is equal to the sum of the number above it and the number to the left of it. In other words, the remaining elements are defined by the formula a_{i}, j = a_{i} - 1, j + a_{i}, j - 1. \n\nThese conditions define all the values in the table.\n\nYou are given a number n. You need to determine the maximum value in the n × n table defined by the rules above.\n\n\n-----Input-----\n\nThe only line of input contains a positive integer n (1 ≤ n ≤ 10) — the number of rows and columns of the table.\n\n\n-----Output-----\n\nPrint a single line containing a positive integer m — the maximum value in the table.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1\nInput\n5\n\nOutput\n70\n\n\n-----Note-----\n\nIn the second test the rows of the table look as follows: {1, 1, 1, 1, 1},  {1, 2, 3, 4, 5},  {1, 3, 6, 10, 15},  {1, 4, 10, 20, 35},  {1, 5, 15, 35, 70}.\n    \"\"\"\n",
        "canonical_solution": "\ndef Zxofj():\n    n = int(input())\n    a = [[1] * n for i in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            a[i][j] = a[i - 1][j] + a[i][j - 1]\n    print(a[n - 1][n - 1])\n    ",
        "inputs": [
            "1\n",
            "5\n",
            "2\n"
        ],
        "outputs": [
            "1",
            "70",
            "2"
        ],
        "starter_code": "\ndef Zxofj():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "For Loop Body",
                6,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef kDSZA():\n    \"\"\"Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.\n\nOrganizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.\n\nTournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.\n\n\n-----Input-----\n\nThe only line of the input contains a single integer n (2 ≤ n ≤ 10^18) — the number of players to participate in the tournament.\n\n\n-----Output-----\n\nPrint the maximum number of games in which the winner of the tournament can take part.\n\n\n-----Examples-----\nInput\n2\n\nOutput\n1\n\nInput\n3\n\nOutput\n2\n\nInput\n4\n\nOutput\n2\n\nInput\n10\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn all samples we consider that player number 1 is the winner.\n\nIn the first sample, there would be only one game so the answer is 1.\n\nIn the second sample, player 1 can consequently beat players 2 and 3. \n\nIn the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1, 2) and (3, 4) and then clash the winners.\n    \"\"\"\n",
        "canonical_solution": "\ndef kDSZA():\n    n = int(input())\n    x = 0\n    cur = 1\n    lst = 1\n    while cur + lst <= n:\n        cur, lst = cur + lst, cur\n        x += 1\n    print(x)\n    ",
        "inputs": [
            "2\n",
            "3\n",
            "4\n"
        ],
        "outputs": [
            "1\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef kDSZA():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "While Loop Body",
                7,
                9
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ROPwh():\n    \"\"\"Valera takes part in the Berland Marathon. The marathon race starts at the stadium that can be represented on the plane as a square whose lower left corner is located at point with coordinates (0, 0) and the length of the side equals a meters. The sides of the square are parallel to coordinate axes.\n\nAs the length of the marathon race is very long, Valera needs to have extra drink during the race. The coach gives Valera a bottle of drink each d meters of the path. We know that Valera starts at the point with coordinates (0, 0) and runs counter-clockwise. That is, when Valera covers a meters, he reaches the point with coordinates (a, 0). We also know that the length of the marathon race equals nd + 0.5 meters. \n\nHelp Valera's coach determine where he should be located to help Valera. Specifically, determine the coordinates of Valera's positions when he covers d, 2·d, ..., n·d meters.\n\n\n-----Input-----\n\nThe first line contains two space-separated real numbers a and d (1 ≤ a, d ≤ 10^5), given with precision till 4 decimal digits after the decimal point. Number a denotes the length of the square's side that describes the stadium. Number d shows that after each d meters Valera gets an extra drink.\n\nThe second line contains integer n (1 ≤ n ≤ 10^5) showing that Valera needs an extra drink n times.\n\n\n-----Output-----\n\nPrint n lines, each line should contain two real numbers x_{i} and y_{i}, separated by a space. Numbers x_{i} and y_{i} in the i-th line mean that Valera is at point with coordinates (x_{i}, y_{i}) after he covers i·d meters. Your solution will be considered correct if the absolute or relative error doesn't exceed 10^{ - 4}.\n\nNote, that this problem have huge amount of output data. Please, do not use cout stream for output in this problem.\n\n\n-----Examples-----\nInput\n2 5\n2\n\nOutput\n1.0000000000 2.0000000000\n2.0000000000 0.0000000000\n\nInput\n4.147 2.8819\n6\n\nOutput\n2.8819000000 0.0000000000\n4.1470000000 1.6168000000\n3.7953000000 4.1470000000\n0.9134000000 4.1470000000\n0.0000000000 2.1785000000\n0.7034000000 0.0000000000\n    \"\"\"\n",
        "canonical_solution": "\ndef ROPwh():\n    a, d = list(map(float, input().split()))\n    n = int(input())\n    \n    def coordinates(s):\n        if s <= a:\n            return (s, 0)\n        elif s <= 2*a:\n            return (a, s-a)\n        elif s <= 3*a:\n            return (3*a - s, a)\n        else:\n            return (0, 4*a - s)\n    \n    for i in range(1, n+1):\n        print(\"%f %f\" % coordinates(i*d % (4*a)))\n    ",
        "inputs": [
            "2 5\n2\n",
            "4.147 2.8819\n6\n",
            "16904.8597 21646.2846\n10\n"
        ],
        "outputs": [
            "1.000000 2.000000\n2.000000 0.000000\n",
            "2.881900 0.000000\n4.147000 1.616800\n3.795300 4.147000\n0.913400 4.147000\n0.000000 2.178500\n0.703400 0.000000\n",
            "16904.859700 4741.424900\n7422.009900 16904.859700\n0.000000 2680.585000\n16904.859700 2060.839900\n10102.594900 16904.859700\n0.000000 5361.170000\n16285.114600 0.000000\n12783.179900 16904.859700\n0.000000 8041.755000\n13604.529600 0.000000\n"
        ],
        "starter_code": "\ndef ROPwh():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "Function Body",
                6,
                14
            ],
            [
                "If Statement Body",
                7,
                14
            ],
            [
                "If Statement Body",
                9,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ],
            [
                "For Loop Body",
                16,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ZDscw():\n    \"\"\"You want to arrange n integers a_1, a_2, ..., a_{n} in some order in a row. Let's define the value of an arrangement as the sum of differences between all pairs of adjacent integers.\n\nMore formally, let's denote some arrangement as a sequence of integers x_1, x_2, ..., x_{n}, where sequence x is a permutation of sequence a. The value of such an arrangement is (x_1 - x_2) + (x_2 - x_3) + ... + (x_{n} - 1 - x_{n}).\n\nFind the largest possible value of an arrangement. Then, output the lexicographically smallest sequence x that corresponds to an arrangement of the largest possible value.\n\n\n-----Input-----\n\nThe first line of the input contains integer n (2 ≤ n ≤ 100). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (|a_{i}| ≤ 1000).\n\n\n-----Output-----\n\nPrint the required sequence x_1, x_2, ..., x_{n}. Sequence x should be the lexicographically smallest permutation of a that corresponds to an arrangement of the largest possible value.\n\n\n-----Examples-----\nInput\n5\n100 -100 50 0 -50\n\nOutput\n100 -50 0 50 -100 \n\n\n\n-----Note-----\n\nIn the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.\n\nSequence x_1, x_2, ... , x_{p} is lexicographically smaller than sequence y_1, y_2, ... , y_{p} if there exists an integer r (0 ≤ r < p) such that x_1 = y_1, x_2 = y_2, ... , x_{r} = y_{r} and x_{r} + 1 < y_{r} + 1.\n    \"\"\"\n",
        "canonical_solution": "\ndef ZDscw():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    A[0], A[-1] = A[-1], A[0]\n    print(\" \".join(list(map(str, A))))",
        "inputs": [
            "5\n100 -100 50 0 -50\n",
            "10\n764 -367 0 963 -939 -795 -26 -49 948 -282\n",
            "20\n262 -689 -593 161 -678 -555 -633 -697 369 258 673 50 833 737 -650 198 -651 -621 -396 939\n"
        ],
        "outputs": [
            "100 -50 0 50 -100 \n",
            "963 -795 -367 -282 -49 -26 0 764 948 -939 \n",
            "939 -689 -678 -651 -650 -633 -621 -593 -555 -396 50 161 198 258 262 369 673 737 833 -697 \n"
        ],
        "starter_code": "\ndef ZDscw():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef XIjfr():\n    \"\"\"Chef is frustrated in this lockown. So to overcome this he plans to travel various mountains.\nHe is very strange so he sets some conditions for $each$ Type 2 query(mentioned below) (i.e. $1$ $i$) : \n- Let Chef has travelled till $ith$ mountain from left to right.\n- He does not like to travel the mountain with the height ,of which he has travelled till now. More formally, \nLet the height of peak on which he is standing is $a_{i}$ then he can only go to the peak of height $a_{j}$ \nwhich is greater than $a_{i}$ and nearest to $ith$ mountain such that there should be no other peak of same height $a_{j}$ till $a_{i}$(height of $ith$ mountain) .\n\n-----Input format:-----\n- \nThe first line contains an integer $T$ denoting the number of test cases.\n- \nThe second line of  consist of a integer $N$ and $Q$ .\n- \nThe third line contains $N$ not necessarily distinct positive integers $a_{0},a_{1}, . . .,a_{n-1}$ denoting the height of \n$N$ mountains.\n- \nThen next $Q$ lines follows where each line consisting of $either$ of $2$ types of queries:\nType 1:  $0$ $A$ $B$ i.e. $a_{A} = B$ (where height of $Ath$ mountain will be updated to $B$) \nType 2:  $1$ $A$ i.e. you have to answer $a_k$ which is greater than $a_{A}$ and nearest to $Ath$ mountain such that there should be no other peak of same height $a_{k}$ till $a_{A}$(height of $Ath$ mountain) .\n\n-----Output format:-----\n- For every query of Type 2 there should be an integer $a_{k}$ on next  line for the updated array , If no such $a_{k}$ exists then $a_{k}$= $-1$ , as query of type 1 will have no output . \n\n-----Constraints:-----\n- $1\\leq T \\leq 10^2$\n- $1 \\leq N,Q \\leq 10^4$\n- $0\\leq a_{i} \\leq 10^6$\n- $0\\leq B \\leq 10^6$\n- $0\\leq A \\leq N-1$\n\n-----Subtasks-----\n- \n1 Point :   \n$1 \\leq T,N,Q \\leq 10^2$ \n$0\\leq B,a_{i} \\leq 10^2$\n- \n99 Points : Orginal   Constraints\n\n-----Example:-----\n\n-----Input:-----\n1\n10 5\n1 3 5 4 5 6 7 8  4 5\n1 7\n1 3\n1 1\n0 2 7\n1 3\n\n-----Output:-----\n-1\n6\n5\n5\n    \"\"\"\n",
        "canonical_solution": "from bisect import bisect_left\ndef XIjfr():\n    # cook your dish here\n     \n    def BinarySearch(a, x): \n     i = bisect_left(a, x) \n     if i != len(a) and a[i] == x: \n      return i \n     else: \n      return -1\n    for _t in range(int(input())):\n     _n, q = list(map(int, input().split()))\n     mounts = list(map(int, input().split()))\n     for _q in range(q):\n      query = list(map(int, input().split()))\n      if query[0] == 0:\n       mounts[query[1]] = query[2]\n      else:\n       curr = query[1]\n       prev = set(mounts[:curr+1])\n       for m in mounts[curr+1:]:\n        if m > mounts[curr] and m not in prev:\n         print(m)\n         break\n       else:\n        print(-1)\n         ",
        "inputs": [
            "1\n10 5\n1 3 5 4 5 6 7 8  4 5\n1 7\n1 3\n1 1\n0 2 7\n1 3\n"
        ],
        "outputs": [
            "-1\n6\n5\n5\n"
        ],
        "starter_code": "\ndef XIjfr():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "Function Body",
                5,
                10
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "For Loop Body",
                11,
                26
            ],
            [
                "For Loop Body",
                14,
                26
            ],
            [
                "If Statement Body",
                16,
                26
            ],
            [
                "For Loop Body",
                21,
                26
            ],
            [
                "If Statement Body",
                22,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef CXmdF():\n    \"\"\"Okabe and Super Hacker Daru are stacking and removing boxes. There are n boxes numbered from 1 to n. Initially there are no boxes on the stack.\n\nOkabe, being a control freak, gives Daru 2n commands: n of which are to add a box to the top of the stack, and n of which are to remove a box from the top of the stack and throw it in the trash. Okabe wants Daru to throw away the boxes in the order from 1 to n. Of course, this means that it might be impossible for Daru to perform some of Okabe's remove commands, because the required box is not on the top of the stack.\n\nThat's why Daru can decide to wait until Okabe looks away and then reorder the boxes in the stack in any way he wants. He can do it at any point of time between Okabe's commands, but he can't add or remove boxes while he does it.\n\nTell Daru the minimum number of times he needs to reorder the boxes so that he can successfully complete all of Okabe's commands. It is guaranteed that every box is added before it is required to be removed.\n\n\n-----Input-----\n\nThe first line of input contains the integer n (1 ≤ n ≤ 3·10^5) — the number of boxes.\n\nEach of the next 2n lines of input starts with a string \"add\" or \"remove\". If the line starts with the \"add\", an integer x (1 ≤ x ≤ n) follows, indicating that Daru should add the box with number x to the top of the stack. \n\nIt is guaranteed that exactly n lines contain \"add\" operations, all the boxes added are distinct, and n lines contain \"remove\" operations. It is also guaranteed that a box is always added before it is required to be removed.\n\n\n-----Output-----\n\nPrint the minimum number of times Daru needs to reorder the boxes to successfully complete all of Okabe's commands.\n\n\n-----Examples-----\nInput\n3\nadd 1\nremove\nadd 2\nadd 3\nremove\nremove\n\nOutput\n1\n\nInput\n7\nadd 3\nadd 2\nadd 1\nremove\nadd 4\nremove\nremove\nremove\nadd 6\nadd 7\nadd 5\nremove\nremove\nremove\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Daru should reorder the boxes after adding box 3 to the stack.\n\nIn the second sample, Daru should reorder the boxes after adding box 4 and box 7 to the stack.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef CXmdF():\n    def main():\n        n = int(input())\n        n = n*2\n        u = 0\n        res = 0\n        x = []\n        for i in range(n):\n            s = sys.stdin.readline()\n            if s[0] == 'r':\n                u+=1\n                if len(x)==0:\n                    continue\n                if x[-1] == u:\n                    x.pop()\n                else:\n                    x = []\n                    res +=1\n            else:\n                a,b = s.split()\n                x.append(int(b))\n        print(res)\n    main()",
        "inputs": [
            "3\nadd 1\nremove\nadd 2\nadd 3\nremove\nremove\n",
            "7\nadd 3\nadd 2\nadd 1\nremove\nadd 4\nremove\nremove\nremove\nadd 6\nadd 7\nadd 5\nremove\nremove\nremove\n",
            "4\nadd 1\nadd 3\nremove\nadd 4\nadd 2\nremove\nremove\nremove\n"
        ],
        "outputs": [
            "1\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef CXmdF():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "Function Body",
                3,
                23
            ],
            [
                "For Loop Body",
                9,
                22
            ],
            [
                "If Statement Body",
                11,
                22
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                19
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef jcpkK():\n    \"\"\"Let's call beauty of an array $b_1, b_2, \\ldots, b_n$ ($n > 1$)  — $\\min\\limits_{1 \\leq i < j \\leq n} |b_i - b_j|$.\n\nYou're given an array $a_1, a_2, \\ldots a_n$ and a number $k$. Calculate the sum of beauty over all subsequences of the array of length exactly $k$. As this number can be very large, output it modulo $998244353$.\n\nA sequence $a$ is a subsequence of an array $b$ if $a$ can be obtained from $b$ by deletion of several (possibly, zero or all) elements.\n\n\n-----Input-----\n\nThe first line contains integers $n, k$ ($2 \\le k \\le n \\le 1000$).\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^5$).\n\n\n-----Output-----\n\nOutput one integer — the sum of beauty over all subsequences of the array of length exactly $k$. As this number can be very large, output it modulo $998244353$.\n\n\n-----Examples-----\nInput\n4 3\n1 7 3 5\n\nOutput\n8\nInput\n5 5\n1 10 100 1000 10000\n\nOutput\n9\n\n\n-----Note-----\n\nIn the first example, there are $4$ subsequences of length $3$ — $[1, 7, 3]$, $[1, 3, 5]$, $[7, 3, 5]$, $[1, 7, 5]$, each of which has beauty $2$, so answer is $8$.\n\nIn the second example, there is only one subsequence of length $5$ — the whole array, which has the beauty equal to $|10-1| = 9$.\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\nimport sys\ndef jcpkK():\n    input = sys.stdin.readline\n    '''\n    for CASES in range(int(input())):\n    n, m = map(int, input().split())\n    n = int(input())\n    A = list(map(int, input().split()))\n    S = input().strip()\n    sys.stdout.write(\" \".join(map(str,ans))+\"\\n\")\n    '''\n    inf = 100000000000000000  # 1e17\n    mod = 998244353\n    n, m = list(map(int, input().split()))\n    A = [0] + sorted(list(map(int, input().split())))\n    ans = 0\n    f = [[0] * (n + 10) for _ in range(m + 10)]\n    for x in range(1,(A[n] - A[1]) // (m - 1) + 1):\n        for i in range(1, n + 1):\n            f[1][i] = 1\n        for i in range(2, m + 1):\n            sum = 0\n            pre = 1\n            for j in range(1, n + 1):\n                while pre <= n and A[pre] + x <= A[j]:\n                    sum += f[i - 1][pre]\n                    sum %= mod\n                    pre += 1\n                f[i][j] = sum\n        for i in range(1, n + 1):\n            ans += f[m][i]\n            ans %= mod\n    print(ans)\n    # the end",
        "inputs": [
            "4 3\n1 7 3 5\n",
            "5 5\n1 10 100 1000 10000\n",
            "2 2\n52233 12247\n"
        ],
        "outputs": [
            "8",
            "9",
            "39986"
        ],
        "starter_code": "\ndef jcpkK():\n",
        "scope": [
            [
                "Function Body",
                3,
                34
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "For Loop Body",
                19,
                33
            ],
            [
                "For Loop Body",
                20,
                21
            ],
            [
                "For Loop Body",
                22,
                30
            ],
            [
                "For Loop Body",
                25,
                30
            ],
            [
                "While Loop Body",
                26,
                29
            ],
            [
                "For Loop Body",
                31,
                33
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef tHmZp():\n    \"\"\"The prison of your city has n prisoners. As the prison can't accommodate all of them, the city mayor has decided to transfer c of the prisoners to a prison located in another city.\n\nFor this reason, he made the n prisoners to stand in a line, with a number written on their chests. The number is the severity of the crime he/she has committed. The greater the number, the more severe his/her crime was.\n\nThen, the mayor told you to choose the c prisoners, who will be transferred to the other prison. He also imposed two conditions. They are,\n\n  The chosen c prisoners has to form a contiguous segment of prisoners.  Any of the chosen prisoner's crime level should not be greater then t. Because, that will make the prisoner a severe criminal and the mayor doesn't want to take the risk of his running away during the transfer. \n\nFind the number of ways you can choose the c prisoners.\n\n\n-----Input-----\n\nThe first line of input will contain three space separated integers n (1 ≤ n ≤ 2·10^5), t (0 ≤ t ≤ 10^9) and c (1 ≤ c ≤ n). The next line will contain n space separated integers, the i^{th} integer is the severity i^{th} prisoner's crime. The value of crime severities will be non-negative and will not exceed 10^9. \n\n\n-----Output-----\n\nPrint a single integer — the number of ways you can choose the c prisoners.\n\n\n-----Examples-----\nInput\n4 3 3\n2 3 1 1\n\nOutput\n2\n\nInput\n1 1 1\n2\n\nOutput\n0\n\nInput\n11 4 2\n2 2 0 7 3 2 2 4 9 1 4\n\nOutput\n6\n    \"\"\"\n",
        "canonical_solution": "\ndef tHmZp():\n    \"\"\"\n    Codeforces Round 244 Div 1 Problem B\n    \n    Author  : chaotic_iak\n    Language: Python 3.3.4\n    \"\"\"\n    \n    class InputHandlerObject(object):\n        inputs = []\n    \n        def getInput(self, n = 0):\n            res = \"\"\n            inputs = self.inputs\n            if not inputs: inputs.extend(input().split(\" \"))\n            if n == 0:\n                res = inputs[:]\n                inputs[:] = []\n            while n > len(inputs):\n                inputs.extend(input().split(\" \"))\n            if n > 0:\n                res = inputs[:n]\n                inputs[:n] = []\n            return res\n    InputHandler = InputHandlerObject()\n    g = InputHandler.getInput\n    \n    ############################## SOLUTION ##############################\n    n,t,c = [int(x) for x in g()]\n    a = [False if int(x) > t else True for x in g()]\n    ct = 0\n    res = 0\n    for i in a:\n        if i:\n            ct += 1\n            if ct >= c: res += 1\n        else:\n            ct = 0\n    print(res)",
        "inputs": [
            "4 3 3\n2 3 1 1\n",
            "1 1 1\n2\n",
            "11 4 2\n2 2 0 7 3 2 2 4 9 1 4\n"
        ],
        "outputs": [
            "2\n",
            "0\n",
            "6\n"
        ],
        "starter_code": "\ndef tHmZp():\n",
        "scope": [
            [
                "Function Body",
                2,
                40
            ],
            [
                "Class Body",
                10,
                25
            ],
            [
                "Function Body",
                13,
                25
            ],
            [
                "If Statement Body",
                16,
                16
            ],
            [
                "If Statement Body",
                17,
                19
            ],
            [
                "While Loop Body",
                20,
                21
            ],
            [
                "If Statement Body",
                22,
                24
            ],
            [
                "List Comprehension",
                30,
                30
            ],
            [
                "List Comprehension",
                31,
                31
            ],
            [
                "For Loop Body",
                34,
                39
            ],
            [
                "If Statement Body",
                35,
                39
            ],
            [
                "If Statement Body",
                37,
                37
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gmUnM():\n    \"\"\"Let's call an array $t$ dominated by value $v$ in the next situation.\n\nAt first, array $t$ should have at least $2$ elements. Now, let's calculate number of occurrences of each number $num$ in $t$ and define it as $occ(num)$. Then $t$ is dominated (by $v$) if (and only if) $occ(v) > occ(v')$ for any other number $v'$. For example, arrays $[1, 2, 3, 4, 5, 2]$, $[11, 11]$ and $[3, 2, 3, 2, 3]$ are dominated (by $2$, $11$ and $3$ respectevitely) but arrays $[3]$, $[1, 2]$ and $[3, 3, 2, 2, 1]$ are not.\n\nSmall remark: since any array can be dominated only by one number, we can not specify this number and just say that array is either dominated or not.\n\nYou are given array $a_1, a_2, \\dots, a_n$. Calculate its shortest dominated subarray or say that there are no such subarrays.\n\nThe subarray of $a$ is a contiguous part of the array $a$, i. e. the array $a_i, a_{i + 1}, \\dots, a_j$ for some $1 \\le i \\le j \\le n$.\n\n\n-----Input-----\n\nThe first line contains single integer $T$ ($1 \\le T \\le 1000$) — the number of test cases. Each test case consists of two lines.\n\nThe first line contains single integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the array $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) — the corresponding values of the array $a$.\n\nIt's guaranteed that the total length of all arrays in one test doesn't exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $T$ integers — one per test case. For each test case print the only integer — the length of the shortest dominated subarray, or $-1$ if there are no such subarrays.\n\n\n-----Example-----\nInput\n4\n1\n1\n6\n1 2 3 4 5 1\n9\n4 1 2 4 5 4 3 2 1\n4\n3 3 3 3\n\nOutput\n-1\n6\n3\n2\n\n\n\n-----Note-----\n\nIn the first test case, there are no subarrays of length at least $2$, so the answer is $-1$.\n\nIn the second test case, the whole array is dominated (by $1$) and it's the only dominated subarray.\n\nIn the third test case, the subarray $a_4, a_5, a_6$ is the shortest dominated subarray.\n\nIn the fourth test case, all subarrays of length more than one are dominated.\n    \"\"\"\n",
        "canonical_solution": "\ndef gmUnM():\n    for _ in range(int(input())):\n        lasts = {}\n        ans = n = int(input())\n        for i, a in enumerate(input().split()):\n            if a in lasts:\n                ans = min(ans, i - lasts[a])\n            lasts[a] = i\n        ans += 1\n        if ans > n:\n            ans = -1\n        print(ans)\n    ",
        "inputs": [
            "4\n1\n1\n6\n1 2 3 4 5 1\n9\n4 1 2 4 5 4 3 2 1\n4\n3 3 3 3\n",
            "1\n2\n2 2\n",
            "1\n11\n1 1 1 1 1 1 1 1 1 1 1\n"
        ],
        "outputs": [
            "-1\n6\n3\n2\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef gmUnM():\n",
        "scope": [
            [
                "Function Body",
                2,
                13
            ],
            [
                "For Loop Body",
                3,
                13
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "If Statement Body",
                7,
                8
            ],
            [
                "If Statement Body",
                11,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef CIdjZ():\n    \"\"\"Devu is a dumb guy, his learning curve is very slow. You are supposed to teach him n subjects, the i^{th} subject has c_{i} chapters. When you teach him, you are supposed to teach all the chapters of a subject continuously.\n\nLet us say that his initial per chapter learning power of a subject is x hours. In other words he can learn a chapter of a particular subject in x hours.\n\nWell Devu is not complete dumb, there is a good thing about him too. If you teach him a subject, then time required to teach any chapter of the next subject will require exactly 1 hour less than previously required (see the examples to understand it more clearly). Note that his per chapter learning power can not be less than 1 hour.\n\nYou can teach him the n subjects in any possible order. Find out minimum amount of time (in hours) Devu will take to understand all the subjects and you will be free to do some enjoying task rather than teaching a dumb guy.\n\nPlease be careful that answer might not fit in 32 bit data type.\n\n\n-----Input-----\n\nThe first line will contain two space separated integers n, x (1 ≤ n, x ≤ 10^5). The next line will contain n space separated integers: c_1, c_2, ..., c_{n} (1 ≤ c_{i} ≤ 10^5).\n\n\n-----Output-----\n\nOutput a single integer representing the answer to the problem.\n\n\n-----Examples-----\nInput\n2 3\n4 1\n\nOutput\n11\n\nInput\n4 2\n5 1 2 1\n\nOutput\n10\n\nInput\n3 3\n1 1 1\n\nOutput\n6\n\n\n\n-----Note-----\n\nLook at the first example. Consider the order of subjects: 1, 2. When you teach Devu the first subject, it will take him 3 hours per chapter, so it will take 12 hours to teach first subject. After teaching first subject, his per chapter learning time will be 2 hours. Now teaching him second subject will take 2 × 1 = 2 hours. Hence you will need to spend 12 + 2 = 14 hours.\n\nConsider the order of subjects: 2, 1. When you teach Devu the second subject, then it will take him 3 hours per chapter, so it will take 3 × 1 = 3 hours to teach the second subject. After teaching the second subject, his per chapter learning time will be 2 hours. Now teaching him the first subject will take 2 × 4 = 8 hours. Hence you will need to spend 11 hours.\n\nSo overall, minimum of both the cases is 11 hours.\n\nLook at the third example. The order in this example doesn't matter. When you teach Devu the first subject, it will take him 3 hours per chapter. When you teach Devu the second subject, it will take him 2 hours per chapter. When you teach Devu the third subject, it will take him 1 hours per chapter. In total it takes 6 hours.\n    \"\"\"\n",
        "canonical_solution": "\ndef CIdjZ():\n    \"\"\"\n    Codeforces Round 251 Div 2 Problem B\n    \n    Author  : chaotic_iak\n    Language: Python 3.3.4\n    \"\"\"\n    \n    def read(mode=2):\n        # 0: String\n        # 1: List of strings\n        # 2: List of integers\n        inputs = input().strip()\n        if mode == 0:\n            return inputs\n        if mode == 1:\n            return inputs.split()\n        if mode == 2:\n            return [int(x) for x in inputs.split()]\n    \n    def write(s=\"\\n\"):\n        if isinstance(s, list): s = \" \".join(s)\n        s = str(s)\n        print(s, end=\"\")\n    \n    ################################################### SOLUTION\n    n,x = read()\n    c = read()\n    c.sort()\n    print(sum(max(x-i,1)*c[i] for i in range(n)))",
        "inputs": [
            "2 3\n4 1\n",
            "4 2\n5 1 2 1\n",
            "3 3\n1 1 1\n"
        ],
        "outputs": [
            "11\n",
            "10\n",
            "6\n"
        ],
        "starter_code": "\ndef CIdjZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                10,
                20
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                19,
                20
            ],
            [
                "List Comprehension",
                20,
                20
            ],
            [
                "Function Body",
                22,
                25
            ],
            [
                "If Statement Body",
                23,
                23
            ],
            [
                "Generator Expression",
                31,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Mkzpg():\n    \"\"\"Vasya wants to turn on Christmas lights consisting of m bulbs. Initially, all bulbs are turned off. There are n buttons, each of them is connected to some set of bulbs. Vasya can press any of these buttons. When the button is pressed, it turns on all the bulbs it's connected to. Can Vasya light up all the bulbs?\n\nIf Vasya presses the button such that some bulbs connected to it are already turned on, they do not change their state, i.e. remain turned on.\n\n\n-----Input-----\n\nThe first line of the input contains integers n and m (1 ≤ n, m ≤ 100) — the number of buttons and the number of bulbs respectively. \n\nEach of the next n lines contains x_{i} (0 ≤ x_{i} ≤ m) — the number of bulbs that are turned on by the i-th button, and then x_{i} numbers y_{ij} (1 ≤ y_{ij} ≤ m) — the numbers of these bulbs.\n\n\n-----Output-----\n\nIf it's possible to turn on all m bulbs print \"YES\", otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n3 4\n2 1 4\n3 1 3 1\n1 2\n\nOutput\nYES\n\nInput\n3 3\n1 1\n1 2\n1 1\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first sample you can press each button once and turn on all the bulbs. In the 2 sample it is impossible to turn on the 3-rd lamp.\n    \"\"\"\n",
        "canonical_solution": "\ndef Mkzpg():\n    n, m = [int(i) for i in input().split()]\n    d = set()\n    for i in range(n):\n    \t_, *a = [int(i) for i in input().split()]\n    \td |= set(a)\n    \n    if len(d) == m:\n    \tprint(\"YES\")\n    else:\n    \tprint(\"NO\")\n    ",
        "inputs": [
            "3 4\n2 1 4\n3 1 3 1\n1 2\n",
            "3 3\n1 1\n1 2\n1 1\n",
            "3 4\n1 1\n1 2\n1 3\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef Mkzpg():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "List Comprehension",
                3,
                3
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "If Statement Body",
                9,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef aBlFf():\n    \"\"\"Andy got a box of candies for Christmas. In fact, he discovered that the box contained several identical smaller boxes, and they could contain even smaller boxes, and so on. Formally, we say that candies are boxes of level 0, and for 1 ≤ i ≤ n, a level i box contains ai boxes of level i - 1. The largest box has level n. Andy realized that it can take quite a long time to open all the boxes before he actually gets to eat some candies, so he put the box aside in frustration.\n\nBut today being his birthday, some friends came to visit Andy, and Andy decided to share some candies with them. In order to do that, he must open some of the boxes. Naturally, Andy can not open a box that is still inside an unopened box. If Andy wants to retrieve X candies, what is the least number of boxes he must open? You must help him answer many such queries. Each query is independent.\n\n-----Input-----\n- The first line contains two integers n and m, which refer to the level of the largest box, and the number of queries respectively.\n- The second line contains n integers a1, ..., an.\n- The third line contains m integers X1, ..., Xm.\n\n-----Output-----\n- Print m integers each in a new line, ith of them equal to the smallest number of boxes Andy must open in order to retrieve at least Xi candies.\n\n-----Constraints-----\n- 1 ≤ n,m ≤ 300000\n- 1 ≤ ai ≤ 109\n- 1 ≤ Xi ≤ 1012\n- It is guaranteed that the total number of candies is at least Xi for all i\n\n-----Example-----\nInput 1:\n5 1\n1 1 1 1 1\n1\n\nOutput 1:\n5\n\nInput 2:\n3 3\n3 3 3\n2 8 13\n\nOutput 2:\n3\n5\n8\n\n-----Explanation-----\nTestcase 1: The only candy is contained in five levels of boxes. \nTestcase 2: In the third query, for 13 candies, Andy should open the largest box, two level-2 boxes, and finally five of six available level-1 boxes. Each of those boxes will contain 3 level-0 boxes (which are candies). So he'll have 15 candies in total, but he needs only 13 of them.\n    \"\"\"\n",
        "canonical_solution": "\ndef aBlFf():\n    n,m = map(int,input().split())\n    box = list(map(int,input().split()))\n    mularr = []\n    queries = list(map(int,input().split()))\n    qm = max(queries)\n    cnt = 0\n    mularr.append([box[0],1])\n    candy = box[0]\n    for b in box[1:]:\n        if b == 1:\n         mularr[-1][1] +=1\n        else:\n         candy *= b\n         mularr.append([candy,1])\n        if qm <= candy:\n         break\n    #print(mularr)\n    for query in queries:\n        cnt = n\n        test = query\n        test-=1\n        for k,v in mularr:\n         #print(mularr[m],test)\n         add = (test//k)*v\n         cnt+=add\n        print(cnt)",
        "inputs": [
            "5 1\n1 1 1 1 1\n1\n",
            "3 3\n3 3 3\n2 8 13\n"
        ],
        "outputs": [
            "5\n",
            "3\n5\n8\n"
        ],
        "starter_code": "\ndef aBlFf():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "For Loop Body",
                11,
                18
            ],
            [
                "If Statement Body",
                12,
                16
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "For Loop Body",
                20,
                28
            ],
            [
                "For Loop Body",
                24,
                27
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def longestDecomposition(self, text: str) -> int:\n            \"\"\"Return the largest possible k such that there exists a_1, a_2, ..., a_k such that:\n\nEach a_i is a non-empty string;\nTheir concatenation a_1 + a_2 + ... + a_k is equal to text;\nFor all 1 <= i <= k,  a_i = a_{k+1 - i}.\n\n \nExample 1:\nInput: text = \"ghiabcdefhelloadamhelloabcdefghi\"\nOutput: 7\nExplanation: We can split the string on \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\n\nExample 2:\nInput: text = \"merchant\"\nOutput: 1\nExplanation: We can split the string on \"(merchant)\".\n\nExample 3:\nInput: text = \"antaprezatepzapreanta\"\nOutput: 11\nExplanation: We can split the string on \"(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)\".\n\nExample 4:\nInput: text = \"aaa\"\nOutput: 3\nExplanation: We can split the string on \"(a)(a)(a)\".\n\n \nConstraints:\n\ntext consists only of lowercase English characters.\n1 <= text.length <= 1000\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        splits = 0\n        leftstart, leftend = 0, 0\n        rightstart, rightend = n-1, n-1\n        while leftend<rightstart:\n            if text[leftstart:leftend+1] == text[rightstart:rightend+1]:\n                leftstart = leftend+1\n                leftend = leftstart\n                rightstart = rightstart-1\n                rightend = rightstart\n                splits+=2\n            else:\n                leftend+=1\n                rightstart-=1\n        return splits+1 if leftstart<=rightend else splits",
        "inputs": [
            [
                "\"ghiabcdefhelloadamhelloabcdefghi\""
            ]
        ],
        "outputs": [
            [
                7
            ]
        ],
        "starter_code": "\nclass Solution:\n    def longestDecomposition(self, text: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                17
            ],
            [
                "Function Body",
                2,
                17
            ],
            [
                "While Loop Body",
                7,
                16
            ],
            [
                "If Statement Body",
                8,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef smOoZ():\n    \"\"\"Some programming contest problems are really tricky: not only do they\nrequire a different output format from what you might have expected, but\nalso the sample output does not show the difference. For an example,\nlet us look at permutations.\n\nA permutation of the integers 1 to n is an\nordering of\nthese integers. So the natural way to represent a permutation is\nto list the integers in this order. With n = 5, a\npermutation might look like 2, 3, 4, 5, 1. \n\nHowever, there is another possibility of representing a permutation:\nYou create a list of numbers where the i-th number is the\nposition of the integer i in the permutation. \nLet us call this second\npossibility an inverse permutation. The inverse permutation\nfor the sequence above is 5, 1, 2, 3, 4.\n\nAn ambiguous permutation is a permutation which cannot be\ndistinguished from its inverse permutation. The permutation 1, 4, 3, 2\nfor example is ambiguous, because its inverse permutation is the same.\nTo get rid of such annoying sample test cases, you have to write a\nprogram which detects if a given permutation is ambiguous or not.\n\n-----Input Specification-----\nThe input contains several test cases.\n\nThe first line of each test case contains an integer n\n(1 ≤ n ≤ 100000).\nThen a permutation of the integers 1 to n follows\nin the next line. There is exactly one space character\nbetween consecutive integers.\nYou can assume that every integer between 1 and n\nappears exactly once in the permutation.\n\nThe last test case is followed by a zero.\n\n-----Output Specification-----\nFor each test case output whether the permutation is ambiguous or not.\nAdhere to the format shown in the sample output.\n\n-----Sample Input-----\n4\n1 4 3 2\n5\n2 3 4 5 1\n1\n1\n0\n\n-----Sample Output-----\nambiguous\nnot ambiguous\nambiguous\n    \"\"\"\n",
        "canonical_solution": "\ndef smOoZ():\n    def invper(ar):\n     ar1=[0]*(len(ar))\n     for i in range(len(ar)):\n      ar1[ar[i]-1]=i+1\n     return ar1\n    t=int(input())\n    \n    while(t!=0):\n     ar=list(map(int,input().split()))\n     ar1=invper(ar)\n     if(ar==ar1):\n      print(\"ambiguous\")\n     else:\n      print(\"not ambiguous\")\n     t = int(input())\n    ",
        "inputs": [
            "4\n1 4 3 2\n5\n2 3 4 5 1\n1\n1\n0\n"
        ],
        "outputs": [
            "ambiguous\nnot ambiguous\nambiguous\n"
        ],
        "starter_code": "\ndef smOoZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                17
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "For Loop Body",
                5,
                6
            ],
            [
                "While Loop Body",
                10,
                17
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gUlGm():\n    \"\"\"One tradition of ACM-ICPC contests is that a team gets a balloon for every solved problem. We assume that the submission time doesn't matter and teams are sorted only by the number of balloons they have. It means that one's place is equal to the number of teams with more balloons, increased by 1. For example, if there are seven teams with more balloons, you get the eight place. Ties are allowed.\n\nYou should know that it's important to eat before a contest. If the number of balloons of a team is greater than the weight of this team, the team starts to float in the air together with their workstation. They eventually touch the ceiling, what is strictly forbidden by the rules. The team is then disqualified and isn't considered in the standings.\n\nA contest has just finished. There are n teams, numbered 1 through n. The i-th team has t_{i} balloons and weight w_{i}. It's guaranteed that t_{i} doesn't exceed w_{i} so nobody floats initially.\n\nLimak is a member of the first team. He doesn't like cheating and he would never steal balloons from other teams. Instead, he can give his balloons away to other teams, possibly making them float. Limak can give away zero or more balloons of his team. Obviously, he can't give away more balloons than his team initially has.\n\nWhat is the best place Limak can get?\n\n\n-----Input-----\n\nThe first line of the standard input contains one integer n (2 ≤ n ≤ 300 000) — the number of teams.\n\nThe i-th of n following lines contains two integers t_{i} and w_{i} (0 ≤ t_{i} ≤ w_{i} ≤ 10^18) — respectively the number of balloons and the weight of the i-th team. Limak is a member of the first team.\n\n\n-----Output-----\n\nPrint one integer denoting the best place Limak can get.\n\n\n-----Examples-----\nInput\n8\n20 1000\n32 37\n40 1000\n45 50\n16 16\n16 16\n14 1000\n2 1000\n\nOutput\n3\n\nInput\n7\n4 4\n4 4\n4 4\n4 4\n4 4\n4 4\n5 5\n\nOutput\n2\n\nInput\n7\n14000000003 1000000000000000000\n81000000000 88000000000\n5000000000 7000000000\n15000000000 39000000000\n46000000000 51000000000\n0 1000000000\n0 0\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Limak has 20 balloons initially. There are three teams with more balloons (32, 40 and 45 balloons), so Limak has the fourth place initially. One optimal strategy is: Limak gives 6 balloons away to a team with 32 balloons and weight 37, which is just enough to make them fly. Unfortunately, Limak has only 14 balloons now and he would get the fifth place. Limak gives 6 balloons away to a team with 45 balloons. Now they have 51 balloons and weight 50 so they fly and get disqualified. Limak gives 1 balloon to each of two teams with 16 balloons initially. Limak has 20 - 6 - 6 - 1 - 1 = 6 balloons. There are three other teams left and their numbers of balloons are 40, 14 and 2. Limak gets the third place because there are two teams with more balloons. \n\nIn the second sample, Limak has the second place and he can't improve it.\n\nIn the third sample, Limak has just enough balloons to get rid of teams 2, 3 and 5 (the teams with 81 000 000 000, 5 000 000 000 and 46 000 000 000 balloons respectively). With zero balloons left, he will get the second place (ex-aequo with team 6 and team 7).\n    \"\"\"\n",
        "canonical_solution": "from bisect import bisect_right\nimport heapq\ndef gUlGm():\n    n = int(input())\n    l = []\n    ti, wi = list(map(int, input().split()))\n    bal = ti\n    pos = 1\n    for _ in range(n - 1):\n        ti, wi = list(map(int, input().split()))\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    #print(l)\n    w = []\n    for i, v in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        #print(w, op)\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    print(best_pos)",
        "inputs": [
            "8\n20 1000\n32 37\n40 1000\n45 50\n16 16\n16 16\n14 1000\n2 1000\n",
            "7\n4 4\n4 4\n4 4\n4 4\n4 4\n4 4\n5 5\n",
            "7\n14000000003 1000000000000000000\n81000000000 88000000000\n5000000000 7000000000\n15000000000 39000000000\n46000000000 51000000000\n0 1000000000\n0 0\n"
        ],
        "outputs": [
            "3\n",
            "2\n",
            "2\n"
        ],
        "starter_code": "\ndef gUlGm():\n",
        "scope": [
            [
                "Function Body",
                3,
                34
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "While Loop Body",
                22,
                33
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "While Loop Body",
                29,
                32
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fSgPz():\n    \"\"\"Tired of boring office work, Denis decided to open a fast food restaurant.\n\nOn the first day he made $a$ portions of dumplings, $b$ portions of cranberry juice and $c$ pancakes with condensed milk.\n\nThe peculiarity of Denis's restaurant is the procedure of ordering food. For each visitor Denis himself chooses a set of dishes that this visitor will receive. When doing so, Denis is guided by the following rules:  every visitor should receive at least one dish (dumplings, cranberry juice, pancakes with condensed milk are all considered to be dishes);  each visitor should receive no more than one portion of dumplings, no more than one portion of cranberry juice and no more than one pancake with condensed milk;  all visitors should receive different sets of dishes. \n\nWhat is the maximum number of visitors Denis can feed?\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 500$) — the number of test cases to solve.\n\nEach of the remaining $t$ lines contains integers $a$, $b$ and $c$ ($0 \\leq a, b, c \\leq 10$) — the number of portions of dumplings, the number of portions of cranberry juice and the number of condensed milk pancakes Denis made.\n\n\n-----Output-----\n\nFor each test case print a single integer — the maximum number of visitors Denis can feed.\n\n\n-----Example-----\nInput\n7\n1 2 1\n0 0 0\n9 1 7\n2 2 3\n2 3 2\n3 2 2\n4 4 4\n\nOutput\n3\n0\n4\n5\n5\n5\n7\n\n\n\n-----Note-----\n\nIn the first test case of the example, Denis can feed the first visitor with dumplings, give the second a portion of cranberry juice, and give the third visitor a portion of cranberry juice and a pancake with a condensed milk.\n\nIn the second test case of the example, the restaurant Denis is not very promising: he can serve no customers.\n\nIn the third test case of the example, Denise can serve four visitors. The first guest will receive a full lunch of dumplings, a portion of cranberry juice and a pancake with condensed milk. The second visitor will get only dumplings. The third guest will receive a pancake with condensed milk, and the fourth guest will receive a pancake and a portion of dumplings. Please note that Denis hasn't used all of the prepared products, but is unable to serve more visitors.\n    \"\"\"\n",
        "canonical_solution": "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ndef fSgPz():\n    input = sys.stdin.readline\n     \n    M = mod = 10**9 + 7\n    def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n    def inv_mod(n):return pow(n, mod - 2, mod)\n     \n    def li():return [int(i) for i in input().rstrip('\\n').split(' ')]\n    def st():return input().rstrip('\\n')\n    def val():return int(input().rstrip('\\n'))\n    def li2():return [i for i in input().rstrip('\\n').split(' ')]\n    def li3():return [int(i) for i in input().rstrip('\\n')]\n    for _ in range(val()):\n        a,b,c = sorted(li())\n        tot = 0\n        if a:\n            tot += 1\n            a -= 1\n        if b:\n            tot += 1\n            b -= 1\n        if c:\n            tot += 1\n            c -= 1\n        if b and c:\n            tot += 1\n            b -= 1\n            c -= 1\n        if a and c:\n            tot += 1\n            a -= 1\n            c -= 1\n        if b and a:\n            b -= 1\n            a -= 1\n            tot += 1\n        if a and b and c:\n            a -= 1\n            b -= 1\n            c -= 1\n            tot += 1\n        print(tot)",
        "inputs": [
            "7\n1 2 1\n0 0 0\n9 1 7\n2 2 3\n2 3 2\n3 2 2\n4 4 4\n",
            "2\n2 2 8\n3 2 2\n"
        ],
        "outputs": [
            "3\n0\n4\n5\n5\n5\n7\n",
            "5\n5\n"
        ],
        "starter_code": "\ndef fSgPz():\n",
        "scope": [
            [
                "Function Body",
                8,
                49
            ],
            [
                "Function Body",
                12,
                12
            ],
            [
                "Generator Expression",
                12,
                12
            ],
            [
                "Function Body",
                13,
                13
            ],
            [
                "Function Body",
                15,
                15
            ],
            [
                "List Comprehension",
                15,
                15
            ],
            [
                "Function Body",
                16,
                16
            ],
            [
                "Function Body",
                17,
                17
            ],
            [
                "Function Body",
                18,
                18
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "Function Body",
                19,
                19
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "For Loop Body",
                20,
                49
            ],
            [
                "If Statement Body",
                23,
                25
            ],
            [
                "If Statement Body",
                26,
                28
            ],
            [
                "If Statement Body",
                29,
                31
            ],
            [
                "If Statement Body",
                32,
                35
            ],
            [
                "If Statement Body",
                36,
                39
            ],
            [
                "If Statement Body",
                40,
                43
            ],
            [
                "If Statement Body",
                44,
                48
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef nMale():\n    \"\"\"Alice and Bob love playing one-dimensional battle ships. They play on the field in the form of a line consisting of n square cells (that is, on a 1 × n table).\n\nAt the beginning of the game Alice puts k ships on the field without telling their positions to Bob. Each ship looks as a 1 × a rectangle (that is, it occupies a sequence of a consecutive squares of the field). The ships cannot intersect and even touch each other.\n\nAfter that Bob makes a sequence of \"shots\". He names cells of the field and Alice either says that the cell is empty (\"miss\"), or that the cell belongs to some ship (\"hit\").\n\nBut here's the problem! Alice like to cheat. May be that is why she responds to each Bob's move with a \"miss\". \n\nHelp Bob catch Alice cheating — find Bob's first move, such that after it you can be sure that Alice cheated.\n\n\n-----Input-----\n\nThe first line of the input contains three integers: n, k and a (1 ≤ n, k, a ≤ 2·10^5) — the size of the field, the number of the ships and the size of each ship. It is guaranteed that the n, k and a are such that you can put k ships of size a on the field, so that no two ships intersect or touch each other.\n\nThe second line contains integer m (1 ≤ m ≤ n) — the number of Bob's moves.\n\nThe third line contains m distinct integers x_1, x_2, ..., x_{m}, where x_{i} is the number of the cell where Bob made the i-th shot. The cells are numbered from left to right from 1 to n.\n\n\n-----Output-----\n\nPrint a single integer — the number of such Bob's first move, after which you can be sure that Alice lied. Bob's moves are numbered from 1 to m in the order the were made. If the sought move doesn't exist, then print \"-1\".\n\n\n-----Examples-----\nInput\n11 3 3\n5\n4 8 6 1 11\n\nOutput\n3\n\nInput\n5 1 3\n2\n1 5\n\nOutput\n-1\n\nInput\n5 1 3\n1\n3\n\nOutput\n1\n    \"\"\"\n",
        "canonical_solution": "\ndef nMale():\n    n,k,a = map(int,input().split())\n    m = int(input())\n    x = [int(y) for y in input().split()]\n    \n    def check(K):\n        used = [0]*(n+1)\n        for i in range(K):\n            used[x[i]] = 1\n        for i in range(1,n+1):\n            used[i]+=used[i-1]\n        have = 0\n        i = a\n        while i<n+1:\n            if used[i]-used[i-a]==0:\n                have+=1\n                i+=a\n            i+=1\n        return have>=k\n    \n    if check(m):\n        print(-1)\n    else:\n        low = -1\n        high = m\n        while high-low>1:\n            if check((low+high+1)//2):\n                low = (low+high+1)//2\n            else:\n                high = (low+high+1)//2\n        print(high)",
        "inputs": [
            "11 3 3\n5\n4 8 6 1 11\n",
            "5 1 3\n2\n1 5\n",
            "5 1 3\n1\n3\n"
        ],
        "outputs": [
            "3\n",
            "-1\n",
            "1\n"
        ],
        "starter_code": "\ndef nMale():\n",
        "scope": [
            [
                "Function Body",
                2,
                32
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "Function Body",
                7,
                20
            ],
            [
                "For Loop Body",
                9,
                10
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "While Loop Body",
                15,
                19
            ],
            [
                "If Statement Body",
                16,
                18
            ],
            [
                "If Statement Body",
                22,
                32
            ],
            [
                "While Loop Body",
                27,
                31
            ],
            [
                "If Statement Body",
                28,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef JSbGu():\n    \"\"\"The Fair Nut lives in $n$ story house. $a_i$ people live on the $i$-th floor of the house. Every person uses elevator twice a day: to get from the floor where he/she lives to the ground (first) floor and to get from the first floor to the floor where he/she lives, when he/she comes back home in the evening. \n\nIt was decided that elevator, when it is not used, will stay on the $x$-th floor, but $x$ hasn't been chosen yet. When a person needs to get from floor $a$ to floor $b$, elevator follows the simple algorithm:   Moves from the $x$-th floor (initially it stays on the $x$-th floor) to the $a$-th and takes the passenger.  Moves from the $a$-th floor to the $b$-th floor and lets out the passenger (if $a$ equals $b$, elevator just opens and closes the doors, but still comes to the floor from the $x$-th floor).  Moves from the $b$-th floor back to the $x$-th.  The elevator never transposes more than one person and always goes back to the floor $x$ before transposing a next passenger. The elevator spends one unit of electricity to move between neighboring floors. So moving from the $a$-th floor to the $b$-th floor requires $|a - b|$ units of electricity.\n\nYour task is to help Nut to find the minimum number of electricity units, that it would be enough for one day, by choosing an optimal the $x$-th floor. Don't forget than elevator initially stays on the $x$-th floor. \n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\leq n \\leq 100$) — the number of floors.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\leq a_i \\leq 100$) — the number of people on each floor.\n\n\n-----Output-----\n\nIn a single line, print the answer to the problem — the minimum number of electricity units.\n\n\n-----Examples-----\nInput\n3\n0 2 1\n\nOutput\n16\nInput\n2\n1 1\n\nOutput\n4\n\n\n-----Note-----\n\nIn the first example, the answer can be achieved by choosing the second floor as the $x$-th floor. Each person from the second floor (there are two of them) would spend $4$ units of electricity per day ($2$ to get down and $2$ to get up), and one person from the third would spend $8$ units of electricity per day ($4$ to get down and $4$ to get up). $4 \\cdot 2 + 8 \\cdot 1 = 16$.\n\nIn the second example, the answer can be achieved by choosing the first floor as the $x$-th floor.\n    \"\"\"\n",
        "canonical_solution": "\ndef JSbGu():\n    n = int(input())\n    line = input().split()\n    ans = 0\n    for i in range(n):\n        ans += int(line[i])*i\n    print(4*ans)\n    ",
        "inputs": [
            "3\n0 2 1\n",
            "2\n1 1\n",
            "1\n1\n"
        ],
        "outputs": [
            "16",
            "4",
            "0"
        ],
        "starter_code": "\ndef JSbGu():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "For Loop Body",
                6,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef jPRVJ():\n    \"\"\"Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink \"Beecola\", which can be bought in n different shops in the city. It's known that the price of one bottle in the shop i is equal to x_{i} coins.\n\nVasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent m_{i} coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of \"Beecola\".\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of shops in the city that sell Vasiliy's favourite drink.\n\nThe second line contains n integers x_{i} (1 ≤ x_{i} ≤ 100 000) — prices of the bottles of the drink in the i-th shop.\n\nThe third line contains a single integer q (1 ≤ q ≤ 100 000) — the number of days Vasiliy plans to buy the drink.\n\nThen follow q lines each containing one integer m_{i} (1 ≤ m_{i} ≤ 10^9) — the number of coins Vasiliy can spent on the i-th day.\n\n\n-----Output-----\n\nPrint q integers. The i-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the i-th day.\n\n\n-----Example-----\nInput\n5\n3 10 8 6 11\n4\n1\n10\n3\n11\n\nOutput\n0\n4\n1\n5\n\n\n\n-----Note-----\n\nOn the first day, Vasiliy won't be able to buy a drink in any of the shops.\n\nOn the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.\n\nOn the third day, Vasiliy can buy a drink only in the shop number 1.\n\nFinally, on the last day Vasiliy can buy a drink in any shop.\n    \"\"\"\n",
        "canonical_solution": "import bisect\ndef jPRVJ():\n    n = int(input())\n    p = list(map(int, input().split()))\n    p.sort()\n    q = int(input())\n    for i in range(q):\n        c = int(input())\n        print(bisect.bisect_right(p, c))\n        ",
        "inputs": [
            "5\n3 10 8 6 11\n4\n1\n10\n3\n11\n",
            "5\n868 987 714 168 123\n10\n424\n192\n795\n873\n117\n914\n735\n158\n631\n471\n",
            "3\n435 482 309\n7\n245\n241\n909\n745\n980\n29\n521\n"
        ],
        "outputs": [
            "0\n4\n1\n5\n",
            "2\n2\n3\n4\n0\n4\n3\n1\n2\n2\n",
            "0\n0\n3\n3\n3\n0\n3\n"
        ],
        "starter_code": "\ndef jPRVJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                7,
                9
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef LCnRg():\n    \"\"\"You are given three non-negative integers $X$, $Y$ and $N$. Find the number of integers $Z$ such that $0 \\le Z \\le N$ and $(X \\oplus Z) < (Y \\oplus Z)$, where $\\oplus$ denotes the bitwise XOR operation.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains three space-separated integers $X$, $Y$ and $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of integers $Z$ which satisfy all conditions.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $0 \\le X, Y, N \\le 2^{30} - 1$\n\n-----Subtasks-----\nSubtask #1 (5 points): $X, Y, N \\le 2^6 - 1$\nSubtask #2 (95 points): original constraints\n\n-----Example Input-----\n3\n1 2 10\n2 1 10\n0 0 7\n\n-----Example Output-----\n6\n5\n0\n    \"\"\"\n",
        "canonical_solution": "\ndef LCnRg():\n    # cook your dish here\n    tc=int(input())\n    for j in range(tc):\n     ip=list(map(int,input().rstrip().split()))\n     x=ip[0]\n     y=ip[1]\n     n=ip[2]\n     cnt=0\n     if(x==y):\n      print('0')\n      continue\n     ln=bin(x).replace(\"0b\", \"\") \n     rn=bin(y).replace(\"0b\", \"\") \n     ll=len(ln)\n     rl=len(rn)\n     #print(ln)\n     #print(rn)\n     if(ll==len(rn)):\n      for i in range(ll):\n       \n       if(ln[i]!=rn[i]):\n        ln=ln[i:]\n        rn=rn[i:]\n        break\n     #print(ln)\n     if(ln[0]=='0'):\n      ln=ln[1:]\n      ll-=1\n     #print(rn)\n     if(rn[0]=='0'):\n      rn=rn[1:]\n      rl-=1\n     ll=len(ln)\n     rl=len(rn)\n     if(ll>rl):\n      lb=ll \n     else:\n      lb=rl \n     pl=2**lb \n     hpl=pl//2\n     amn=((n+1)//pl)*hpl \n     rm=(n+1)%pl \n     if((rm*2)<=pl):\n      amn+=rm\n     else:\n      amn+=hpl \n     #print(\"amn = \",amn)\n     aln=(n+1)-amn\n     #print(\"aln = \",aln)\n     if(x<y):\n      print(amn)\n     else:\n      print(aln)",
        "inputs": [
            "3\n1 2 10\n2 1 10\n0 0 7\n"
        ],
        "outputs": [
            "6\n5\n0\n"
        ],
        "starter_code": "\ndef LCnRg():\n",
        "scope": [
            [
                "Function Body",
                2,
                55
            ],
            [
                "For Loop Body",
                5,
                55
            ],
            [
                "If Statement Body",
                11,
                13
            ],
            [
                "If Statement Body",
                20,
                26
            ],
            [
                "For Loop Body",
                21,
                26
            ],
            [
                "If Statement Body",
                23,
                26
            ],
            [
                "If Statement Body",
                28,
                30
            ],
            [
                "If Statement Body",
                32,
                34
            ],
            [
                "If Statement Body",
                37,
                40
            ],
            [
                "If Statement Body",
                45,
                48
            ],
            [
                "If Statement Body",
                52,
                55
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef BqJzY():\n    \"\"\"Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite \"Le Hamburger de Polycarpus\" as a string of letters 'B' (bread), 'S' (sausage) и 'C' (cheese). The ingredients in the recipe go from bottom to top, for example, recipe \"ВSCBS\" represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.\n\nPolycarpus has n_{b} pieces of bread, n_{s} pieces of sausage and n_{c} pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are p_{b} rubles for a piece of bread, p_{s} for a piece of sausage and p_{c} for a piece of cheese.\n\nPolycarpus has r rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient.\n\n\n-----Input-----\n\nThe first line of the input contains a non-empty string that describes the recipe of \"Le Hamburger de Polycarpus\". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C).\n\nThe second line contains three integers n_{b}, n_{s}, n_{c} (1 ≤ n_{b}, n_{s}, n_{c} ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers p_{b}, p_{s}, p_{c} (1 ≤ p_{b}, p_{s}, p_{c} ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 10^12) — the number of rubles Polycarpus has.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\nPrint the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.\n\n\n-----Examples-----\nInput\nBBBSSC\n6 4 1\n1 2 3\n4\n\nOutput\n2\n\nInput\nBBC\n1 10 1\n1 10 1\n21\n\nOutput\n7\n\nInput\nBSC\n1 1 1\n1 1 3\n1000000000000\n\nOutput\n200000000001\n    \"\"\"\n",
        "canonical_solution": "\ndef BqJzY():\n    def main():\n        s = input()\n        a = b = c = 0\n        for elem in s:\n            if elem == \"B\":\n                a += 1\n            elif elem == \"S\":\n                b += 1\n            else:\n                c += 1\n        na, nb, nc = map(int, input().split())\n        pa, pb, pc = map(int, input().split())\n        k = int(input())\n    \n        l = 0\n        r = 10**13\n        while r - l > 1:\n            m = (l + r) // 2\n            cntA = max(0, a * m - na)\n            cntB = max(0, b * m - nb)\n            cntC = max(0, c * m - nc)\n            money = cntA * pa + cntB * pb + cntC * pc\n            if money <= k:\n                l = m\n            else:\n                r = m\n        print(l)\n    \n    main()",
        "inputs": [
            "BBBSSC\n6 4 1\n1 2 3\n4\n",
            "BBC\n1 10 1\n1 10 1\n21\n",
            "BSC\n1 1 1\n1 1 3\n1000000000000\n"
        ],
        "outputs": [
            "2\n",
            "7\n",
            "200000000001\n"
        ],
        "starter_code": "\ndef BqJzY():\n",
        "scope": [
            [
                "Function Body",
                2,
                31
            ],
            [
                "Function Body",
                3,
                29
            ],
            [
                "For Loop Body",
                6,
                12
            ],
            [
                "If Statement Body",
                7,
                12
            ],
            [
                "If Statement Body",
                9,
                12
            ],
            [
                "While Loop Body",
                19,
                28
            ],
            [
                "If Statement Body",
                25,
                28
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fOnHC():\n    \"\"\"Zonal Computing Olympiad 2012, 26 Nov 2011\n\nA sequence of opening and closing brackets is well-bracketed if we can pair up each opening bracket with a matching closing bracket in the usual sense.  For instance, the sequences (), (()) and ()(()) are well-bracketed, while (, ()), (()(), and )(  are not well-bracketed.\n\nThe nesting depth of a well-bracketed sequence tells us the maximum number of levels of inner matched brackets enclosed within outer matched brackets.  For instance, the nesting depth of () and ()()() is 1, the nesting depth of (()) and ()(()) is 2, the nesting depth of ((())) is 3, and so on.  \n\nGiven a well-bracketed sequence, we are interested in computing the following: \n-  The nesting depth, and the first position where it occurs–this will be the position of the first opening bracket at this nesting depth, where the positions are numbered starting with 1.\n-  The maximum number of symbols between any pair of matched  brackets, including both the outer brackets, and the first position where this occurs–that is, the position of the first opening bracket of this segment\n\nFor instance, the nesting depth of ()(())()(()())(()()) is 2 and the first position where this occurs is 4.  The opening bracket at position 10 is also at nesting depth 2 but we have to report the first position where this occurs, which is 4.\n\nIn this sequence, the maximum number of symbols between a pair of matched bracket is 6, starting at position 9. There is another such sequence of length 6 starting at position 15, but this is not the first such position.\n\n-----Input format-----\nThe input consists of two lines. The first line is a single integer N, the length of the bracket sequence. Positions in the sequence are numbered 1,2,…,N. The second line is a sequence of N space-separated integers that encode the bracket expression as follows: 1 denotes an opening bracket ( and 2 denotes a closing bracket ).  Nothing other than 1 or 2 appears in the second line of input and the corresponding expression is guaranteed to be well-bracketed.\n\n-----Output format-----\nYour program should print 4 space-separated integers in a line, denoting the four quantities asked for in the following order: nesting depth, first position that achieves the nesting depth, length of the maximum sequence between matching brackets and the first position where such a maximum length sequence occurs.  \n\n-----Testdata-----\n\nYou may assume that 2 ≤ N ≤ 105.  In 30% of the test cases, 2 ≤ N ≤ 103.\n\n- Subtask 1 (30 marks)\n- Subtask 2 (70 marks)\n\n-----Sample Input-----\n20\n1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 1 2 1 2 2\n\n-----Sample Output-----\n2 4 6 9\n    \"\"\"\n",
        "canonical_solution": "\ndef fOnHC():\n    # cook your dish here\n    \n    T = int(input())\n    l = list(map(int, input().strip().split(\" \")))\n    \n    depth = 0\n    max_depth = 0\n    max_depth_index = 0\n    \n    max_l=0\n    max_l_index=0\n    last_zero=-1\n    \n    for i in range(T):\n        if l[i] == 1:\n            depth += 1\n            if depth > max_depth:\n                max_depth = depth\n                max_depth_index = i + 1\n        else:\n            depth-=1\n            if depth == 0:\n                length = i - last_zero\n                if length > max_l:\n                    max_l = length\n                    max_l_index = last_zero + 2\n                last_zero = i\n            \n    print(max_depth, max_depth_index, max_l, max_l_index)\n    \n    \"\"\"\n    2 4 6 9\n    \"\"\"",
        "inputs": [
            "20\n1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 1 2 1 2 2\n"
        ],
        "outputs": [
            "2 4 6 9\n"
        ],
        "starter_code": "\ndef fOnHC():\n",
        "scope": [
            [
                "Function Body",
                2,
                35
            ],
            [
                "For Loop Body",
                16,
                29
            ],
            [
                "If Statement Body",
                17,
                29
            ],
            [
                "If Statement Body",
                19,
                21
            ],
            [
                "If Statement Body",
                24,
                29
            ],
            [
                "If Statement Body",
                26,
                28
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def countTriplets(self, A: List[int]) -> int:\n            \"\"\"Given an array of integers A, find the number of triples of indices (i, j, k) such that:\n\n0 <= i < A.length\n0 <= j < A.length\n0 <= k < A.length\nA[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.\n\n \nExample 1:\nInput: [2,1,3]\nOutput: 12\nExplanation: We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0, j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 & 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) : 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0, k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\n \nNote:\n\n1 <= A.length <= 1000\n0 <= A[i] < 2^16\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def countTriplets(self, A: List[int]) -> int:\n        counters = [0] * (1 << 16)\n        counters[0] = len(A)\n        for num in A:\n            mask = (~num) & ((1 << 16) - 1)\n            sm = mask\n            while sm != 0:\n                counters[sm] += 1\n                sm = (sm - 1) & mask\n        \n        return sum(counters[num1 & num2] for num1 in A for num2 in A)\n",
        "inputs": [
            [
                [
                    2,
                    1,
                    3
                ]
            ]
        ],
        "outputs": [
            [
                12
            ]
        ],
        "starter_code": "\nclass Solution:\n    def countTriplets(self, A: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                12
            ],
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                5,
                10
            ],
            [
                "While Loop Body",
                8,
                10
            ],
            [
                "Generator Expression",
                12,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef kXTGi():\n    \"\"\"Polycarp has a checkered sheet of paper of size n × m. Polycarp painted some of cells with black, the others remained white. Inspired by Malevich's \"Black Square\", Polycarp wants to paint minimum possible number of white cells with black so that all black cells form a square.\n\nYou are to determine the minimum possible number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. The square's side should have positive length.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 100) — the sizes of the sheet.\n\nThe next n lines contain m letters 'B' or 'W' each — the description of initial cells' colors. If a letter is 'B', then the corresponding cell is painted black, otherwise it is painted white.\n\n\n-----Output-----\n\nPrint the minimum number of cells needed to be painted black so that the black cells form a black square with sides parallel to the painting's sides. All the cells that do not belong to the square should be white. If it is impossible, print -1.\n\n\n-----Examples-----\nInput\n5 4\nWWWW\nWWWB\nWWWB\nWWBB\nWWWW\n\nOutput\n5\n\nInput\n1 2\nBB\n\nOutput\n-1\n\nInput\n3 3\nWWW\nWWW\nWWW\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example it is needed to paint 5 cells — (2, 2), (2, 3), (3, 2), (3, 3) and (4, 2). Then there will be a square with side equal to three, and the upper left corner in (2, 2).\n\nIn the second example all the cells are painted black and form a rectangle, so it's impossible to get a square.\n\nIn the third example all cells are colored white, so it's sufficient to color any cell black.\n    \"\"\"\n",
        "canonical_solution": "\ndef kXTGi():\n    h, w = map(int, input().split())\n    x0, y0, x1, y1, c = 1000, 1000, -1, -1, 0\n    for i in range(h):\n      row = str(input())\n      for j in range(w):\n        if row[j] == 'B':\n          x0, y0, x1, y1, c = min(x0, i), min(y0, j), max(x1, i), max(y1, j), c + 1\n    ln = max(x1 - x0 + 1, y1 - y0 + 1)\n    if ln > min(h, w):\n      print(-1)\n    elif x1 == -1:\n      print(1)\n    else:\n      print(ln * ln - c)",
        "inputs": [
            "5 4\nWWWW\nWWWB\nWWWB\nWWBB\nWWWW\n",
            "1 2\nBB\n",
            "3 3\nWWW\nWWW\nWWW\n"
        ],
        "outputs": [
            "5\n",
            "-1\n",
            "1\n"
        ],
        "starter_code": "\ndef kXTGi():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                5,
                9
            ],
            [
                "For Loop Body",
                7,
                9
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "If Statement Body",
                11,
                16
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef DQwPy():\n    \"\"\"Reminder: the median of the array $[a_1, a_2, \\dots, a_{2k+1}]$ of odd number of elements is defined as follows: let $[b_1, b_2, \\dots, b_{2k+1}]$ be the elements of the array in the sorted order. Then median of this array is equal to $b_{k+1}$.\n\nThere are $2n$ students, the $i$-th student has skill level $a_i$. It's not guaranteed that all skill levels are distinct.\n\nLet's define skill level of a class as the median of skill levels of students of the class.\n\nAs a principal of the school, you would like to assign each student to one of the $2$ classes such that each class has odd number of students (not divisible by $2$). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.\n\nWhat is the minimum possible absolute difference you can achieve?\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of students halved.\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\dots, a_{2 n}$ ($1 \\le a_i \\le 10^9$) — skill levels of students.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.\n\n\n-----Example-----\nInput\n3\n1\n1 1\n3\n6 5 4 1 2 3\n5\n13 4 20 13 2 5 8 3 17 16\n\nOutput\n0\n1\n5\n\n\n\n-----Note-----\n\nIn the first test, there is only one way to partition students — one in each class. The absolute difference of the skill levels will be $|1 - 1| = 0$.\n\nIn the second test, one of the possible partitions is to make the first class of students with skill levels $[6, 4, 2]$, so that the skill level of the first class will be $4$, and second with $[5, 1, 3]$, so that the skill level of the second class will be $3$. Absolute difference will be $|4 - 3| = 1$.\n\nNote that you can't assign like $[2, 3]$, $[6, 5, 4, 1]$ or $[]$, $[6, 5, 4, 1, 2, 3]$ because classes have even number of students.\n\n$[2]$, $[1, 3, 4]$ is also not possible because students with skills $5$ and $6$ aren't assigned to a class.\n\nIn the third test you can assign the students in the following way: $[3, 4, 13, 13, 20], [2, 5, 8, 16, 17]$ or $[3, 8, 17], [2, 4, 5, 13, 13, 16, 20]$. Both divisions give minimal possible absolute difference.\n    \"\"\"\n",
        "canonical_solution": "\ndef DQwPy():\n    for _ in range(int(input())):\n        n = int(input())\n        ar = list(map(int, input().split()))\n        ar.sort()\n        print(abs(ar[n] - ar[n - 1]))",
        "inputs": [
            "3\n1\n1 1\n3\n6 5 4 1 2 3\n5\n13 4 20 13 2 5 8 3 17 16\n"
        ],
        "outputs": [
            "0\n1\n5\n"
        ],
        "starter_code": "\ndef DQwPy():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "For Loop Body",
                3,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef iLQJP():\n    \"\"\"Sereja owns a restaurant for n people. The restaurant hall has a coat rack with n hooks. Each restaurant visitor can use a hook to hang his clothes on it. Using the i-th hook costs a_{i} rubles. Only one person can hang clothes on one hook.\n\nTonight Sereja expects m guests in the restaurant. Naturally, each guest wants to hang his clothes on an available hook with minimum price (if there are multiple such hooks, he chooses any of them). However if the moment a guest arrives the rack has no available hooks, Sereja must pay a d ruble fine to the guest. \n\nHelp Sereja find out the profit in rubles (possibly negative) that he will get tonight. You can assume that before the guests arrive, all hooks on the rack are available, all guests come at different time, nobody besides the m guests is visiting Sereja's restaurant tonight.\n\n\n-----Input-----\n\nThe first line contains two integers n and d (1 ≤ n, d ≤ 100). The next line contains integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 100). The third line contains integer m (1 ≤ m ≤ 100).\n\n\n-----Output-----\n\nIn a single line print a single integer — the answer to the problem.\n\n\n-----Examples-----\nInput\n2 1\n2 1\n2\n\nOutput\n3\n\nInput\n2 1\n2 1\n10\n\nOutput\n-5\n\n\n\n-----Note-----\n\nIn the first test both hooks will be used, so Sereja gets 1 + 2 = 3 rubles.\n\nIn the second test both hooks will be used but Sereja pays a fine 8 times, so the answer is 3 - 8 =  - 5.\n    \"\"\"\n",
        "canonical_solution": "\ndef iLQJP():\n    n,d=list(map(int,input().split()))\n    \n    A=list(map(int,input().split()))\n    \n    m=int(input())\n    \n    A.sort()\n    \n    if(m<=n):\n        print(sum(A[:m]))\n    \n    else:\n        print(sum(A)-(d*(m-n)))\n    ",
        "inputs": [
            "2 1\n2 1\n2\n",
            "2 1\n2 1\n10\n",
            "1 1\n1\n2\n"
        ],
        "outputs": [
            "3\n",
            "-5\n",
            "0\n"
        ],
        "starter_code": "\ndef iLQJP():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "If Statement Body",
                11,
                15
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef dSPuO():\n    \"\"\"You are given two integers $n$ and $k$. Your task is to find if $n$ can be represented as a sum of $k$ distinct positive odd (not divisible by $2$) integers or not.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^5$) — the number of test cases.\n\nThe next $t$ lines describe test cases. The only line of the test case contains two integers $n$ and $k$ ($1 \\le n, k \\le 10^7$).\n\n\n-----Output-----\n\nFor each test case, print the answer — \"YES\" (without quotes) if $n$ can be represented as a sum of $k$ distinct positive odd (not divisible by $2$) integers and \"NO\" otherwise.\n\n\n-----Example-----\nInput\n6\n3 1\n4 2\n10 3\n10 2\n16 4\n16 5\n\nOutput\nYES\nYES\nNO\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test case, you can represent $3$ as $3$.\n\nIn the second test case, the only way to represent $4$ is $1+3$.\n\nIn the third test case, you cannot represent $10$ as the sum of three distinct positive odd integers.\n\nIn the fourth test case, you can represent $10$ as $3+7$, for example.\n\nIn the fifth test case, you can represent $16$ as $1+3+5+7$.\n\nIn the sixth test case, you cannot represent $16$ as the sum of five distinct positive odd integers.\n    \"\"\"\n",
        "canonical_solution": "\ndef dSPuO():\n    t = int(input())\n    for _ in range(t):\n    \tn, k = map(int, input().split())\n    \tn -= k**2\n    \tif n<0:\n    \t\tprint(\"NO\")\n    \telif n%2 == 0:\n    \t\tprint(\"YES\")\n    \telse:\n    \t\tprint(\"NO\")",
        "inputs": [
            "6\n3 1\n4 2\n10 3\n10 2\n16 4\n16 5\n",
            "1\n994999 23\n",
            "11\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n4 2\n"
        ],
        "outputs": [
            "YES\nYES\nNO\nYES\nYES\nNO\n",
            "YES\n",
            "YES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        ],
        "starter_code": "\ndef dSPuO():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                4,
                12
            ],
            [
                "If Statement Body",
                7,
                12
            ],
            [
                "If Statement Body",
                9,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wmUJR():\n    \"\"\"The Jones Trucking Company tracks the location of each of its trucks on a grid similar to an (x, y) plane. The home office is at the location (0, 0). Read the coordinates of truck A and the coordinates of truck B and determine which is closer to the office.\n\n-----Input:-----\nThe first line of the data set for this problem is an integer representing the number of collections of data that follow. Each collection contains 4 integers: the x-coordinate and then the \ny-coordinate of truck A followed by the x-coordinate and then the  y-coordinate of truck B.\n\n-----Output:-----\nAll letters are upper case.\nThe output is to be formatted exactly like that for the sample output given below.\n\n-----Assumptions:-----\nThe x-coordinate is in the range –20 .. 20. The y-coordinate is in the range –20 .. 20.\n\n-----Discussion:-----\nThe distance between point #1 with coordinates (x1, y1) and point #2 with coordinates (x2, y2) is:\n\n-----Sample Input:-----\n4\n3 -2 -5 -3\n0 6 1 2\n-7 8 4 -1\n3 3 -2 2\n\n-----Sample Output:-----\nA IS CLOSER\nB IS CLOSER\nB IS CLOSER\nB IS CLOSER\n    \"\"\"\n",
        "canonical_solution": "\ndef wmUJR():\n    # cook your dish here\n    try:\n     t = int(input())\n     for i in range(t):\n      ar=list(map(int,input().split()))\n      if (ar[0]**2 + ar[1]**2 > ar[2]**2 + ar[3]**2):\n       print(\"B IS CLOSER\")\n      else:\n       print(\"A IS CLOSER\")\n      \n      \n      \n    except:\n     pass\n     \n     \n    ",
        "inputs": [
            "4\n3 -2 -5 -3\n0 6 1 2\n-7 8 4 -1\n3 3 -2 2\n"
        ],
        "outputs": [
            "A IS CLOSER\nB IS CLOSER\nB IS CLOSER\nB IS CLOSER\n"
        ],
        "starter_code": "\ndef wmUJR():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "Try Block",
                4,
                16
            ],
            [
                "Except Block",
                15,
                16
            ],
            [
                "For Loop Body",
                6,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ACKIr():\n    \"\"\"In Snakeland, there are some snakes and mongooses. They are lined up in a row. The information about how exactly they are lined up it is provided to you by a string of length n. If the i-th character of this string is 's', then it means that there is a snake at the i-th position, whereas the character 'm' denotes a mongoose.\nYou might have heard about the age-old rivalry between hares and tortoises, but in Snakeland, the rivalry between snakes and mongooses is much more famous. The snakes and the mongooses want to hold a final poll in which the ultimate winner of this age-old battle will be decided. If the snakes get more votes than the mongooses, they will be the ultimate winners. Similarly, if the mongooses get more votes than snakes, they will be the ultimate winners. Obviously, each animal is loyal to their species, i.e. each snake will vote for the snakes to be the ultimate champions and each mongoose for the mongooses.\n\nTomorrow's the election day. Before the elections, the mongooses decided to cheat. They planned that each mongoose will eat at most one of its neighbor snakes. Two animals are said to be neighbors of each other if they are consecutive to each other in the row. After this, the elections will be held. The mongooses planned in such a way that the number of snakes eaten is maximized. Can you find out who will win the final poll? Output \"snakes\", \"mongooses\" or \"tie\" correspondingly.\n\n-----Input-----\nFirst line of the input contains an integer T denoting the number of test cases. The description of T test cases follow.\nThe only line of each test case contains a string consisting of characters 's' and 'm'. \n\n-----Output-----\nFor each test case output a single line containing \"snakes\", \"mongooses\" or \"tie\" correspondingly (without quotes).\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ |s| ≤ 100\n\n-----Example-----\nInput\n4\nsm\nssm\nsms\nssmmmssss\n\nOutput\nmongooses\ntie\ntie\nsnakes\n\n-----Explanation-----\nExample 1. The mongoose will eat the snake. Only the mongoose will be left. So, on the election day, there is one mongoose and zero snakes. So mongooses will win.\nExample 2. The mongoose will eat the snake at position 2 (1-based indexing). One mongoose and one snake will be left. Hence, there will be a tie.\nExample 3. The mongoose can eat either the snake to its left or to the right. But, it can eat only one of them. Afterwards, there will be a single snake and mongoose. So, it will result in a tie. \nExample 4. The mongooses can eat at max two snakes. For example, s*mmm*sss, where * denotes the snakes that were eaten by mongooses. After this, we have four snakes and three mongooses. So, the snakes win.\n    \"\"\"\n",
        "canonical_solution": "\ndef ACKIr():\n    for i in range(int(input())):\n     a=input()\n     c=a.count('m')\n     d=a.count('s')\n     t=0\n     while t<len(a)-1:\n      if (a[t]=='m' and a[t+1]=='s') or (a[t]=='s' and a[t+1]=='m'):\n       d=d-1\n       t=t+2\n      else:\n       t=t+1\n     if c>d:\n      print('mongooses')\n     elif d>c:\n      print('snakes')\n     else:\n      print('tie')\n    ",
        "inputs": [
            "4\nsm\nssm\nsms\nssmmmssss\n"
        ],
        "outputs": [
            "mongooses\ntie\ntie\nsnakes\n"
        ],
        "starter_code": "\ndef ACKIr():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "For Loop Body",
                3,
                19
            ],
            [
                "While Loop Body",
                8,
                13
            ],
            [
                "If Statement Body",
                9,
                13
            ],
            [
                "If Statement Body",
                14,
                19
            ],
            [
                "If Statement Body",
                16,
                19
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef qrszL():\n    \"\"\"We have a chocolate bar partitioned into H horizontal rows and W vertical columns of squares.\nThe square (i, j) at the i-th row from the top and the j-th column from the left is dark if S_{i,j} is 0, and white if S_{i,j} is 1.\nWe will cut the bar some number of times to divide it into some number of blocks. In each cut, we cut the whole bar by a line running along some boundaries of squares from end to end of the bar.\nHow many times do we need to cut the bar so that every block after the cuts has K or less white squares?\n\n-----Constraints-----\n - 1 \\leq H \\leq 10\n - 1 \\leq W \\leq 1000\n - 1 \\leq K \\leq H \\times W\n - S_{i,j} is 0 or 1.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nH W K\nS_{1,1}S_{1,2}...S_{1,W}\n:\nS_{H,1}S_{H,2}...S_{H,W}\n\n-----Output-----\nPrint the number of minimum times the bar needs to be cut so that every block after the cuts has K or less white squares.\n\n-----Sample Input-----\n3 5 4\n11100\n10001\n00111\n\n-----Sample Output-----\n2\n\nFor example, cutting between the 1-st and 2-nd rows and between the 3-rd and 4-th columns - as shown in the figure to the left - works.\nNote that we cannot cut the bar in the ways shown in the two figures to the right.\n    \"\"\"\n",
        "canonical_solution": "\ndef qrszL():\n    h, w, k = list(map(int, input().split()))\n    \n    choco = [list(map(int, list(input()) )) for i in range(h)]\n    \n    choco_cumsum = [[0 for i in range(w)] for j in range(h)]\n    \n    for i in range(h):\n        choco_cumsum[i][0] = choco[i][0]\n        for j in range(1, w):\n            choco_cumsum[i][j] = choco_cumsum[i][j-1] + choco[i][j]\n    \n    ans = h + w + 1\n    \n    for h_cut in range(2**(h-1)):\n        # 上位ビットが上側。1が切る、0が切らない\n        num_cut_init = bin(h_cut).count(\"1\") # 立っているビットの個数\n        num_cut = num_cut_init\n        w_last_cot_pos = -1\n        valid = True\n    \n        temp_list = [0] * (num_cut_init + 1)\n        temp_dict = {}\n        idx = 0\n        temp_dict[0] = idx\n        for i in range(1, h):\n            # print('idx', 2 ** (-i+h-1) )\n            if h_cut & (2 ** (-i+h-1) ):\n                idx += 1\n            # idx += h_cut & (2 ** (h-1) - i)\n            temp_dict[i] = idx\n        # print(temp_dict)\n    \n        iw = 0\n        while iw < w:\n    \n            for ih in range(h):\n                temp_list[temp_dict[ih]] += choco[ih][iw]\n            # print(iw, temp_list)\n    \n            condition = max(temp_list) > k\n            if condition:\n                if w_last_cot_pos < iw-1:\n                    # もしそこで切ってkを超えるなら、その手前で切る\n                    num_cut += 1\n                    w_last_cot_pos = iw - 1\n                    temp_list = [0] * (num_cut_init + 1)\n                    # print('iw: ', iw, 'last: ', w_last_cot_pos)\n    \n                else:\n                    # 1つしか動かしてない場合は土台無理なので次のh_cutに\n                    valid = False\n                    break\n            \n            else:\n                iw += 1\n        \n        if valid:\n            ans = min(ans, num_cut)\n        # print(num_cut)\n    \n    print(ans)\n    ",
        "inputs": [
            "3 5 4\n11100\n10001\n00111\n",
            "3 5 8\n11100\n10001\n00111\n",
            "4 10 4\n1110010010\n1000101110\n0011101001\n1101000111\n"
        ],
        "outputs": [
            "2\n",
            "0\n",
            "3\n"
        ],
        "starter_code": "\ndef qrszL():\n",
        "scope": [
            [
                "Function Body",
                2,
                63
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "For Loop Body",
                16,
                60
            ],
            [
                "For Loop Body",
                27,
                32
            ],
            [
                "If Statement Body",
                29,
                30
            ],
            [
                "While Loop Body",
                36,
                57
            ],
            [
                "For Loop Body",
                38,
                39
            ],
            [
                "If Statement Body",
                43,
                57
            ],
            [
                "If Statement Body",
                44,
                54
            ],
            [
                "If Statement Body",
                59,
                60
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef gvbOf():\n    \"\"\"Teddy and Tracy like to play a game based on strings. The game is as follows. Initially, Tracy writes a long random string on a whiteboard. Then, each player starting with Teddy makes turn alternately. Each turn, the player must erase a contiguous substring that exists in the dictionary. The dictionary consists of N words.\nOf course, the player that can't erase any substring in his turn loses the game, and the other player is declared the winner.\nNote that after a substring R is erased, the remaining substring becomes separated, i.e. they cannot erase a word that occurs partially to the left of R and partially to the right of R.\n\nDetermine the winner of the game, assuming that both players play optimally.\n\n-----Input-----\nThe first line contains a single integer T, the number of test cases. T test cases follow. The first line of each testcase contains a string S, the string Tracy writes on the whiteboard. The next line contains a single integer N. N lines follow. The i-th line contains a single string wi, the i-th word in the dictionary.\n\n-----Output-----\nFor each test case, output a single line containing the name of the winner of the game.\n\n-----Example-----\nInput:\n3\ncodechef\n2\ncode\nchef\nfoo\n1\nbar\nmississippi\n4\nssissi\nmippi\nmi\nppi\n\nOutput:\nTracy\nTracy\nTeddy\n\n-----Constraints-----\n- 1 <= T <= 5\n- 1 <= N <= 30\n- 1 <= |S| <= 30\n- 1 <= |wi| <= 30\n- S and wi contain only characters 'a'-'z'\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef gvbOf():\n    def mex(S,W,C,start,end):\n        \"\"\"Returns Nim-number of S[start:end]\"\"\"\n        key=(start,end)\n        try:\n            return C[key]\n        except KeyError:\n            pass\n        A=set()\n        for s in range(start,end):\n            for e in range(start+1,end+1):\n                if S[s:e] not in W: continue\n                A.add(mex(S,W,C,start,s)^mex(S,W,C,e,end))\n        a=0\n        while a in A: a+=1\n        C[key]=a\n        return a\n        \n    a=sys.stdin\n    #a=open('astrgame.txt','r')\n    T=int(a.readline())\n    for t in range(T):\n        S=a.readline().strip()\n        N=int(a.readline())\n        W=set([a.readline().strip() for n in range(N)])\n        print('Teddy' if mex(S,W,{},0,len(S)) else 'Tracy')\n        ",
        "inputs": [
            "3\ncodechef\n2\ncode\nchef\nfoo\n1\nbar\nmississippi\n4\nssissi\nmippi\nmi\nppi\n\n\n"
        ],
        "outputs": [
            "Tracy\nTracy\nTeddy\n"
        ],
        "starter_code": "\ndef gvbOf():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                3,
                18
            ],
            [
                "Try Block",
                6,
                9
            ],
            [
                "Except Block",
                8,
                9
            ],
            [
                "For Loop Body",
                11,
                14
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                13
            ],
            [
                "While Loop Body",
                16,
                16
            ],
            [
                "For Loop Body",
                23,
                27
            ],
            [
                "List Comprehension",
                26,
                26
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n            \"\"\"Given an integer array arr of distinct integers and an integer k.\nA game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0 and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\nReturn the integer which will win the game.\nIt is guaranteed that there will be a winner of the game.\n \nExample 1:\nInput: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n\nExample 2:\nInput: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.\n\nExample 3:\nInput: arr = [1,9,8,2,3,7,6,4,5], k = 7\nOutput: 9\n\nExample 4:\nInput: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\nOutput: 99\n\n \nConstraints:\n\n2 <= arr.length <= 10^5\n1 <= arr[i] <= 10^6\narr contains distinct integers.\n1 <= k <= 10^9\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        win=0\n        \n        curr = arr[0]\n        mx=0\n        \n        \n        for i in range(1,len(arr)):          \n            if arr[i] > curr:\n                curr=arr[i]\n                win=0\n                \n            win=win+1\n            if win==k:\n                break\n                \n        return curr",
        "inputs": [
            [
                [
                    5,
                    1,
                    2,
                    3,
                    4,
                    6,
                    7
                ],
                2
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                18
            ],
            [
                "Function Body",
                2,
                18
            ],
            [
                "For Loop Body",
                9,
                16
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                15,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef mcFYI():\n    \"\"\"You got a box with a combination lock. The lock has a display showing n digits. There are two buttons on the box, each button changes digits on the display. You have quickly discovered that the first button adds 1 to all the digits (all digits 9 become digits 0), and the second button shifts all the digits on the display one position to the right (the last digit becomes the first one). For example, if the display is currently showing number 579, then if we push the first button, the display will show 680, and if after that we push the second button, the display will show 068.\n\nYou know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order. The leading zeros are ignored while comparing numbers. Now your task is to find the desired number.\n\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of digits on the display.\n\nThe second line contains n digits — the initial state of the display.\n\n\n-----Output-----\n\nPrint a single line containing n digits — the desired state of the display containing the smallest possible number.\n\n\n-----Examples-----\nInput\n3\n579\n\nOutput\n024\n\nInput\n4\n2014\n\nOutput\n0142\n    \"\"\"\n",
        "canonical_solution": "\ndef mcFYI():\n    \n    def modify(string, index):\n        \n        if string[index] == '0':\n            key = 0\n        else:\n            key = 10 - int(string[index])\n        bad = ''\n        for i in string:\n            bad += str((int(i) + key) % 10)\n        return bad[index:] + bad[:index]\n    \n    \n    x = int(input())\n    y = input()\n    minx = 'zzzzzzzzz'\n    for i in range(x):\n        minx = min(minx, modify(y, i))\n    print(minx)\n    ",
        "inputs": [
            "3\n579\n",
            "4\n2014\n",
            "1\n1\n"
        ],
        "outputs": [
            "024\n",
            "0142\n",
            "0\n"
        ],
        "starter_code": "\ndef mcFYI():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "Function Body",
                4,
                13
            ],
            [
                "If Statement Body",
                6,
                9
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "For Loop Body",
                19,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef mHSBk():\n    \"\"\"You are given three strings $a$, $b$ and $c$ of the same length $n$. The strings consist of lowercase English letters only. The $i$-th letter of $a$ is $a_i$, the $i$-th letter of $b$ is $b_i$, the $i$-th letter of $c$ is $c_i$.\n\nFor every $i$ ($1 \\leq i \\leq n$) you must swap (i.e. exchange) $c_i$ with either $a_i$ or $b_i$. So in total you'll perform exactly $n$ swap operations, each of them either $c_i \\leftrightarrow a_i$ or $c_i \\leftrightarrow b_i$ ($i$ iterates over all integers between $1$ and $n$, inclusive).\n\nFor example, if $a$ is \"code\", $b$ is \"true\", and $c$ is \"help\", you can make $c$ equal to \"crue\" taking the $1$-st and the $4$-th letters from $a$ and the others from $b$. In this way $a$ becomes \"hodp\" and $b$ becomes \"tele\".\n\nIs it possible that after these swaps the string $a$ becomes exactly the same as the string $b$?\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 100$)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a string of lowercase English letters $a$.\n\nThe second line of each test case contains a string of lowercase English letters $b$.\n\nThe third line of each test case contains a string of lowercase English letters $c$.\n\nIt is guaranteed that in each test case these three strings are non-empty and have the same length, which is not exceeding $100$.\n\n\n-----Output-----\n\nPrint $t$ lines with answers for all test cases. For each test case:\n\nIf it is possible to make string $a$ equal to string $b$ print \"YES\" (without quotes), otherwise print \"NO\" (without quotes).\n\nYou can print either lowercase or uppercase letters in the answers.\n\n\n-----Example-----\nInput\n4\naaa\nbbb\nccc\nabc\nbca\nbca\naabb\nbbaa\nbaba\nimi\nmii\niim\n\nOutput\nNO\nYES\nYES\nNO\n\n\n\n-----Note-----\n\nIn the first test case, it is impossible to do the swaps so that string $a$ becomes exactly the same as string $b$.\n\nIn the second test case, you should swap $c_i$ with $a_i$ for all possible $i$. After the swaps $a$ becomes \"bca\", $b$ becomes \"bca\" and $c$ becomes \"abc\". Here the strings $a$ and $b$ are equal.\n\nIn the third test case, you should swap $c_1$ with $a_1$, $c_2$ with $b_2$, $c_3$ with $b_3$ and $c_4$ with $a_4$. Then string $a$ becomes \"baba\", string $b$ becomes \"baba\" and string $c$ becomes \"abab\". Here the strings $a$ and $b$ are equal.\n\nIn the fourth test case, it is impossible to do the swaps so that string $a$ becomes exactly the same as string $b$.\n    \"\"\"\n",
        "canonical_solution": "\ndef mHSBk():\n    for _ in range(int(input())):\n    \ta, b, c = input(), input(), input()\n    \tn = len(a)\n    \n    \tok = True\n    \tfor i in range(n):\n    \t\tif c[i] not in [a[i], b[i]]:\n    \t\t\tok = False\n    \n    \tprint('YES' if ok else 'NO')\n    ",
        "inputs": [
            "4\naaa\nbbb\nccc\nabc\nbca\nbca\naabb\nbbaa\nbaba\nimi\nmii\niim\n"
        ],
        "outputs": [
            "NO\nYES\nYES\nNO\n"
        ],
        "starter_code": "\ndef mHSBk():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                3,
                12
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                9,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef KOmSJ():\n    \"\"\"Given a binary string $S$ consisting of only 1’s and 0’s where 1 represents a Square and 0 represents a Circle. The diameter of the circle and the side of the square must be any integer (obviously > 0) . You will have to perfectly inscribe (as shown in the example below) the respective geometric figure at $S$$i+1$ inside of $S$$i$ where $i$ $\\epsilon$ $[0,N-2]$, if it is possible. Note that, it will not be possible to inscribe if the dimension of the geometric figure you are perfectly inscribing is not an integer and you will discard the rest of the string. Find the maximum number of circles we can inscribe in a square according to the given string.  \nFor a given binary string there can be only one geometric figure and this figure is concentric.  \nFor example : the string 1100 can be represented as the figure below, the first two squares have the same side length and the next two circles have the same diameter.  \n\nAnother example : the string 0001 can be represented as the one given below\nAgain here, we have 3 circles of the same diameter and one square inscribed in them.  \n\n-----Input:-----\nThe first line contains $N$, the number of strings\n\nThen each of the next $N$ lines contains a binary string $S$.  \n\n-----Output:-----\nThe $N$ lines of output should have $N$ integers in separate lines, the maximum number of circles we can inscribe in a square according to the given string $S$ .  \n\n-----Constraints-----\n- 1 $\\leq$ $N$ $\\leq$ 103\n- 1 $\\leq$ length of string $S$ $\\leq$ 104\n\n-----Sample Input:-----\n3\n\n1110\n\n0010\n\n1001000  \n\n-----Sample Output:-----\n1\n\n0\n\n2  \n\n-----Explanation:-----\nIn  the first case, we can inscribe the string 1110 as :  three squares of side length 4 units (on top of each other) and then  we can inscribe one circle of diameter 4 units.\nThe answer is 1 since, there is 1 circle inscribed in a square.\n\nIn the second case 0010, Let the first two circles be of some diameter 10, we can see that we cannot inscribe another square of any integer dimension inside them.\n\nSo, the answer is 0.\n\nIn the third case 1001000, we can take the first square of size 10, then inscribe two circles of diameter 5, then we cannot inscribe another square in this since, it will not be of any possible integer dimension and we discard the rest of the string.\n    \"\"\"\n",
        "canonical_solution": "\ndef KOmSJ():\n    for z in range(int(input())):\n        s = input()\n        n = len(s)\n        i = 0\n        while i<n and s[i]=='1':\n            i+=1\n        if i==0:\n            print(0)\n        else:\n            k = 0\n            while i<n and s[i]=='0':\n                i+=1\n                k+=1\n            print(k)\n    ",
        "inputs": [
            "3\n1110\n0010\n1001000\n"
        ],
        "outputs": [
            "1\n0\n2\n"
        ],
        "starter_code": "\ndef KOmSJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                3,
                16
            ],
            [
                "While Loop Body",
                7,
                8
            ],
            [
                "If Statement Body",
                9,
                16
            ],
            [
                "While Loop Body",
                13,
                15
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef HDoUk():\n    \"\"\"After completing some serious investigation, Watson and Holmes are now chilling themselves in the Shimla hills. Very soon Holmes became bored. Holmes lived entirely for his profession. We know he is a workaholic. So Holmes wants to stop his vacation and get back to work. But after a tiresome season, Watson is in no mood to return soon. So to keep Holmes engaged, he decided to give Holmes one math problem. And Holmes agreed to solve the problem and said as soon as he solves the problem, they should return back to work. Watson too agreed. \nThe problem was as follows. Watson knows Holmes’ favorite numbers are 6 and 5. So he decided to give Holmes N  single digit numbers. Watson asked Holmes to form a new number with the given N numbers in such a way that the newly formed number should be completely divisible by 5 and 6. Watson told Holmes that he should also form the number from these digits in such a way that the formed number is maximum. He may or may not use all the given numbers. But he is not allowed to use leading zeros. Though he is allowed to leave out some of the numbers, he is not allowed to add any extra numbers, which means the maximum count of each digit in the newly formed number, is the same as the number of times that number is present in those given N digits.\n\n-----Input-----\nThe first line of input contains one integers T denoting the number of test cases.\nEach test case consists of one integer N, number of numbers.\nNext line contains contains N single digit integers \n\n-----Output-----\nFor each test case output a single number, where the above said conditions are satisfied. If it is not possible to create such a number with the given constraints print -1.If there exists a solution, the maximised number should be greater than or equal to 0. \n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 10000\n- 0 ≤ Each digit ≤ 9\n\n-----Subtasks-----\nSubtask #1 : (90 points)\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 10000\n\nSubtask 2 : (10 points) \n\n- 1 ≤ T ≤ 10\n- 1 ≤ N≤ 10\n\n-----Example-----\nInput:\n2\n12\n3 1 2 3 2 0 2 2 2 0 2 3\n11\n3 9 9 6 4 3 6 4 9 6 0\n\nOutput:\n33322222200\n999666330\n    \"\"\"\n",
        "canonical_solution": "\ndef HDoUk():\n    t=int(input())\n    for i in range(0,t):\n     n=int(input())\n     lis=list(map(int,input().split()))\n     lis2=[]\n     for j in range(0,10):\n      lis2.append(0)\n     for j in range(0,len(lis)):\n      lis2[lis[j]]+=1;\n     s=sum(lis)\n     while s%3!=0:\n      if s%3==2:\n       if lis2[2]>=1:\n        lis2[2]-=1\n        s=s-2\n       elif lis2[5]>=1:\n        lis2[5]-=1\n        s=s-5\n       elif lis2[8]>=1:\n        lis2[8]-=1\n        s=s-8\n       elif lis2[1]>=2:\n        lis2[1]-=2\n        s=s-2\n       elif lis2[1]>=1 and lis2[4]>=1:\n        lis2[1]-=1\n        lis2[4]-=1\n        s=s-5\n       elif lis2[4]>=2:\n        lis2[4]-=2\n        s=s-8\n       elif lis2[1]>=1 and lis2[7]>=1:\n        lis2[1]-=1\n        lis2[7]-=1\n        s=s-8\n       elif lis2[4]>=1 and lis2[7]>=1:\n        lis2[4]-=1\n        lis2[7]-=1\n        s=s-11\n       elif lis2[7]>=2:\n        lis2[7]-=2\n        s=s-14\n      elif s%3==1:\n       if lis2[1]>=1:\n        lis2[1]-=1\n        s=s-1\n       elif lis2[4]>=1:\n        lis2[4]-=1\n        s=s-4\n       elif lis2[7]>=1:\n        lis2[7]-=1\n        s=s-7\n       elif lis2[2]>=2:\n        lis2[2]-=2\n        s=s-4\n       elif lis2[5]>=1 and lis2[2]>=1:\n        lis2[2]-=1\n        lis2[5]-=1\n        s=s-7\n       elif lis2[5]>=2:\n        lis2[5]-=2\n        s=s-10\n       elif lis2[2]>=1 and lis2[8]>=1:\n        lis2[2]-=1\n        lis2[8]-=1\n        s=s-10\n       elif lis2[8]>=1 and lis2[5]>=1:\n        lis2[8]-=1\n        lis2[5]-=1\n        s=s-13\n       elif lis2[8]>=2:\n        lis2[8]-=2\n        s=s-16\n     lis3=[]\n     for j in range(1,10):\n      if lis2[j]>=1:\n       for k in range(0,lis2[j]):\n        lis3.append(j)\n     lis3.reverse()\n     for k in range(0,lis2[0]):\n      lis3.append(0)\n     sol=''\n     for k in range(0,len(lis3)):\n      sol+=str(lis3[k])\n     print(sol)",
        "inputs": [
            "2\n12\n3 1 2 3 2 0 2 2 2 0 2 3\n11\n3 9 9 6 4 3 6 4 9 6 0\n"
        ],
        "outputs": [
            "33322222200\n999666330\n"
        ],
        "starter_code": "\ndef HDoUk():\n",
        "scope": [
            [
                "Function Body",
                2,
                87
            ],
            [
                "For Loop Body",
                4,
                87
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "While Loop Body",
                13,
                75
            ],
            [
                "If Statement Body",
                14,
                75
            ],
            [
                "If Statement Body",
                15,
                44
            ],
            [
                "If Statement Body",
                18,
                44
            ],
            [
                "If Statement Body",
                21,
                44
            ],
            [
                "If Statement Body",
                24,
                44
            ],
            [
                "If Statement Body",
                27,
                44
            ],
            [
                "If Statement Body",
                31,
                44
            ],
            [
                "If Statement Body",
                34,
                44
            ],
            [
                "If Statement Body",
                38,
                44
            ],
            [
                "If Statement Body",
                42,
                44
            ],
            [
                "If Statement Body",
                45,
                75
            ],
            [
                "If Statement Body",
                46,
                75
            ],
            [
                "If Statement Body",
                49,
                75
            ],
            [
                "If Statement Body",
                52,
                75
            ],
            [
                "If Statement Body",
                55,
                75
            ],
            [
                "If Statement Body",
                58,
                75
            ],
            [
                "If Statement Body",
                62,
                75
            ],
            [
                "If Statement Body",
                65,
                75
            ],
            [
                "If Statement Body",
                69,
                75
            ],
            [
                "If Statement Body",
                73,
                75
            ],
            [
                "For Loop Body",
                77,
                80
            ],
            [
                "If Statement Body",
                78,
                80
            ],
            [
                "For Loop Body",
                79,
                80
            ],
            [
                "For Loop Body",
                82,
                83
            ],
            [
                "For Loop Body",
                85,
                86
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef hZUEO():\n    \"\"\"You are given a sequence of integers $A_1, A_2, \\ldots, A_N$. This sequence is circular ― for each valid $i$, the element $A_{i+1}$ follows after $A_i$, and the element $A_1$ follows after $A_N$.\nYou may insert any positive integers at any positions you choose in this sequence; let's denote the resulting sequence by $B$. This sequence is also circular. For each pair of its elements $B_s$ and $B_f$, let's denote the (non-circular) sequence created by starting at $B_s$ and moving from each element to the one that follows after it, until we reach $B_f$, by $B(s, f)$. This sequence includes the elements $B_s$ and $B_f$.\nFor each $K$ from $2$ to $N$ inclusive, find the smallest possible number of elements that need to be inserted into $A$ to form a sequence $B$ for which there is no subsequence $B(p, q)$ such that:\n- The size of $B(p, q)$ is at least $K$.\n- There is no pair of consecutive elements in $B(p, q)$ such that their GCD is equal to $1$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing $N-1$ space-separated integers. For each $i$ ($1 \\le i \\le N-1$), the $i$-th of these integers should be the smallest number of inserted elements in a valid sequence $B$ for $K = i+1$.\n\n-----Constraints-----\n- $1 \\le T \\le 2,000$\n- $2 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $2 \\cdot 10^6$\n\n-----Example Input-----\n1\n5\n3 6 4 5 9\n\n-----Example Output-----\n3 1 1 0\n    \"\"\"\n",
        "canonical_solution": "from math import gcd\nfrom itertools import groupby\ndef hZUEO():\n    def gcd_split(seq):\n     gcds= [int(gcd(a,b)==1) for a,b in zip(seq[1:],seq[:-1])]\n     gcds.append(int(gcd(seq[0],seq[-1])==1))\n     # print(gcds)\n     if max(gcds)==0:\n      return -1\n     else:\n      splits=[len(list(x))+1 for num,x in groupby(gcds) if num==0]\n      # print(splits)\n      if gcds[0]==gcds[-1]==0:\n       splits[0] += splits[-1]-1\n       splits = splits[:-1]\n      return splits\n    for _ in range(int(input())):\n     N=int(input())\n     A=[int(x) for x in input().split()]\n     split = gcd_split(A)\n     # print(split)\n     \n     res=[]\n     if split!=-1:\n      for K in range(2,N+1):\n       temp=(x for x in split if x>=K)\n       ins = sum([(x//(K-1)-1 if x%(K-1)==0 else x//(K-1)) for x in temp])\n       if ins==0:\n        break\n       else:\n        res.append(ins)\n     else:\n      for K in range(2,N+1):\n       ins = N//(K-1)+(N%(K-1)>0)\n       if ins==0:\n        break\n       else:\n        res.append(ins)\n     \n     res = res + [0]*(N-1 -len(res))\n     print(*res)",
        "inputs": [
            "1\n5\n3 6 4 5 9\n"
        ],
        "outputs": [
            "3 1 1 0\n"
        ],
        "starter_code": "\ndef hZUEO():\n",
        "scope": [
            [
                "Function Body",
                3,
                41
            ],
            [
                "Function Body",
                4,
                16
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "If Statement Body",
                8,
                16
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "If Statement Body",
                13,
                15
            ],
            [
                "For Loop Body",
                17,
                41
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "If Statement Body",
                24,
                38
            ],
            [
                "For Loop Body",
                25,
                31
            ],
            [
                "Generator Expression",
                26,
                26
            ],
            [
                "List Comprehension",
                27,
                27
            ],
            [
                "If Statement Body",
                28,
                31
            ],
            [
                "For Loop Body",
                33,
                38
            ],
            [
                "If Statement Body",
                35,
                38
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef IRhkK():\n    \"\"\"Cowboy Vlad has a birthday today! There are $n$ children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.\n\nFormally, let's number children from $1$ to $n$ in a circle order, that is, for every $i$ child with number $i$ will stand next to the child with number $i+1$, also the child with number $1$ stands next to the child with number $n$. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.\n\nPlease help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 100$) — the number of the children who came to the cowboy Vlad's birthday.\n\nThe second line contains integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^9$) denoting heights of every child.\n\n\n-----Output-----\n\nPrint exactly $n$ integers — heights of the children in the order in which they should stand in a circle. You can start printing a circle with any child.\n\nIf there are multiple possible answers, print any of them.\n\n\n-----Examples-----\nInput\n5\n2 1 1 3 2\n\nOutput\n1 2 3 2 1\n\nInput\n3\n30 10 20\n\nOutput\n10 20 30\n\n\n\n-----Note-----\n\nIn the first example, the discomfort of the circle is equal to $1$, since the corresponding absolute differences are $1$, $1$, $1$ and $0$. Note, that sequences $[2, 3, 2, 1, 1]$ and $[3, 2, 1, 1, 2]$ form the same circles and differ only by the selection of the starting point.\n\nIn the second example, the discomfort of the circle is equal to $20$, since the absolute difference of $10$ and $30$ is equal to $20$.\n    \"\"\"\n",
        "canonical_solution": "\ndef IRhkK():\n    n = int(input())\n    a = list(map(int,input().split()))\n    a = sorted(a)\n    \n    out = [0 for x in range(n)]\n    if n%2:\n        out[n//2] = a[-1]\n    for x in range(n//2):\n        out[x] = a[x*2]\n        out[-(1+x)] = a[(x*2)+1]\n    print (\" \".join(str(c) for c in out)) ",
        "inputs": [
            "5\n2 1 1 3 2\n",
            "3\n30 10 20\n",
            "2\n10 20\n"
        ],
        "outputs": [
            "1 2 3 2 1\n",
            "10 30 20\n",
            "10 20\n"
        ],
        "starter_code": "\ndef IRhkK():\n",
        "scope": [
            [
                "Function Body",
                2,
                13
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "If Statement Body",
                8,
                9
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "Generator Expression",
                13,
                13
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RCUuk():\n    \"\"\"Chef has a calculator which has two screens and two buttons. Initially, each screen shows the number zero. Pressing the first button increments the number on the first screen by 1, and each click of the first button consumes 1 unit of energy.\nPressing the second button increases the number on the second screen by the number which is currently appearing on the first screen. Each click of the second button consumes B units of energy.\nInitially the calculator has N units of energy.\nNow chef wonders what the maximum possible number is, that he gets on the second screen of the calculator, with the limited energy.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases.\nEach test case is described using a single line containing two integers, N and B.\n\n-----Output-----\nFor each test case, output a single line containing the answer to this test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10,000\n- 1 ≤ N, B ≤ 1,000,000,000\n\n-----Subtasks-----\n- Subtask 1 (20 points): 1 ≤ N, B ≤ 1,000\n- Subtask 2 (80 points): Original constraints\n\n-----Example-----\nInput:\n3\n10 2\n8 5\n6 1\n\nOutput:\n12\n3\n9\n\n-----Explanation-----\nExample case 1. There are 10 units of energy available. Pressing second button takes 2 units of energy. Chef can achieve 12 on the second screen as follows.\n\n- Press first button to get scores (1, 0). 9 units of energey is left.\n- Press first button to get scores (2, 0). 8 units of energy remaining.\n- Press first button to get scores (3, 0). 7 units of energy remaining.\n- Press first button to get scores (4, 0). 6 units of energy remaining.\n- Press second button to get scores (4, 4). 4 units of energy remaining.\n- Press second button to get scores (4, 8). 2 units of energy remaining.\n- Press second button to get scores (4, 12). 0 units of energy remaining.\n    \"\"\"\n",
        "canonical_solution": "\ndef RCUuk():\n    # cook your dish here\n    for i in range(int(input())):\n     n,b=map(int,input().split())\n     ans=round(n/(2*b))*(n-b*round((n/(2*b))));\n     print(ans)",
        "inputs": [
            "3\n10 2\n8 5\n6 1\n"
        ],
        "outputs": [
            "12\n3\n9\n"
        ],
        "starter_code": "\ndef RCUuk():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "For Loop Body",
                4,
                7
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef YDMNE():\n    \"\"\"Natasha's favourite numbers are $n$ and $1$, and Sasha's favourite numbers are $m$ and $-1$. One day Natasha and Sasha met and wrote down every possible array of length $n+m$ such that some $n$ of its elements are equal to $1$ and another $m$ elements are equal to $-1$. For each such array they counted its maximal prefix sum, probably an empty one which is equal to $0$ (in another words, if every nonempty prefix sum is less to zero, then it is considered equal to zero). Formally, denote as $f(a)$ the maximal prefix sum of an array $a_{1, \\ldots ,l}$ of length $l \\geq 0$. Then: \n\n$$f(a) = \\max (0, \\smash{\\displaystyle\\max_{1 \\leq i \\leq l}} \\sum_{j=1}^{i} a_j )$$\n\nNow they want to count the sum of maximal prefix sums for each such an array and they are asking you to help. As this sum can be very large, output it modulo $998\\: 244\\: 853$.\n\n\n-----Input-----\n\nThe only line contains two integers $n$ and $m$ ($0 \\le n,m \\le 2\\,000$).\n\n\n-----Output-----\n\nOutput the answer to the problem modulo $998\\: 244\\: 853$.\n\n\n-----Examples-----\nInput\n0 2\n\nOutput\n0\n\nInput\n2 0\n\nOutput\n2\n\nInput\n2 2\n\nOutput\n5\n\nInput\n2000 2000\n\nOutput\n674532367\n\n\n\n-----Note-----\n\nIn the first example the only possible array is [-1,-1], its maximal prefix sum is equal to $0$. \n\nIn the second example the only possible array is [1,1], its maximal prefix sum is equal to $2$. \n\nThere are $6$ possible arrays in the third example:\n\n[1,1,-1,-1], f([1,1,-1,-1]) = 2\n\n[1,-1,1,-1], f([1,-1,1,-1]) = 1\n\n[1,-1,-1,1], f([1,-1,-1,1]) = 1\n\n[-1,1,1,-1], f([-1,1,1,-1]) = 1\n\n[-1,1,-1,1], f([-1,1,-1,1]) = 0\n\n[-1,-1,1,1], f([-1,-1,1,1]) = 0\n\nSo the answer for the third example is $2+1+1+1+0+0 = 5$.\n    \"\"\"\n",
        "canonical_solution": "\ndef YDMNE():\n    n, m = list(map(int, input().split()))\n    mod = 998244853\n    fact = [1]\n    invfact = [1]\n    def pw(x, y):\n        ans = 1\n        while (y):\n            if (y & 1):\n                ans = (ans * x) % mod\n            x = x * x % mod\n            y >>= 1\n        return ans\n    def inv(x):\n        return pw(x, mod - 2)\n    for i in range(1, n + m + 1):\n        fact.append(fact[i - 1] * i % mod)\n        invfact.append(invfact[i - 1] * inv(i) % mod)\n    mn = max(0, n - m)\n    def ways_to(sub):\n        inc = (n + m + sub) // 2\n        return fact[n + m] * invfact[inc] * invfact[n + m - inc] % mod\n    ans = 0\n    ways = [0 for x in range(0, n + 2)]\n    for i in range (mn, n + 1):\n        ways[i] = ways_to(n - m) - ways_to(2 * i - n + m)\n    ways[n + 1] = ways_to(n - m)\n    for i in range(1, n + 1):\n        ans += i * (ways[i + 1] - ways[i])\n        ans %= mod\n    if (ans < 0) :\n        ans += mod\n    print(ans)\n    ",
        "inputs": [
            "0 2\n",
            "2 0\n",
            "2 2\n"
        ],
        "outputs": [
            "0\n",
            "2\n",
            "5\n"
        ],
        "starter_code": "\ndef YDMNE():\n",
        "scope": [
            [
                "Function Body",
                2,
                34
            ],
            [
                "Function Body",
                7,
                14
            ],
            [
                "While Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "Function Body",
                15,
                16
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "Function Body",
                21,
                23
            ],
            [
                "List Comprehension",
                25,
                25
            ],
            [
                "For Loop Body",
                26,
                27
            ],
            [
                "For Loop Body",
                29,
                31
            ],
            [
                "If Statement Body",
                32,
                33
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RFsTM():\n    \"\"\"\tDevuLand is a very strange place. There are n villages in it. Some of the villages are occupied by dinosaurs while the remaining ones by villagers.\n\tYou are given the information of DevuLand \n\tby an array D of size n. If D[i] is non-negative, it means that there are D[i] villagers in that village. \n\tOtherwise, it means that are -D[i] \n\tdinosaurs in that village.\n\n\tIt is also guaranteed that total number of villagers in DevuLand is equal to total number of dinosaurs.\n\nOnce dinosaurs got very hungry and started eating villagers. Frightened villagers gathered immediately and met their Sarpanch Deviji. Deviji, being a very daring and negotiable person, met to the head\nof dinosaurs. Soon both parties called a truce. It was decided that the villagers will provide laddus to \nthe dinosaurs. So everyday, each villager will take exactly one laddu to one of the dinosaurs in such a way that no dinosaur remains hungry (note that this is possible because number of villagers is the same as the number of dinosaurs).\n\nActually, carrying laddus is a quite a tough job. Villagers have to use a bullock cart for that. It takes one unit of grass a bullock to \ncarry a cart with 1 laddu for 1 kilometre. Laddus used to be very heavy in DevuLand, so a bullock cart can not carry more than one laddu.\n\nIt is also given distance between village indexed i and j is |j - i| (the absolute value) kilometres.\n\nNow villagers sat down and found a strategy to feed laddus to dinosaurs so that they need to buy the least amount of grass from the nearby market. \nThey are not very good in \ncalculations, please find out what is the minimum number of units of grass they need to buy.\n\n-----Input-----\n\nFirst line of the input contains an integer T denoting number of test cases.\n\nFor each test case, there are two lines. \n\nFirst line contains a single integer denoting n: number of villages. \n\nSecond line contains n space separated integers denoting the array D.\n\n-----Output-----\n\nFor each test case, print a single line containing the integer corresponding to answer of the problem.\n\n-----Constraints-----\n\n-  1 ≤ T ≤ 10^5 \n-  1 ≤ n ≤ 10^5 \n-  -10^4 ≤ D[i] ≤ 10^4 \n-  Sum of n over all the test cases will be ≤ 10^6 \n-  It is guaranteed that sum of D[i] is zero for a single test case which ensures that there are equal number of villagers and dinosaurs. \n\n-----Example-----\nInput:\n3\n2\n5 -5\n2\n-5 5\n3\n1 2 -3\nOutput:\n5\n5\n4\n\n-----Explanation-----\nExample case 1. Each villager in village 1, need to walk 1 km to reach to the dinosaur in 2nd village.\nExample case 2. Each villager in village 2, need to walk 1 km to reach to the dinosaur 1st village.\nExample case 3. Each villager in village 1, need to walk 2 km to reach to the dinosaur in 3rd village whereas Each villager in village 2, \nneed to walk 1 km to reach to the dinosaur in 3rd village.\n    \"\"\"\n",
        "canonical_solution": "\ndef RFsTM():\n    # cook your dish here\n    for _ in range(int(input())):\n     n = int(input())\n     a = list(map(int, input().split()))\n     curr = 0\n     ans = 0\n     for x in a:\n      curr += x\n      ans += abs(curr)\n     print(ans)",
        "inputs": [
            "3\n2\n5 -5\n2\n-5 5\n3\n1 2 -3\n"
        ],
        "outputs": [
            "5\n5\n4\n"
        ],
        "starter_code": "\ndef RFsTM():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                4,
                12
            ],
            [
                "For Loop Body",
                9,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FgLGJ():\n    \"\"\"The numbers of all offices in the new building of the Tax Office of IT City will have lucky numbers.\n\nLucky number is a number that consists of digits 7 and 8 only. Find the maximum number of offices in the new building of the Tax Office given that a door-plate can hold a number not longer than n digits.\n\n\n-----Input-----\n\nThe only line of input contains one integer n (1 ≤ n ≤ 55) — the maximum length of a number that a door-plate can hold.\n\n\n-----Output-----\n\nOutput one integer — the maximum number of offices, than can have unique lucky numbers not longer than n digits.\n\n\n-----Examples-----\nInput\n2\n\nOutput\n6\n    \"\"\"\n",
        "canonical_solution": "\ndef FgLGJ():\n    n = int(input())\n    print(2**(n+1) - 2)\n    ",
        "inputs": [
            "2\n",
            "1\n",
            "3\n"
        ],
        "outputs": [
            "6",
            "2",
            "14"
        ],
        "starter_code": "\ndef FgLGJ():\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wrkOa():\n    \"\"\"Recently Luba learned about a special kind of numbers that she calls beautiful numbers. The number is called beautiful iff its binary representation consists of k + 1 consecutive ones, and then k consecutive zeroes.\n\nSome examples of beautiful numbers:   1_2 (1_10);  110_2 (6_10);  1111000_2 (120_10);  111110000_2 (496_10). \n\nMore formally, the number is beautiful iff there exists some positive integer k such that the number is equal to (2^{k} - 1) * (2^{k} - 1).\n\nLuba has got an integer number n, and she wants to find its greatest beautiful divisor. Help her to find it!\n\n\n-----Input-----\n\nThe only line of input contains one number n (1 ≤ n ≤ 10^5) — the number Luba has got.\n\n\n-----Output-----\n\nOutput one number — the greatest beautiful divisor of Luba's number. It is obvious that the answer always exists.\n\n\n-----Examples-----\nInput\n3\n\nOutput\n1\n\nInput\n992\n\nOutput\n496\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter, defaultdict\nimport itertools\nimport sys\ndef wrkOa():\n    def main():\n        n = int(input())\n        ans = 1\n        for k in range(1, 10):\n            v = ((1 << k) - 1) * (1 << (k - 1))\n            if n % v == 0:\n                ans = v\n        print(ans)\n    main()",
        "inputs": [
            "3\n",
            "992\n",
            "81142\n"
        ],
        "outputs": [
            "1\n",
            "496\n",
            "1\n"
        ],
        "starter_code": "\ndef wrkOa():\n",
        "scope": [
            [
                "Function Body",
                4,
                13
            ],
            [
                "Function Body",
                5,
                12
            ],
            [
                "For Loop Body",
                8,
                11
            ],
            [
                "If Statement Body",
                10,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef OGera():\n    \"\"\"Polycarp is flying in the airplane. Finally, it is his favorite time — the lunchtime. The BerAvia company stewardess is giving food consecutively to all the passengers from the 1-th one to the last one. Polycarp is sitting on seat m, that means, he will be the m-th person to get food.\n\nThe flight menu has k dishes in total and when Polycarp boarded the flight, he had time to count the number of portions of each dish on board. Thus, he knows values a_1, a_2, ..., a_{k}, where a_{i} is the number of portions of the i-th dish.\n\nThe stewardess has already given food to m - 1 passengers, gave Polycarp a polite smile and asked him what he would prefer. That's when Polycarp realized that they might have run out of some dishes by that moment. For some of the m - 1 passengers ahead of him, he noticed what dishes they were given. Besides, he's heard some strange mumbling from some of the m - 1 passengers ahead of him, similar to phrase 'I'm disappointed'. That happened when a passenger asked for some dish but the stewardess gave him a polite smile and said that they had run out of that dish. In that case the passenger needed to choose some other dish that was available. If Polycarp heard no more sounds from a passenger, that meant that the passenger chose his dish at the first try.\n\nHelp Polycarp to find out for each dish: whether they could have run out of the dish by the moment Polyarp was served or that dish was definitely available.\n\n\n-----Input-----\n\nEach test in this problem consists of one or more input sets. First goes a string that contains a single integer t (1 ≤ t ≤ 100 000) — the number of input data sets in the test. Then the sets follow, each set is preceded by an empty line.\n\nThe first line of each set of the input contains integers m, k (2 ≤ m ≤ 100 000, 1 ≤ k ≤ 100 000) — the number of Polycarp's seat and the number of dishes, respectively.\n\nThe second line contains a sequence of k integers a_1, a_2, ..., a_{k} (1 ≤ a_{i} ≤ 100 000), where a_{i} is the initial number of portions of the i-th dish.\n\nThen m - 1 lines follow, each line contains the description of Polycarp's observations about giving food to a passenger sitting in front of him: the j-th line contains a pair of integers t_{j}, r_{j} (0 ≤ t_{j} ≤ k, 0 ≤ r_{j} ≤ 1), where t_{j} is the number of the dish that was given to the j-th passenger (or 0, if Polycarp didn't notice what dish was given to the passenger), and r_{j} — a 1 or a 0, depending on whether the j-th passenger was or wasn't disappointed, respectively.\n\nWe know that sum a_{i} equals at least m, that is,Polycarp will definitely get some dish, even if it is the last thing he wanted. It is guaranteed that the data is consistent.\n\nSum m for all input sets doesn't exceed 100 000. Sum k for all input sets doesn't exceed 100 000.\n\n\n-----Output-----\n\nFor each input set print the answer as a single line. Print a string of k letters \"Y\" or \"N\". Letter \"Y\" in position i should be printed if they could have run out of the i-th dish by the time the stewardess started serving Polycarp.\n\n\n-----Examples-----\nInput\n2\n\n3 4\n2 3 2 1\n1 0\n0 0\n\n5 5\n1 2 1 3 1\n3 0\n0 0\n2 1\n4 0\n\nOutput\nYNNY\nYYYNY\n\n\n\n-----Note-----\n\nIn the first input set depending on the choice of the second passenger the situation could develop in different ways:  If he chose the first dish, then by the moment the stewardess reaches Polycarp, they will have run out of the first dish;  If he chose the fourth dish, then by the moment the stewardess reaches Polycarp, they will have run out of the fourth dish;  Otherwise, Polycarp will be able to choose from any of the four dishes. \n\nThus, the answer is \"YNNY\".\n\nIn the second input set there is, for example, the following possible scenario. First, the first passenger takes the only third dish, then the second passenger takes the second dish. Then, the third passenger asks for the third dish, but it is not available, so he makes disappointed muttering and ends up with the second dish. Then the fourth passenger takes the fourth dish, and Polycarp ends up with the choice between the first, fourth and fifth dish.\n\nLikewise, another possible scenario is when by the time the stewardess comes to Polycarp, they will have run out of either the first or the fifth dish (this can happen if one of these dishes is taken by the second passenger). It is easy to see that there is more than enough of the fourth dish, so Polycarp can always count on it. Thus, the answer is \"YYYNY\".\n    \"\"\"\n",
        "canonical_solution": "\ndef OGera():\n    t = int(input())\n    for i in range(t):\n        input()\n        m,k = map(int,input().split())\n        ak = list(map(int,input().split()))\n        ak2 = [0]*k\n        tjrj = [list(map(int,input().split())) for j in range(m-1)]\n        num = 0\n        num2 = 0\n        num3 = 100002\n        for j in range(m-1):\n            if num2 == 1 or tjrj[j][1] == 0:\n                if tjrj[j][0] != 0:\n                    ak[tjrj[j][0]-1] -= 1\n                else:\n                    num += 1\n            else:\n                for z in range(k):\n                        if ak[z] - num < 1:\n                            ak2[z] = 1\n                num2 = 1\n                if tjrj[j][0] != 0:\n                    ak[tjrj[j][0]-1] -= 1\n                else:\n                    num += 1\n                for f in range(j,m-1):\n                    if tjrj[f][0] != 0:\n                        ak2[tjrj[f][0]-1] = 0\n                for f in range(k):\n                    if ak2[f] == 1:\n                        if num3 > ak[f]:\n                            num3 = ak[f]\n                num -= num3\n        for z in range(k):\n            if ak[z] - num < 1 or ak2[z] == 1:\n                print(\"Y\",end=\"\")\n            else:\n                print(\"N\",end=\"\")\n        print()\n    ",
        "inputs": [
            "2\n\n3 4\n2 3 2 1\n1 0\n0 0\n\n5 5\n1 2 1 3 1\n3 0\n0 0\n2 1\n4 0\n",
            "4\n\n2 1\n42\n0 0\n\n2 1\n2\n0 0\n\n2 1\n42\n1 0\n\n2 1\n2\n1 0\n",
            "5\n\n3 3\n1 1 1\n0 0\n0 1\n\n3 3\n1 1 1\n1 0\n2 1\n\n3 3\n1 1 1\n1 0\n0 1\n\n3 3\n1 1 1\n0 0\n1 0\n\n3 3\n1 1 1\n0 0\n1 1\n"
        ],
        "outputs": [
            "YNNY\nYYYNY\n",
            "N\nN\nN\nN\n",
            "YYY\nYYN\nYYY\nYYY\nYYY\n"
        ],
        "starter_code": "\ndef OGera():\n",
        "scope": [
            [
                "Function Body",
                2,
                41
            ],
            [
                "For Loop Body",
                4,
                41
            ],
            [
                "List Comprehension",
                9,
                9
            ],
            [
                "For Loop Body",
                13,
                35
            ],
            [
                "If Statement Body",
                14,
                35
            ],
            [
                "If Statement Body",
                15,
                18
            ],
            [
                "For Loop Body",
                20,
                22
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "If Statement Body",
                24,
                27
            ],
            [
                "For Loop Body",
                28,
                30
            ],
            [
                "If Statement Body",
                29,
                30
            ],
            [
                "For Loop Body",
                31,
                34
            ],
            [
                "If Statement Body",
                32,
                34
            ],
            [
                "If Statement Body",
                33,
                34
            ],
            [
                "For Loop Body",
                36,
                40
            ],
            [
                "If Statement Body",
                37,
                40
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Oedtm():\n    \"\"\"Vova has taken his summer practice this year and now he should write a report on how it went.\n\nVova has already drawn all the tables and wrote down all the formulas. Moreover, he has already decided that the report will consist of exactly $n$ pages and the $i$-th page will include $x_i$ tables and $y_i$ formulas. The pages are numbered from $1$ to $n$.\n\nVova fills the pages one after another, he can't go filling page $i + 1$ before finishing page $i$ and he can't skip pages. \n\nHowever, if he draws strictly more than $k$ tables in a row or writes strictly more than $k$ formulas in a row then he will get bored. Vova wants to rearrange tables and formulas in each page in such a way that he doesn't get bored in the process. Vova can't move some table or some formula to another page.\n\nNote that the count doesn't reset on the start of the new page. For example, if the page ends with $3$ tables and the next page starts with $5$ tables, then it's counted as $8$ tables in a row.\n\nHelp Vova to determine if he can rearrange tables and formulas on each page in such a way that there is no more than $k$ tables in a row and no more than $k$ formulas in a row.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 3 \\cdot 10^5$, $1 \\le k \\le 10^6$).\n\nThe second line contains $n$ integers $x_1, x_2, \\dots, x_n$ ($1 \\le x_i \\le 10^6$) — the number of tables on the $i$-th page.\n\nThe third line contains $n$ integers $y_1, y_2, \\dots, y_n$ ($1 \\le y_i \\le 10^6$) — the number of formulas on the $i$-th page.\n\n\n-----Output-----\n\nPrint \"YES\" if Vova can rearrange tables and formulas on each page in such a way that there is no more than $k$ tables in a row and no more than $k$ formulas in a row.\n\nOtherwise print \"NO\".\n\n\n-----Examples-----\nInput\n2 2\n5 5\n2 2\n\nOutput\nYES\n\nInput\n2 2\n5 6\n2 2\n\nOutput\nNO\n\nInput\n4 1\n4 1 10 1\n3 2 10 1\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example the only option to rearrange everything is the following (let table be 'T' and formula be 'F'):   page $1$: \"TTFTTFT\"  page $2$: \"TFTTFTT\" \n\nThat way all blocks of tables have length $2$.\n\nIn the second example there is no way to fit everything in such a way that there are no more than $2$ tables in a row and $2$ formulas in a row.\n    \"\"\"\n",
        "canonical_solution": "\ndef Oedtm():\n    def max(a, b):\n    \tif a > b:\n    \t\treturn a\n    \telse:\n    \t\treturn b\n    n, k = map(int, input().split())\n    x = [int(t) for t in input().split()]\n    y = [int(t) for t in input().split()]\n    f, s = 0, 0\n    for i in range(n):\n        f = max(0, x[i] + f - k * y[i])\n        s = max(0, y[i] + s - k * x[i])\n        if f > k or s > k:\n            print('NO')\n            return\n    print('YES')",
        "inputs": [
            "2 2\n5 5\n2 2\n",
            "2 2\n5 6\n2 2\n",
            "4 1\n4 1 10 1\n3 2 10 1\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "YES\n"
        ],
        "starter_code": "\ndef Oedtm():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "If Statement Body",
                4,
                7
            ],
            [
                "List Comprehension",
                9,
                9
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "For Loop Body",
                12,
                17
            ],
            [
                "If Statement Body",
                15,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef iDtyP():\n    \"\"\"You are given an $array$ of size $N$ and an integer $K$ ( $N > 1 , K > 0$ ).\nEach element in the array can be incremented by $K$ or decremented by $K$ $at$ $most$ $once$.\nSo there will be  $3^n$ possible combinations of final array. (As there are 3 options for every element).\n\nOut of these combinations, you have to select a combination, in which the $absolute$ difference between the largest and the smallest element is $maximum$.\nYou have to print the $maximum$ $absolute$ $difference$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a two lines of input\n- First line contains two integers $N, K$. \n- Second line contains $N$ space separated integers.\n\n-----Output:-----\nFor each testcase, output the maximum absolute difference that can be achieved on a new line.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $2 \\leq N \\leq 1000$\n- $1 \\leq K , arr[i]  \\leq 10000$\n$NOTE$:  Large  input files, Use of fastio is recommended.\n\n-----Sample Input:-----\n2\n\n4 3\n\n4 2 5 1\n\n3 5\n\n2 5 3\n\n-----Sample Output:-----\n10\n\n13\n    \"\"\"\n",
        "canonical_solution": "\ndef iDtyP():\n    # cook your dish here\n    testcases=int(input())\n    \n    for _ in range(testcases):\n        (N,K)=list(map(int,input().split()))\n        array=list(map(int,input().split()))\n        \n        max=array[0]\n        min=array[0]\n        \n        for i in array:\n            if i>max:\n                max=i\n            if i<min:\n                min=i\n                \n        max=max+K \n        min=min-K\n        \n        print(abs(max-min))",
        "inputs": [
            "2\n4 3\n4 2 5 1\n3 5\n2 5 3\n"
        ],
        "outputs": [
            "10\n13\n"
        ],
        "starter_code": "\ndef iDtyP():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "For Loop Body",
                6,
                22
            ],
            [
                "For Loop Body",
                13,
                17
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "If Statement Body",
                16,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef EMxdm():\n    \"\"\"Tomya is a girl. She loves Chef Ciel very much.\n\nTomya like a positive integer p, and now she wants to get a receipt of Ciel's restaurant whose total price is exactly p.\nThe current menus of Ciel's restaurant are shown the following table.\nName of Menupriceeel flavored water1deep-fried eel bones2clear soup made with eel livers4grilled eel livers served with grated radish8savory egg custard with eel16eel fried rice (S)32eel fried rice (L)64grilled eel wrapped in cooked egg128eel curry rice256grilled eel over rice512deluxe grilled eel over rice1024eel full-course2048\n\nNote that the i-th menu has the price 2i-1 (1 ≤ i ≤ 12).\n\nSince Tomya is a pretty girl, she cannot eat a lot.\nSo please find the minimum number of menus whose total price is exactly p.\nNote that if she orders the same menu twice, then it is considered as two menus are ordered. (See Explanations for details)\n\n-----Input-----\n\nThe first line contains an integer T, the number of test cases.\nThen T test cases follow.\nEach test case contains an integer p.\n\n-----Output-----\n\nFor each test case, print the minimum number of menus whose total price is exactly p.\n\n-----Constraints-----\n\n1 ≤ T ≤ 5\n\n1 ≤ p ≤ 100000 (105)\n\nThere exists combinations of menus whose total price is exactly p.\n\n-----Sample Input-----\n4\n10\n256\n255\n4096\n\n-----Sample Output-----\n2\n1\n8\n2\n\n-----Explanations-----\n\nIn the first sample, examples of the menus whose total price is 10 are the following:\n\n1+1+1+1+1+1+1+1+1+1 = 10 (10 menus)\n\n1+1+1+1+1+1+1+1+2 = 10 (9 menus)\n\n2+2+2+2+2 = 10 (5 menus)\n\n2+4+4 = 10 (3 menus)\n\n2+8 = 10 (2 menus)\n\nHere the minimum number of menus is 2.\n\nIn the last sample, the optimal way is 2048+2048=4096 (2 menus).\nNote that there is no menu whose price is 4096.\n    \"\"\"\n",
        "canonical_solution": "\ndef EMxdm():\n    t= int(input())\n    while(t>0):\n        n = int(input())\n        m=0\n        m=n//(2**11)\n        n%=(2**11)\n        while(n>0):\n            num=n%2\n            m+=num\n            n//=2\n        print(m)\n        t-=1",
        "inputs": [
            "4\n10\n256\n255\n4096\n"
        ],
        "outputs": [
            "2\n1\n8\n2\n"
        ],
        "starter_code": "\ndef EMxdm():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "While Loop Body",
                4,
                14
            ],
            [
                "While Loop Body",
                9,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef VxTyX():\n    \"\"\"Anmol gained a lot of weight last semester. So this semester, he decided to run everyday. There is a very long straight road starting at his hostel. There are N poles on the road - P1, P2, P3,..., PN on the road. All the poles lie on the same side of his hostel. The distance between Pi and his hostel is Di.\nFor 1 ≤ i, j ≤ N, i < j implies Di < Dj\nEveryday, Anmol chooses a pole Pi to start running from. He keeps on running until he reaches Pi+K. Whenever he reaches a pole (other than the starting pole), he records the distance traveled since the last pole.\n\nYou are given the distances recorded by him today. Your task is to find the number of distinct values of i such that i + K ≤ N and if he starts at Pi and end at Pi+K, he would end up having exactly the same record of distances (in the same order).\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases.\n- The first line of each test case contains two space separated integers N and K.\n- The next line contains N space separated integers D1, D2,..., DN.\n- The next line contains K space separated integers representing the distances recorded by Anmol in the same order.\n.\n\n-----Output-----\n- For each test case, output a single line containing the answer for that test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ N ≤ 5 x 104\n- 1 ≤ K < N\n- 1 ≤ Di ≤ 106\n\n-----Subtasks-----\n\n-----Subtask #1 (20 points)-----\n- 1 ≤ N ≤ 1000\n\n-----Subtask #2 (80 points)-----\n- Original constraints\n\n-----Example-----\nInput:\n3\n5 1\n1 5 10 12 14\n5\n5 2\n5 8 13 16 21\n3 5\n5 3\n2 6 8 11 16\n2 3 5\n\nOutput:\n1\n2\n1\n\n-----Explanation-----\nExample case 1. If he runs from P2 to P3, he will record (5)\nExample case 2. He can start at P1 or P3\nExample case 3. He can start at P2\n    \"\"\"\n",
        "canonical_solution": "\ndef VxTyX():\n    #code snippet reference:http://www.geeksforgeeks.org/searching-for-patterns-set    -2-kmp-algorithm/\n    def KMPMatch(pattern, string):\n     M = len(pattern)\n     N = len(string)\n     nonlocal ans\n    \n     lps = [0]*M\n     j = 0 \n     LPSCompute(pattern, M, lps)\n    \n     i = 0 \n     while i < N:\n      if pattern[j] == string[i]:\n       i+=1\n       j+=1\n    \n      if j==M:\n       ans+=1\n       j = lps[j-1]\n       \n      elif i < N and pattern[j] != string[i]:\n       if j != 0:\n        j = lps[j-1]\n       else:\n        i+=1\n    \n    def LPSCompute(pattern, M, lps):\n     len = 0 \n     lps[0] \n     i = 1\n     while i < M:\n      if pattern[i]==pattern[len]:\n       len+=1\n       lps[i] = len\n       i+=1\n      else:\n       if len!=0:\n        len = lps[len-1]\n    \n       else:\n        lps[i] = 0\n        i+=1\n    \n    for _ in range(int(input())):\n     n,k=list(map(int,input().split()))\n     s=list(map(int,input().split()))\n     pattern=list(map(int,input().split()))\n     ans=0\n     string=[]\n     for i in range(n-1):\n      string.append(s[i+1]-s[i])\n     KMPMatch(pattern, string)\n     print(ans)\n    \n    ",
        "inputs": [
            "3\n5 1\n1 5 10 12 14\n5\n5 2\n5 8 13 16 21\n3 5\n5 3\n2 6 8 11 16\n2 3 5\n"
        ],
        "outputs": [
            "1\n2\n1\n"
        ],
        "starter_code": "\ndef VxTyX():\n",
        "scope": [
            [
                "Function Body",
                2,
                55
            ],
            [
                "Function Body",
                4,
                27
            ],
            [
                "While Loop Body",
                14,
                27
            ],
            [
                "If Statement Body",
                15,
                17
            ],
            [
                "If Statement Body",
                19,
                27
            ],
            [
                "If Statement Body",
                23,
                27
            ],
            [
                "If Statement Body",
                24,
                27
            ],
            [
                "Function Body",
                29,
                44
            ],
            [
                "While Loop Body",
                33,
                44
            ],
            [
                "If Statement Body",
                34,
                44
            ],
            [
                "If Statement Body",
                39,
                44
            ],
            [
                "For Loop Body",
                46,
                55
            ],
            [
                "For Loop Body",
                52,
                53
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef rEPGL():\n    \"\"\"A necklace can be described as a string of links ('-') and pearls ('o'), with the last link or pearl connected to the first one. $0$ \n\nYou can remove a link or a pearl and insert it between two other existing links or pearls (or between a link and a pearl) on the necklace. This process can be repeated as many times as you like, but you can't throw away any parts.\n\nCan you make the number of links between every two adjacent pearls equal? Two pearls are considered to be adjacent if there is no other pearl between them.\n\nNote that the final necklace should remain as one circular part of the same length as the initial necklace.\n\n\n-----Input-----\n\nThe only line of input contains a string $s$ ($3 \\leq |s| \\leq 100$), representing the necklace, where a dash '-' represents a link and the lowercase English letter 'o' represents a pearl.\n\n\n-----Output-----\n\nPrint \"YES\" if the links and pearls can be rejoined such that the number of links between adjacent pearls is equal. Otherwise print \"NO\".\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n-o-o--\nOutput\nYES\nInput\n-o---\n\nOutput\nYES\nInput\n-o---o-\n\nOutput\nNO\nInput\nooo\n\nOutput\nYES\n    \"\"\"\n",
        "canonical_solution": "\ndef rEPGL():\n    def main():\n        s = input()\n        links = s.count('-')\n        pearls = s.count('o')\n        if pearls == 0 or links % pearls == 0:\n            print('YES')\n        else:\n            print('NO')\n    \n    main()\n    ",
        "inputs": [
            "-o-o--\n",
            "-o---\n",
            "-o---o-\n"
        ],
        "outputs": [
            "YES\n",
            "YES\n",
            "NO\n"
        ],
        "starter_code": "\ndef rEPGL():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "Function Body",
                3,
                10
            ],
            [
                "If Statement Body",
                7,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n            \"\"\"Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n\nExample 1:\n\nInput:nums = [1,1,1], k = 2\nOutput: 2\n\n\n\nNote:\n\nThe length of the array is in range [1, 20,000].\nThe range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def subarraySum(self, nums, k):\n         \"\"\"\n         :type nums: List[int]\n         :type k: int\n         :rtype: int\n         \"\"\"\n         \n         dic = {}\n         numSum = 0\n         dic[0] = 1\n         ans = 0\n         for i in range(len(nums)):\n             numSum += nums[i]\n             if (numSum - k) in dic:\n                 ans += dic[numSum - k]\n             if numSum in dic:\n                 dic[numSum] += 1\n             else:\n                 dic[numSum] = 1\n         return ans",
        "inputs": [
            [
                [
                    1,
                    1,
                    1
                ],
                2
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                21
            ],
            [
                "Function Body",
                2,
                21
            ],
            [
                "For Loop Body",
                13,
                20
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "If Statement Body",
                17,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef bdiAV():\n    \"\"\"Little kids, Jack and Evan like playing their favorite game Glass-and-Stone. Today they want to play something new and came across Twitter on their father's laptop.\n\nThey saw it for the first time but were already getting bored to see a bunch of sentences having at most 140 characters each. The only thing they liked to play with it is, closing and opening tweets.\n\nThere are N tweets on the page and each tweet can be opened by clicking on it, to see some statistics related to that tweet. Initially all the tweets are closed. Clicking on an open tweet closes it and clicking on a closed tweet opens it. There is also a button to close all the open tweets. Given a sequence of K clicks by Jack, Evan has to guess the total number of open tweets just after each click. Please help Evan in this game.\n\n-----Input-----\nFirst line contains two integers N K, the number of tweets (numbered 1 to N) and the number of clicks respectively (1 ≤ N, K ≤ 1000). Each of the following K lines has one of the following.\n\n- CLICK X , where X is the tweet number (1 ≤ X ≤ N)\n- CLOSEALL\n\n-----Output-----\nOutput K lines, where the ith line should contain the number of open tweets just after the ith click.\n\n-----Example-----\nInput:\n3 6\nCLICK 1\nCLICK 2\nCLICK 3\nCLICK 2\nCLOSEALL\nCLICK 1\n\nOutput:\n1\n2\n3\n2\n0\n1\n\nExplanation:\n\nLet open[x] = 1 if the xth tweet is open and 0 if its closed.\n\nInitially open[1..3] = { 0 , 0 , 0 }. Here is the state of open[1..3] after each click and corresponding count of open tweets.\n\nCLICK 1 : { 1, 0, 0 }, open count = 1\n\nCLICK 2 : { 1, 1, 0 }, open count = 2\n\nCLICK 3 : { 1, 1, 1 }, open count = 3\n\nCLICK 2 : { 1, 0, 1 }, open count = 2\n\nCLOSEALL : { 0, 0, 0 }, open count = 0\n\nCLICK 1 : { 1, 0, 0 }, open count = 1\n    \"\"\"\n",
        "canonical_solution": "\ndef bdiAV():\n    def getInput():\n     N_k = input().split()\n     N =int(N_k[0])\n     k =int(N_k[1])\n     list = []\n     output = []\n     count = 0\n     for i in range(0,k):\n      val = input()\n      if(val!=\"CLOSEALL\"):\n       val=val.split()\n       val = int (val[1])\n       if val not in list:\n        count= count +1\n        list.append(val)\n       else:\n        list.remove(val)\n        count= count -1\n      else:\n       count =0\n       while len(list) > 0: \n        list.pop()\n      output.append(count)\n     for each in output:\n      print(each)\n    getInput()",
        "inputs": [
            "3 6\nCLICK 1\nCLICK 2\nCLICK 3\nCLICK 2\nCLOSEALL\nCLICK 1\n"
        ],
        "outputs": [
            "1\n2\n3\n2\n0\n1\n"
        ],
        "starter_code": "\ndef bdiAV():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "Function Body",
                3,
                27
            ],
            [
                "For Loop Body",
                10,
                25
            ],
            [
                "If Statement Body",
                12,
                24
            ],
            [
                "If Statement Body",
                15,
                20
            ],
            [
                "While Loop Body",
                23,
                24
            ],
            [
                "For Loop Body",
                26,
                27
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GxRJq():\n    \"\"\"For years, the Day of city N was held in the most rainy day of summer. New mayor decided to break this tradition and select a not-so-rainy day for the celebration. The mayor knows the weather forecast for the $n$ days of summer. On the $i$-th day, $a_i$ millimeters of rain will fall. All values $a_i$ are distinct.\n\nThe mayor knows that citizens will watch the weather $x$ days before the celebration and $y$ days after. Because of that, he says that a day $d$ is not-so-rainy if $a_d$ is smaller than rain amounts at each of $x$ days before day $d$ and and each of $y$ days after day $d$. In other words, $a_d < a_j$ should hold for all $d - x \\le j < d$ and $d < j \\le d + y$. Citizens only watch the weather during summer, so we only consider such $j$ that $1 \\le j \\le n$.\n\nHelp mayor find the earliest not-so-rainy day of summer.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $x$ and $y$ ($1 \\le n \\le 100\\,000$, $0 \\le x, y \\le 7$) — the number of days in summer, the number of days citizens watch the weather before the celebration and the number of days they do that after.\n\nThe second line contains $n$ distinct integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ denotes the rain amount on the $i$-th day.\n\n\n-----Output-----\n\nPrint a single integer — the index of the earliest not-so-rainy day of summer. We can show that the answer always exists.\n\n\n-----Examples-----\nInput\n10 2 2\n10 9 6 7 8 3 2 1 4 5\n\nOutput\n3\n\nInput\n10 2 3\n10 9 6 7 8 3 2 1 4 5\n\nOutput\n8\n\nInput\n5 5 5\n100000 10000 1000 100 10\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first example days $3$ and $8$ are not-so-rainy. The $3$-rd day is earlier.\n\nIn the second example day $3$ is not not-so-rainy, because $3 + y = 6$ and $a_3 > a_6$. Thus, day $8$ is the answer. Note that $8 + y = 11$, but we don't consider day $11$, because it is not summer.\n    \"\"\"\n",
        "canonical_solution": "\ndef GxRJq():\n    n, x, y = list(map(int, input().split()))\n    arr = [int(x) for x in input().split()]\n    for i in range(n):\n        if arr[i] == min(arr[max(0, i - x):i + y + 1]):\n            print(i + 1)\n            break\n    ",
        "inputs": [
            "10 2 2\n10 9 6 7 8 3 2 1 4 5\n",
            "10 2 3\n10 9 6 7 8 3 2 1 4 5\n",
            "5 5 5\n100000 10000 1000 100 10\n"
        ],
        "outputs": [
            "3\n",
            "8\n",
            "5\n"
        ],
        "starter_code": "\ndef GxRJq():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "If Statement Body",
                6,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef uEnxv():\n    \"\"\"Given an array of size N$N$ and two integers K$K$ and S$S$, the special sum of a subarray is defined as follows:\n\n(Sum of all elements of the subarray) * (K$K$ - p$p$ * S$S$)\n\nWhere p$p$ = number of distinct prime factors of “product of all elements of the subarray”.\n\nFind the maximum special sum by considering all non-empty subarrays of the given array.\n\n-----Input-----\n- First line contains 3 integers N$N$, K$K$ and S$S$.     \n- Second line contains N$N$ integers, the elements of the array.  \n\n-----Output-----\nOutput a single integer. The maximum special sum considering all non-empty subarrays of the array.\n\n-----Constraints:-----\n- 1≤N,K,S≤105$ 1 \\leq N, K, S \\leq 10^5 $ \n- 0≤K/S≤20$ 0 \\leq K / S \\leq 20 $ \n- 1<$ 1 < $ Any element of array <105$ < 10^5 $\n\n-----Sample Input-----\n4 10 2\n\n14 2 7 15\n\n-----Sample Output-----\n138\n\n-----Sample Explanation-----\nConsider the subarray {14, 2, 7}\n\nTotal number of distinct prime factors in it is 2 (2 and 7).\n\nTherefore, value of special sum is (14 + 2 + 7) * (10 - 2 * 2) = 138.\n\nThis is the subarray with the maximum special sum.\n    \"\"\"\n",
        "canonical_solution": "from math import floor, sqrt\ndef uEnxv():\n    # cook your dish here\n    try:long\n    except NameError:long = int \n    def fac(n):\n        step,maxq,d = lambda x: 1 + (x<<2) - ((x>>1)<<1),long(floor(sqrt(n))),1\n        q = n % 2 == 0 and 2 or 3 \n        while q <= maxq and n % q != 0:\n         q = step(d)\n         d += 1\n        return q <= maxq and [q] + fac(n//q) or [n]\n    n,k,s = map(int,input().split())\n    a,di,l,m,ans,su =list(map(int,input().split())),{},[],0,0,0\n    for i in a:\n        bb,su = list(set(fac(i))),su+i\n        for j in bb:\n         try:di[j]+=1\n         except KeyError:m,di[j] = m+1,1\n        l.append(su*(k-m*s))\n        if su*(k-m*s) <0:m,di,su = 0,{},0\n    print(max(l))",
        "inputs": [
            "4 10 2\n14 2 7 15\n"
        ],
        "outputs": [
            "138\n"
        ],
        "starter_code": "\ndef uEnxv():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "Try Block",
                4,
                5
            ],
            [
                "Except Block",
                5,
                5
            ],
            [
                "Function Body",
                6,
                12
            ],
            [
                "Lambda Expression",
                7,
                7
            ],
            [
                "While Loop Body",
                9,
                11
            ],
            [
                "For Loop Body",
                15,
                21
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "Try Block",
                18,
                19
            ],
            [
                "Except Block",
                19,
                19
            ],
            [
                "If Statement Body",
                21,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef QsIVN():\n    \"\"\"Blake is a CEO of a large company called \"Blake Technologies\". He loves his company very much and he thinks that his company should be the best. That is why every candidate needs to pass through the interview that consists of the following problem.\n\nWe define function f(x, l, r) as a bitwise OR of integers x_{l}, x_{l} + 1, ..., x_{r}, where x_{i} is the i-th element of the array x. You are given two arrays a and b of length n. You need to determine the maximum value of sum f(a, l, r) + f(b, l, r) among all possible 1 ≤ l ≤ r ≤ n. [Image] \n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 1000) — the length of the arrays.\n\nThe second line contains n integers a_{i} (0 ≤ a_{i} ≤ 10^9).\n\nThe third line contains n integers b_{i} (0 ≤ b_{i} ≤ 10^9).\n\n\n-----Output-----\n\nPrint a single integer — the maximum value of sum f(a, l, r) + f(b, l, r) among all possible 1 ≤ l ≤ r ≤ n.\n\n\n-----Examples-----\nInput\n5\n1 2 4 3 2\n2 3 3 12 1\n\nOutput\n22\nInput\n10\n13 2 7 11 8 4 9 8 5 1\n5 7 18 9 2 3 0 11 8 6\n\nOutput\n46\n\n\n-----Note-----\n\nBitwise OR of two non-negative integers a and b is the number c = a OR b, such that each of its digits in binary notation is 1 if and only if at least one of a or b have 1 in the corresponding position in binary notation.\n\nIn the first sample, one of the optimal answers is l = 2 and r = 4, because f(a, 2, 4) + f(b, 2, 4) = (2 OR 4 OR 3) + (3 OR 3 OR 12) = 7 + 15 = 22. Other ways to get maximum value is to choose l = 1 and r = 4, l = 1 and r = 5, l = 2 and r = 4, l = 2 and r = 5, l = 3 and r = 4, or l = 3 and r = 5.\n\nIn the second sample, the maximum value is obtained for l = 1 and r = 9.\n    \"\"\"\n",
        "canonical_solution": "\ndef QsIVN():\n    def f(m):\n        v = 0\n        for x in m:\n            v |= x\n        return v\n    input()\n    print(f(map(int, input().split())) + f(map(int, input().split())))",
        "inputs": [
            "5\n1 2 4 3 2\n2 3 3 12 1\n",
            "10\n13 2 7 11 8 4 9 8 5 1\n5 7 18 9 2 3 0 11 8 6\n",
            "25\n12 30 38 109 81 124 80 33 38 48 29 78 96 48 96 27 80 77 102 65 80 113 31 118 35\n25 64 95 13 12 6 111 80 85 16 61 119 23 65 73 65 20 95 124 18 28 79 125 106 116\n"
        ],
        "outputs": [
            "22",
            "46",
            "254"
        ],
        "starter_code": "\ndef QsIVN():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "For Loop Body",
                5,
                6
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef BJYmC():\n    \"\"\"Chef has a number N, Cheffina challenges the chef to check the divisibility of all the permutation of N by 5. If any of the permutations is divisible by 5 then print 1 else print 0.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input,$N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n19\n385\n\n-----Sample Output:-----\n0\n1\n    \"\"\"\n",
        "canonical_solution": "\ndef BJYmC():\n    a = int(input())\r\n    for i in range(a):\r\n    \tb = input()\r\n    \tif '5' in b or '0' in b:\r\n    \t\tprint(1)\r\n    \t\tcontinue\r\n    \tprint(0)",
        "inputs": [
            "2\n19\n385\n"
        ],
        "outputs": [
            "0\n1\n"
        ],
        "starter_code": "\ndef BJYmC():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                4,
                9
            ],
            [
                "If Statement Body",
                6,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GwoKX():\n    \"\"\"In this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline).\nYour task is print the words in the text in lexicographic order (that is, dictionary order). Each word should appear exactly once in your list. You can ignore the case (for instance, \"The\" and \"the\" are to be treated as the same word). There should be no uppercase letters in the output.\nFor example, consider the following candidate for the input text: \nThis is a sample piece of text to illustrate this \nproblem.\n\nThe corresponding output would read as:\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n\n-----Input format-----\n- The first line of input contains a single integer $N$, indicating the number of lines in the input.\n- This is followed by $N$ lines of input text.\n\n-----Output format-----\n- The first line of output contains a single integer $M$ indicating the number of distinct words in the given text. \n- The next $M$ lines list out these words in lexicographic order.\n\n-----Constraints-----\n- $1 \\leq N \\leq 10000$\n- There are at most 80 characters in each line.\n- There are at the most 1000 distinct words in the given text.\n\n-----Sample Input-----\n2\nThis is a sample piece of text to illustrate this \nproblem. \n\n-----Sample Output-----\n10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef GwoKX():\n    t=int(input())\n    x=sys.stdin.readlines()\n    l=[]\n    for s in x:\n        s=s.replace(\".\",\"\")\n        s=s.replace(\"'\",\"\")\n        s=s.replace(\",\",\"\")\n        s=s.replace(\":\",\"\")\n        s=s.replace(\";\",\"\")\n        lst=[str(i) for i in s.split()]\n        for j in lst:\n            l.append(j)\n    m=[]\n    for y in l:\n        z=y.lower()\n        m.append(z)\n    n=[]\n    for  k in m:\n        if(k in n):\n            continue\n        else:\n            n.append(k)\n    print(len(n))\n    h=sorted(n)\n    for j in h:\n        print(j)",
        "inputs": [
            "2\nThis is a sample piece of text to illustrate this\nproblem.\n"
        ],
        "outputs": [
            "10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n"
        ],
        "starter_code": "\ndef GwoKX():\n",
        "scope": [
            [
                "Function Body",
                2,
                28
            ],
            [
                "For Loop Body",
                6,
                14
            ],
            [
                "List Comprehension",
                12,
                12
            ],
            [
                "For Loop Body",
                13,
                14
            ],
            [
                "For Loop Body",
                16,
                18
            ],
            [
                "For Loop Body",
                20,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ],
            [
                "For Loop Body",
                27,
                28
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wZmSz():\n    \"\"\"Vasya takes part in the orienteering competition. There are n checkpoints located along the line at coordinates x_1, x_2, ..., x_{n}. Vasya starts at the point with coordinate a. His goal is to visit at least n - 1 checkpoint in order to finish the competition. Participant are allowed to visit checkpoints in arbitrary order.\n\nVasya wants to pick such checkpoints and the order of visiting them that the total distance travelled is minimized. He asks you to calculate this minimum possible value.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and a (1 ≤ n ≤ 100 000,  - 1 000 000 ≤ a ≤ 1 000 000) — the number of checkpoints and Vasya's starting position respectively.\n\nThe second line contains n integers x_1, x_2, ..., x_{n} ( - 1 000 000 ≤ x_{i} ≤ 1 000 000) — coordinates of the checkpoints.\n\n\n-----Output-----\n\nPrint one integer — the minimum distance Vasya has to travel in order to visit at least n - 1 checkpoint.\n\n\n-----Examples-----\nInput\n3 10\n1 7 12\n\nOutput\n7\n\nInput\n2 0\n11 -10\n\nOutput\n10\n\nInput\n5 0\n0 0 1000 0 0\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample Vasya has to visit at least two checkpoints. The optimal way to achieve this is the walk to the third checkpoints (distance is 12 - 10 = 2) and then proceed to the second one (distance is 12 - 7 = 5). The total distance is equal to 2 + 5 = 7.\n\nIn the second sample it's enough to visit only one checkpoint so Vasya should just walk to the point  - 10.\n    \"\"\"\n",
        "canonical_solution": "from math import *\ndef wZmSz():\n    n, a = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    if n == 1:\n        print(0)\n        \n    else:\n        if a > A[-1]:\n            print(abs(a - A[1]))\n        elif a < A[0]:\n            print(abs(a - A[-2]))\n        else:\n            per1 = abs(A[0] - A[-2])\n            per2 = abs(A[1] - A[-1])\n            ans1 = abs(A[0] - a) + per1\n            ans2 = per1 + abs(A[-2] - a)\n            ans3 = per2 + abs(a - A[-1])\n            ans4 = per2 + abs(a - A[1])\n            print(min(ans1, ans2, ans3, ans4))",
        "inputs": [
            "3 10\n1 7 12\n",
            "2 0\n11 -10\n",
            "5 0\n0 0 1000 0 0\n"
        ],
        "outputs": [
            "7\n",
            "10\n",
            "0\n"
        ],
        "starter_code": "\ndef wZmSz():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "If Statement Body",
                6,
                21
            ],
            [
                "If Statement Body",
                10,
                21
            ],
            [
                "If Statement Body",
                12,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef rzkPx():\n    \"\"\"Polycarp is preparing the first programming contest for robots. There are $n$ problems in it, and a lot of robots are going to participate in it. Each robot solving the problem $i$ gets $p_i$ points, and the score of each robot in the competition is calculated as the sum of $p_i$ over all problems $i$ solved by it. For each problem, $p_i$ is an integer not less than $1$.\n\nTwo corporations specializing in problem-solving robot manufacturing, \"Robo-Coder Inc.\" and \"BionicSolver Industries\", are going to register two robots (one for each corporation) for participation as well. Polycarp knows the advantages and flaws of robots produced by these companies, so, for each problem, he knows precisely whether each robot will solve it during the competition. Knowing this, he can try predicting the results — or manipulating them. \n\nFor some reason (which absolutely cannot involve bribing), Polycarp wants the \"Robo-Coder Inc.\" robot to outperform the \"BionicSolver Industries\" robot in the competition. Polycarp wants to set the values of $p_i$ in such a way that the \"Robo-Coder Inc.\" robot gets strictly more points than the \"BionicSolver Industries\" robot. However, if the values of $p_i$ will be large, it may look very suspicious — so Polycarp wants to minimize the maximum value of $p_i$ over all problems. Can you help Polycarp to determine the minimum possible upper bound on the number of points given for solving the problems?\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100$) — the number of problems.\n\nThe second line contains $n$ integers $r_1$, $r_2$, ..., $r_n$ ($0 \\le r_i \\le 1$). $r_i = 1$ means that the \"Robo-Coder Inc.\" robot will solve the $i$-th problem, $r_i = 0$ means that it won't solve the $i$-th problem.\n\nThe third line contains $n$ integers $b_1$, $b_2$, ..., $b_n$ ($0 \\le b_i \\le 1$). $b_i = 1$ means that the \"BionicSolver Industries\" robot will solve the $i$-th problem, $b_i = 0$ means that it won't solve the $i$-th problem.\n\n\n-----Output-----\n\nIf \"Robo-Coder Inc.\" robot cannot outperform the \"BionicSolver Industries\" robot by any means, print one integer $-1$.\n\nOtherwise, print the minimum possible value of $\\max \\limits_{i = 1}^{n} p_i$, if all values of $p_i$ are set in such a way that the \"Robo-Coder Inc.\" robot gets strictly more points than the \"BionicSolver Industries\" robot.\n\n\n-----Examples-----\nInput\n5\n1 1 1 0 0\n0 1 1 1 1\n\nOutput\n3\n\nInput\n3\n0 0 0\n0 0 0\n\nOutput\n-1\n\nInput\n4\n1 1 1 1\n1 1 1 1\n\nOutput\n-1\n\nInput\n9\n1 0 0 0 0 0 0 0 1\n0 1 1 0 1 1 1 1 0\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example, one of the valid score assignments is $p = [3, 1, 3, 1, 1]$. Then the \"Robo-Coder\" gets $7$ points, the \"BionicSolver\" — $6$ points.\n\nIn the second example, both robots get $0$ points, and the score distribution does not matter.\n\nIn the third example, both robots solve all problems, so their points are equal.\n    \"\"\"\n",
        "canonical_solution": "\ndef rzkPx():\n    n=int(input())\n    r = [int(x) for x in input().split()]\n    s = [int(x) for x in input().split()]\n    a=0\n    b=0\n    for i in range(n):\n        if r[i]==1 and s[i]==0:\n            a+=1\n        if r[i]==0 and s[i]==1:\n            b+=1\n    if a==0:\n        print(-1)\n    else:\n        print((b)//a+1)",
        "inputs": [
            "5\n1 1 1 0 0\n0 1 1 1 1\n",
            "3\n0 0 0\n0 0 0\n",
            "4\n1 1 1 1\n1 1 1 1\n"
        ],
        "outputs": [
            "3\n",
            "-1\n",
            "-1\n"
        ],
        "starter_code": "\ndef rzkPx():\n",
        "scope": [
            [
                "Function Body",
                2,
                16
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "If Statement Body",
                13,
                16
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef YPDiU():\n    \"\"\"Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0, 0). The robot can process commands. There are four types of commands it can perform:  U — move from the cell (x, y) to (x, y + 1);  D — move from (x, y) to (x, y - 1);  L — move from (x, y) to (x - 1, y);  R — move from (x, y) to (x + 1, y). \n\nIvan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0, 0), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!\n\n\n-----Input-----\n\nThe first line contains one number n — the length of sequence of commands entered by Ivan (1 ≤ n ≤ 100).\n\nThe second line contains the sequence itself — a string consisting of n characters. Each character can be U, D, L or R.\n\n\n-----Output-----\n\nPrint the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.\n\n\n-----Examples-----\nInput\n4\nLDUR\n\nOutput\n4\n\nInput\n5\nRRRUU\n\nOutput\n0\n\nInput\n6\nLLRRRR\n\nOutput\n4\n    \"\"\"\n",
        "canonical_solution": "\ndef YPDiU():\n    '''input\n    6\n    LLRRRR\n    '''\n    n = int(input())\n    s = input()\n    h, v = min(s.count(\"L\"), s.count(\"R\")), min(s.count(\"U\"), s.count(\"D\"))\n    print(2*h + 2*v)",
        "inputs": [
            "4\nLDUR\n",
            "5\nRRRUU\n",
            "6\nLLRRRR\n"
        ],
        "outputs": [
            "4\n",
            "0\n",
            "4\n"
        ],
        "starter_code": "\ndef YPDiU():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ZgqJE():\n    \"\"\"The Resistance is trying to take control over all planets in a particular solar system. This solar system is shaped like a tree. More precisely, some planets are connected by bidirectional hyperspace tunnels in such a way that there is a path between every pair of the planets, but removing any tunnel would disconnect some of them.\n\nThe Resistance already has measures in place that will, when the time is right, enable them to control every planet that is not remote. A planet is considered to be remote if it is connected to the rest of the planets only via a single hyperspace tunnel.\n\nHow much work is there left to be done: that is, how many remote planets are there?\n\n\n-----Input-----\n\nThe first line of the input contains an integer N (2 ≤ N ≤ 1000) – the number of planets in the galaxy.\n\nThe next N - 1 lines describe the hyperspace tunnels between the planets. Each of the N - 1 lines contains two space-separated integers u and v (1 ≤ u, v ≤ N) indicating that there is a bidirectional hyperspace tunnel between the planets u and v. It is guaranteed that every two planets are connected by a path of tunnels, and that each tunnel connects a different pair of planets.\n\n\n-----Output-----\n\nA single integer denoting the number of remote planets.\n\n\n-----Examples-----\nInput\n5\n4 1\n4 2\n1 3\n1 5\n\nOutput\n3\n\nInput\n4\n1 2\n4 3\n1 4\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example, only planets 2, 3 and 5 are connected by a single tunnel.\n\nIn the second example, the remote planets are 2 and 3.\n\nNote that this problem has only two versions – easy and medium.\n    \"\"\"\n",
        "canonical_solution": "\ndef ZgqJE():\n    N = int(input())\n    cnt = [0] * N\n    for n in range(N - 1):\n        u, v = list(map(int, input().split()))\n        cnt[u - 1] += 1\n        cnt[v - 1] += 1\n    \n    print(sum(x == 1 for x in cnt))\n    ",
        "inputs": [
            "5\n4 1\n4 2\n1 3\n1 5\n",
            "4\n1 2\n4 3\n1 4\n",
            "10\n4 3\n2 6\n10 1\n5 7\n5 8\n10 6\n5 9\n9 3\n2 9\n"
        ],
        "outputs": [
            "3\n",
            "2\n",
            "4\n"
        ],
        "starter_code": "\ndef ZgqJE():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "Generator Expression",
                10,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fUJxb():\n    \"\"\"Is it rated?\n\nHere it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.\n\nAnother Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.\n\nIt's known that if at least one participant's rating has changed, then the round was rated for sure.\n\nIt's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.\n\nIn this problem, you should not make any other assumptions about the rating system.\n\nDetermine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.\n\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 1000) — the number of round participants.\n\nEach of the next n lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 4126) — the rating of the i-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.\n\n\n-----Output-----\n\nIf the round is rated for sure, print \"rated\". If the round is unrated for sure, print \"unrated\". If it's impossible to determine whether the round is rated or not, print \"maybe\".\n\n\n-----Examples-----\nInput\n6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n\nOutput\nrated\n\nInput\n4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n\nOutput\nunrated\n\nInput\n5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n\nOutput\nmaybe\n\n\n\n-----Note-----\n\nIn the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.\n\nIn the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.\n\nIn the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.\n    \"\"\"\n",
        "canonical_solution": "\ndef fUJxb():\n    '''input\n    5\n    3123 3123\n    2777 2777\n    2246 2246\n    2246 2246\n    1699 1699\n    '''\n    n = int(input())\n    x = []\n    f = 0\n    for _ in range(n):\n    \ta, b = list(map(int, input().split()))\n    \tif a != b:\n    \t\tf = 1\n    \tx.append(a)\n    if f == 1:\n    \tprint(\"rated\")\n    elif sorted(x)[::-1] == x:\n    \tprint(\"maybe\")\n    else:\n    \tprint(\"unrated\")\n    \n    \n    \n    \n    \n    \n    \n    ",
        "inputs": [
            "6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n",
            "4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n",
            "5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n"
        ],
        "outputs": [
            "rated\n",
            "unrated\n",
            "maybe\n"
        ],
        "starter_code": "\ndef fUJxb():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "For Loop Body",
                14,
                18
            ],
            [
                "If Statement Body",
                16,
                17
            ],
            [
                "If Statement Body",
                19,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RLwbK():\n    \"\"\"As you know America’s Presidential Elections are about to take place and the most popular leader of the Republican party Donald Trump is famous for throwing allegations against anyone he meets.\n\nHe goes to a rally and meets n people which he wants to offend. For each person i he can choose an integer between 1 to max[i].\n\nHe wants to decide in how many ways he can offend all these persons (N) given the condition that all numbers chosen by him for each person are distinct.\nSo he needs your help to find out the number of ways in which he can do that. If no solution is possible print 0\n\n-----Input-----\nThe first line of the input contains an integer T (1<=T<=100) denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case contains a single integer N denoting the number of people Trump wants to offend. The second line contains N space-separated integers maxnumber[0], maxnumber[1], ..., maxnumber[n-1] denoting the maxnumber that trump can choose for each person. \n\n-----Output-----\nFor each test case, output a single line containing the number of ways Trump can assign numbers to the people, modulo 1,000,000,007. If it's impossible to assign distinct integers to the people, print 0\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 50\n- 1 ≤ Maxnumber[i] ≤ 3000\n\n-----Example-----\nInput:\n3\n1\n4\n2\n10 5\n4\n2 3 1 3\n\nOutput:\n4\n45\n0\n\n\n-----Explanation-----\nIn case 1, He can choose any number from 1 to 4\n\nIn case 2,Out of the total 50 combination he can not take (1,1) ,(2,2) , (3,3) ,(4,4) or (5,5).\n    \"\"\"\n",
        "canonical_solution": "\ndef RLwbK():\n    for t in range(int(input())):\n     n = int(input())\n     a = sorted(map(int,input().split()))\n     ans = 1\n     for i in range(n):\n      ans *= (a[i]-i)\n      ans %= (10**9+7)\n      if (ans == 0):\n       break\n     print(ans) ",
        "inputs": [
            "3\n1\n4\n2\n10 5\n4\n2 3 1 3\n"
        ],
        "outputs": [
            "4\n45\n0\n"
        ],
        "starter_code": "\ndef RLwbK():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                3,
                12
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                10,
                11
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef sYCMz():\n    \"\"\"Chef has a pepperoni pizza in the shape of a $N \\times N$ grid; both its rows and columns are numbered $1$ through $N$. Some cells of this grid have pepperoni on them, while some do not. Chef wants to cut the pizza vertically in half and give the two halves to two of his friends. Formally, one friend should get everything in the columns $1$ through $N/2$ and the other friend should get everything in the columns $N/2+1$ through $N$.\nBefore doing that, if Chef wants to, he may choose one row of the grid and reverse it, i.e. swap the contents of the cells in the $i$-th and $N+1-i$-th column in this row for each $i$ ($1 \\le i \\le N/2$).\nAfter the pizza is cut, let's denote the number of cells containing pepperonis in one half by $p_1$ and their number in the other half by $p_2$. Chef wants to minimise their absolute difference. What is the minimum value of $|p_1-p_2|$?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains a string with length $N$ describing the $i$-th row of the grid; this string contains only characters '1' (denoting a cell with pepperonis) and '0' (denoting a cell without pepperonis).\n\n-----Output-----\nFor each test case, print a single line containing one integer — the minimum absolute difference between the number of cells with pepperonis in the half-pizzas given to Chef's friends.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $2 \\le N \\le 1,000$\n- $N$ is even\n- the sum of $N \\cdot N$ over all test cases does not exceed $2 \\cdot 10^6$\n\n-----Example Input-----\n2\n6\n100000\n100000\n100000\n100000\n010010\n001100\n4\n0011\n1100\n1110\n0001\n\n-----Example Output-----\n2\n0\n\n-----Explanation-----\nExample case 1: Initially, $|p_1-p_2| = 4$, but if Chef reverses any one of the first four rows from \"100000\" to \"000001\", $|p_1-p_2|$ becomes $2$.\nExample case 2: Initially, $|p_1-p_2| = 0$. We cannot make that smaller by reversing any row.\n    \"\"\"\n",
        "canonical_solution": "\ndef sYCMz():\n    # cook your dish here\n    for _ in range(int(input())):\n     n=int(input())\n     l1=[]\n     l2=[]\n     \n     for i in range(n):\n      s=input()\n      a=s[ :n//2].count('1')\n      b=s[n//2: ].count('1')\n      if a>b:\n       l1.append(a-b)\n       \n      elif a<b:\n       l2.append(b-a)\n       \n     p=sum(l1)\n     q=sum(l2)\n     \n     if p==q:\n      print(0)\n      \n     elif p>q:\n      diff=p-q\n      flag=0\n      for i in range(diff//2, 0, -1):\n       a=diff-i\n       if (i in l1) or (a in l1):\n        print(abs(a-i))\n        flag=1\n        break\n       \n      if flag==0:\n       print(diff)\n       \n     else:\n      diff=q-p\n      flag=0\n      for i in range(diff//2, 0, -1):\n       a=diff-i\n       if (i in l2) or (a in l2):\n        print(abs(a-i))\n        flag=1\n        break\n       \n      if flag==0:\n       print(diff)",
        "inputs": [
            "2\n6\n100000\n100000\n100000\n100000\n010010\n001100\n4\n0011\n1100\n1110\n0001\n"
        ],
        "outputs": [
            "2\n0\n"
        ],
        "starter_code": "\ndef sYCMz():\n",
        "scope": [
            [
                "Function Body",
                2,
                49
            ],
            [
                "For Loop Body",
                4,
                49
            ],
            [
                "For Loop Body",
                9,
                17
            ],
            [
                "If Statement Body",
                13,
                17
            ],
            [
                "If Statement Body",
                16,
                17
            ],
            [
                "If Statement Body",
                22,
                49
            ],
            [
                "If Statement Body",
                25,
                49
            ],
            [
                "For Loop Body",
                28,
                33
            ],
            [
                "If Statement Body",
                30,
                33
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "For Loop Body",
                41,
                46
            ],
            [
                "If Statement Body",
                43,
                46
            ],
            [
                "If Statement Body",
                48,
                49
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Yojym():\n    \"\"\"You are given an array $a$ of $n$ integers, where $n$ is odd. You can make the following operation with it:  Choose one of the elements of the array (for example $a_i$) and increase it by $1$ (that is, replace it with $a_i + 1$). \n\nYou want to make the median of the array the largest possible using at most $k$ operations.\n\nThe median of the odd-sized array is the middle element after the array is sorted in non-decreasing order. For example, the median of the array $[1, 5, 2, 3, 5]$ is $3$.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$, $n$ is odd, $1 \\le k \\le 10^9$) — the number of elements in the array and the largest number of operations you can make.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 10^9$).\n\n\n-----Output-----\n\nPrint a single integer — the maximum possible median after the operations.\n\n\n-----Examples-----\nInput\n3 2\n1 3 5\n\nOutput\n5\nInput\n5 5\n1 2 1 1 1\n\nOutput\n3\nInput\n7 7\n4 1 2 4 3 4 4\n\nOutput\n5\n\n\n-----Note-----\n\nIn the first example, you can increase the second element twice. Than array will be $[1, 5, 5]$ and it's median is $5$.\n\nIn the second example, it is optimal to increase the second number and than increase third and fifth. This way the answer is $3$.\n\nIn the third example, you can make four operations: increase first, fourth, sixth, seventh element. This way the array will be $[5, 1, 2, 5, 3, 5, 5]$ and the median will be $5$.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport math\nfrom bisect import bisect_left\ndef Yojym():\n    input = sys.stdin.readline\n    sys.setrecursionlimit(100000)\n    def getN():\n        return int(input())\n    def getList():\n        return list(map(int, input().split()))\n    n, k = getList()\n    nums = getList()\n    nums.sort()\n    half = (n // 2) + 1\n    nums = nums[half-1:]\n    sm = sum(nums)\n    def check(arr, k, tgt):\n        for num in arr:\n            sub = max(0, (tgt - num))\n            if sub == 0:\n                return True\n            k -= sub\n            if k < 0:\n                return False\n        return True\n    mn = 0\n    mx = 3 * (10 ** 9)\n    # print(nums, sm)\n    while(mx-mn > 1):\n        md = (mx+mn) // 2\n        # print(md)\n        if check(nums, k, md):\n            mn = md\n        else:\n            mx = md\n    if not check(nums, k, md):\n        md -= 1\n    print(md)",
        "inputs": [
            "3 2\n1 3 5\n",
            "5 5\n1 2 1 1 1\n",
            "7 7\n4 1 2 4 3 4 4\n"
        ],
        "outputs": [
            "5",
            "3",
            "5"
        ],
        "starter_code": "\ndef Yojym():\n",
        "scope": [
            [
                "Function Body",
                4,
                38
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Function Body",
                9,
                10
            ],
            [
                "Function Body",
                17,
                25
            ],
            [
                "For Loop Body",
                18,
                24
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "If Statement Body",
                23,
                24
            ],
            [
                "While Loop Body",
                29,
                35
            ],
            [
                "If Statement Body",
                32,
                35
            ],
            [
                "If Statement Body",
                36,
                37
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef xIrlU():\n    \"\"\"While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array a and integer x. He should find the number of different ordered pairs of indexes (i, j) such that a_{i} ≤ a_{j} and there are exactly k integers y such that a_{i} ≤ y ≤ a_{j} and y is divisible by x.\n\nIn this problem it is meant that pair (i, j) is equal to (j, i) only if i is equal to j. For example pair (1, 2) is not the same as (2, 1).\n\n\n-----Input-----\n\nThe first line contains 3 integers n, x, k (1 ≤ n ≤ 10^5, 1 ≤ x ≤ 10^9, 0 ≤ k ≤ 10^9), where n is the size of the array a and x and k are numbers from the statement.\n\nThe second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — the elements of the array a.\n\n\n-----Output-----\n\nPrint one integer — the answer to the problem.\n\n\n-----Examples-----\nInput\n4 2 1\n1 3 5 7\n\nOutput\n3\n\nInput\n4 2 0\n5 3 1 7\n\nOutput\n4\n\nInput\n5 3 1\n3 3 3 3 3\n\nOutput\n25\n\n\n\n-----Note-----\n\nIn first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).\n\nIn second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).\n\nIn third sample every pair (i, j) is suitable, so the answer is 5 * 5 = 25.\n    \"\"\"\n",
        "canonical_solution": "import math\nimport bisect\ndef xIrlU():\n    n, x, k = list(map(int, input().split()))\n    a = sorted(list(map(int, input().split())))\n    ans = 0\n    for num in a:\n        l = math.ceil(num/x)*x + (k-1)*x\n        r = l + x - 1\n        l = num if l < num else l\n        # print(l, r, bisect.bisect_left(a, l), bisect.bisect_right(a, r), bisect.bisect_right(a, r) - bisect.bisect_left(a, l))\n        ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\n    print(ans)\n    '''\n    7 3 2\n    1 3 5 9 11 16 25\n    '''\n    '''\n    4 2 0\n    5 3 1 7\n    '''",
        "inputs": [
            "4 2 1\n1 3 5 7\n",
            "4 2 0\n5 3 1 7\n",
            "5 3 1\n3 3 3 3 3\n"
        ],
        "outputs": [
            "3\n",
            "4\n",
            "25\n"
        ],
        "starter_code": "\ndef xIrlU():\n",
        "scope": [
            [
                "Function Body",
                3,
                21
            ],
            [
                "For Loop Body",
                7,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef itoGf():\n    \"\"\"Let’s define a grid to be a set of tiles with 2 rows and 13 columns. Each tile has an English letter written in it. The letters don't have to be unique: there might be two or more tiles with the same letter written on them. Here is an example of a grid: ABCDEFGHIJKLM\n\nNOPQRSTUVWXYZ \n\nWe say that two tiles are adjacent if they share a side or a corner. In the example grid above, the tile with the letter 'A' is adjacent only to the tiles with letters 'B', 'N', and 'O'. A tile is not adjacent to itself.\n\nA sequence of tiles is called a path if each tile in the sequence is adjacent to the tile which follows it (except for the last tile in the sequence, which of course has no successor). In this example, \"ABC\" is a path, and so is \"KXWIHIJK\". \"MAB\" is not a path because 'M' is not adjacent to 'A'. A single tile can be used more than once by a path (though the tile cannot occupy two consecutive places in the path because no tile is adjacent to itself).\n\nYou’re given a string s which consists of 27 upper-case English letters. Each English letter occurs at least once in s. Find a grid that contains a path whose tiles, viewed in the order that the path visits them, form the string s. If there’s no solution, print \"Impossible\" (without the quotes).\n\n\n-----Input-----\n\nThe only line of the input contains the string s, consisting of 27 upper-case English letters. Each English letter occurs at least once in s.\n\n\n-----Output-----\n\nOutput two lines, each consisting of 13 upper-case English characters, representing the rows of the grid. If there are multiple solutions, print any of them. If there is no solution print \"Impossible\".\n\n\n-----Examples-----\nInput\nABCDEFGHIJKLMNOPQRSGTUVWXYZ\n\nOutput\nYXWVUTGHIJKLM\nZABCDEFSRQPON\n\nInput\nBUVTYZFQSNRIWOXXGJLKACPEMDH\n\nOutput\nImpossible\n    \"\"\"\n",
        "canonical_solution": "\ndef itoGf():\n    3\n    \n    s = input()\n    n = len(s)\n    \n    a, b = 0, 0\n    d = dict()\n    for i in range(len(s)):\n        if s[i] in d:\n            a = d[s[i]]\n            b = i\n        d[s[i]] = i\n    \n    if a == b - 1:\n        print(\"Impossible\")\n    else:\n        ans = [[' '] * 13 for i in range(2)]\n        if (b - a) % 2 == 1:\n            for i in range((b - a) // 2):\n                ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\n                ans[1][-i - 1] = s[a + i + (b - a) // 2 + 1]\n            x = -(b - a) // 2\n            y = 0\n            for i in range(b, n):\n                ans[y][x] = s[i]\n                if y == 0:\n                    x -= 1\n                else:\n                    x += 1\n                if x == -14:\n                    y = 1\n                    x = 0\n            for i in range(a):\n                ans[y][x] = s[i]\n                if y == 0:\n                    x -= 1\n                else:\n                    x += 1\n                if x == -14:\n                    y = 1\n                    x = 0\n            print(\"\".join(ans[0]))\n            print(\"\".join(ans[1]))\n        else:\n            for i in range((b - a) // 2):\n                ans[0][-(b - a) // 2 + i + 1] = s[a + i + 1]\n                ans[1][-i - 1] = s[a + i + (b - a) // 2]\n            x = -(b - a) // 2\n            y = 0\n            for i in range(b, n):\n                ans[y][x] = s[i]\n                if y == 0:\n                    x -= 1\n                else:\n                    x += 1\n                if x == -14:\n                    y = 1\n                    x = 0\n            for i in range(a):\n                ans[y][x] = s[i]\n                if y == 0:\n                    x -= 1\n                else:\n                    x += 1\n                if x == -14:\n                    y = 1\n                    x = 0\n            print(\"\".join(ans[0]))\n            print(\"\".join(ans[1]))\n    \n    \n    \n    ",
        "inputs": [
            "ABCDEFGHIJKLMNOPQRSGTUVWXYZ\n",
            "BUVTYZFQSNRIWOXXGJLKACPEMDH\n",
            "DYCEUXXKMGZOINVPHWQSRTABLJF\n"
        ],
        "outputs": [
            "YXWVUTGHIJKLM\nZABCDEFSRQPON\n",
            "Impossible\n",
            "Impossible\n"
        ],
        "starter_code": "\ndef itoGf():\n",
        "scope": [
            [
                "Function Body",
                2,
                71
            ],
            [
                "For Loop Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                13
            ],
            [
                "If Statement Body",
                16,
                71
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "If Statement Body",
                20,
                71
            ],
            [
                "For Loop Body",
                21,
                23
            ],
            [
                "For Loop Body",
                26,
                34
            ],
            [
                "If Statement Body",
                28,
                31
            ],
            [
                "If Statement Body",
                32,
                34
            ],
            [
                "For Loop Body",
                35,
                43
            ],
            [
                "If Statement Body",
                37,
                40
            ],
            [
                "If Statement Body",
                41,
                43
            ],
            [
                "For Loop Body",
                47,
                49
            ],
            [
                "For Loop Body",
                52,
                60
            ],
            [
                "If Statement Body",
                54,
                57
            ],
            [
                "If Statement Body",
                58,
                60
            ],
            [
                "For Loop Body",
                61,
                69
            ],
            [
                "If Statement Body",
                63,
                66
            ],
            [
                "If Statement Body",
                67,
                69
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef hUwdn():\n    \"\"\"There is a tree with N vertices numbered 1 to N.\nThe i-th edge in this tree connects Vertex a_i and Vertex b_i, and the color and length of that edge are c_i and d_i, respectively.\nHere the color of each edge is represented by an integer between 1 and N-1 (inclusive). The same integer corresponds to the same color, and different integers correspond to different colors.\nAnswer the following Q queries:\n - Query j (1 \\leq j \\leq Q): assuming that the length of every edge whose color is x_j is changed to y_j, find the distance between Vertex u_j and Vertex v_j. (The changes of the lengths of edges do not affect the subsequent queries.)\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq a_i, b_i \\leq N\n - 1 \\leq c_i \\leq N-1\n - 1 \\leq d_i \\leq 10^4\n - 1 \\leq x_j \\leq N-1\n - 1 \\leq y_j \\leq 10^4\n - 1 \\leq u_j < v_j \\leq N\n - The given graph is a tree.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN Q\na_1 b_1 c_1 d_1\n:\na_{N-1} b_{N-1} c_{N-1} d_{N-1}\nx_1 y_1 u_1 v_1\n:\nx_Q y_Q u_Q v_Q\n\n-----Output-----\nPrint Q lines. The j-th line (1 \\leq j \\leq Q) should contain the answer to Query j.\n\n-----Sample Input-----\n5 3\n1 2 1 10\n1 3 2 20\n2 4 4 30\n5 2 1 40\n1 100 1 4\n1 100 1 5\n3 1000 3 4\n\n-----Sample Output-----\n130\n200\n60\n\nThe graph in this input is as follows:\n\nHere the edges of Color 1 are shown as solid red lines, the edge of Color 2 is shown as a bold green line, and the edge of Color 4 is shown as a blue dashed line.\n - Query 1: Assuming that the length of every edge whose color is 1 is changed to 100, the distance between Vertex 1 and Vertex 4 is 100 + 30 = 130.\n - Query 2: Assuming that the length of every edge whose color is 1 is changed to 100, the distance between Vertex 1 and Vertex 5 is 100 + 100 = 200.\n - Query 3: Assuming that the length of every edge whose color is 3 is changed to 1000 (there is no such edge), the distance between Vertex 3 and Vertex 4 is 20 + 10 + 30 = 60. Note that the edges of Color 1 now have their original lengths.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef hUwdn():\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**5)\n    N, Q = map(int, input().split())\n    path = [[] for _ in range(N)]\n    for _ in range(N-1) :\n        a, b, c, d = (int(i) for i in input().split())\n        path[a-1].append((b-1, c-1, d))\n        path[b-1].append((a-1, c-1, d))\n    # doublingに必要なKを求める\n    for K in range(18) :\n        if 2 ** K >= N :\n            break\n    # dfs\n    parent = [[-1] * N for _ in range(K)]\n    rank = [-1 for _ in range(N)]\n    rank[0] = 0\n    queue = [0]\n    while queue :\n        cur = queue.pop()\n        for nex, _, _ in path[cur] :\n            if rank[nex] < 0 :\n                queue.append(nex)\n                parent[0][nex] = cur\n                rank[nex] = rank[cur] + 1\n    # doubling        \n    for i in range(1, K) :\n        for j in range(N) :\n            if parent[i-1][j] > 0 :\n                parent[i][j] = parent[i-1][parent[i-1][j]]\n    # lca\n    def lca(a, b) :\n        if rank[a] > rank[b] :\n            a, b = b, a\n        diff = rank[b] - rank[a]\n        i = 0\n        while diff > 0 :\n            if diff & 1 :\n                b = parent[i][b]\n            diff >>= 1\n            i += 1\n            \n        if a == b :\n            return a\n        for i in range(K-1, -1, -1) :\n            if parent[i][a] != parent[i][b] :\n                a = parent[i][a]\n                b = parent[i][b]\n        return parent[0][a]\n    # Queryの先読み\n    schedule = [[] for _ in range(N)]\n    for i in range(Q) : \n        x, y, u, v = map(int, input().split())\n        x, u, v = x-1, u-1, v-1\n        l = lca(u, v)\n        schedule[u].append((i, 1, x, y))\n        schedule[v].append((i, 1, x, y))\n        schedule[l].append((i, -2, x, y))\n    ret = [0] * Q\n    C = [0] * (N-1)\n    D = [0] * (N-1)\n    def dfs(cur, pre, tot) :\n        for i, t, c, d in schedule[cur] :\n            ret[i] += t * (tot - D[c] + C[c] * d)\n        \n        for nex, c, d in path[cur] :\n            if nex == pre :\n                continue\n            C[c] += 1\n            D[c] += d\n            dfs(nex, cur, tot + d)\n            C[c] -= 1\n            D[c] -= d\n    dfs(0, -1, 0)\n       \n    for i in range(Q) :\n        print(ret[i])",
        "inputs": [
            "5 3\n1 2 1 10\n1 3 2 20\n2 4 4 30\n5 2 1 40\n1 100 1 4\n1 100 1 5\n3 1000 3 4\n"
        ],
        "outputs": [
            "130\n200\n60\n"
        ],
        "starter_code": "\ndef hUwdn():\n",
        "scope": [
            [
                "Function Body",
                2,
                78
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                10
            ],
            [
                "Generator Expression",
                8,
                8
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "List Comprehension",
                16,
                16
            ],
            [
                "List Comprehension",
                17,
                17
            ],
            [
                "While Loop Body",
                20,
                26
            ],
            [
                "For Loop Body",
                22,
                26
            ],
            [
                "If Statement Body",
                23,
                26
            ],
            [
                "For Loop Body",
                28,
                31
            ],
            [
                "For Loop Body",
                29,
                31
            ],
            [
                "If Statement Body",
                30,
                31
            ],
            [
                "Function Body",
                33,
                50
            ],
            [
                "If Statement Body",
                34,
                35
            ],
            [
                "While Loop Body",
                38,
                42
            ],
            [
                "If Statement Body",
                39,
                40
            ],
            [
                "If Statement Body",
                44,
                45
            ],
            [
                "For Loop Body",
                46,
                49
            ],
            [
                "If Statement Body",
                47,
                49
            ],
            [
                "List Comprehension",
                52,
                52
            ],
            [
                "For Loop Body",
                53,
                59
            ],
            [
                "Function Body",
                63,
                74
            ],
            [
                "For Loop Body",
                64,
                65
            ],
            [
                "For Loop Body",
                67,
                74
            ],
            [
                "If Statement Body",
                68,
                69
            ],
            [
                "For Loop Body",
                77,
                78
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FLDVr():\n    \"\"\"Bees Alice and Alesya gave beekeeper Polina famous card game \"Set\" as a Christmas present. The deck consists of cards that vary in four features across three options for each kind of feature: number of shapes, shape, shading, and color. In this game, some combinations of three cards are said to make up a set. For every feature — color, number, shape, and shading — the three cards must display that feature as either all the same, or pairwise different. The picture below shows how sets look.\n\n[Image]\n\nPolina came up with a new game called \"Hyperset\". In her game, there are $n$ cards with $k$ features, each feature has three possible values: \"S\", \"E\", or \"T\". The original \"Set\" game can be viewed as \"Hyperset\" with $k = 4$.\n\nSimilarly to the original game, three cards form a set, if all features are the same for all cards or are pairwise different. The goal of the game is to compute the number of ways to choose three cards that form a set.\n\nUnfortunately, winter holidays have come to an end, and it's time for Polina to go to school. Help Polina find the number of sets among the cards lying on the table.\n\n\n-----Input-----\n\nThe first line of each test contains two integers $n$ and $k$ ($1 \\le n \\le 1500$, $1 \\le k \\le 30$) — number of cards and number of features.\n\nEach of the following $n$ lines contains a card description: a string consisting of $k$ letters \"S\", \"E\", \"T\". The $i$-th character of this string decribes the $i$-th feature of that card. All cards are distinct.\n\n\n-----Output-----\n\nOutput a single integer — the number of ways to choose three cards that form a set.\n\n\n-----Examples-----\nInput\n3 3\nSET\nETS\nTSE\n\nOutput\n1\nInput\n3 4\nSETE\nETSE\nTSES\n\nOutput\n0\nInput\n5 4\nSETT\nTEST\nEEET\nESTE\nSTES\n\nOutput\n2\n\n\n-----Note-----\n\nIn the third example test, these two triples of cards are sets:  \"SETT\", \"TEST\", \"EEET\"  \"TEST\", \"ESTE\", \"STES\"\n    \"\"\"\n",
        "canonical_solution": "\ndef FLDVr():\n    def gen(a, b):\n        gener = ''\n        for i in range(k):\n            if a[i] == b[i]:\n                gener += a[i]\n            else:\n                if 'S' not in (a[i], b[i]):\n                    gener += 'S'\n                elif 'E' not in (a[i], b[i]):\n                    gener += 'E'\n                else:\n                    gener += 'T'\n        return gener\n    \n    \n    n, k = list(map(int, input().split()))\n    cards = []\n    diff = set()\n    for i in range(n):\n        s = input()\n        cards.append(s)\n        diff.add(s)\n    ans = 0\n    was = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            aaa = gen(cards[i], cards[j])\n            if aaa in diff and max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa) not in was:\n                ans += 1\n                was.add(max(cards[i], cards[j], aaa) + min(cards[i], cards[j], aaa))\n    print(ans)\n    ",
        "inputs": [
            "3 3\nSET\nETS\nTSE\n",
            "3 4\nSETE\nETSE\nTSES\n",
            "5 4\nSETT\nTEST\nEEET\nESTE\nSTES\n"
        ],
        "outputs": [
            "1",
            "0",
            "2"
        ],
        "starter_code": "\ndef FLDVr():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "Function Body",
                3,
                15
            ],
            [
                "For Loop Body",
                5,
                14
            ],
            [
                "If Statement Body",
                6,
                14
            ],
            [
                "If Statement Body",
                9,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ],
            [
                "For Loop Body",
                21,
                24
            ],
            [
                "For Loop Body",
                27,
                32
            ],
            [
                "For Loop Body",
                28,
                32
            ],
            [
                "If Statement Body",
                30,
                32
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef imyZz():\n    \"\"\"ZS the Coder has recently found an interesting concept called the Birthday Paradox. It states that given a random set of 23 people, there is around 50% chance that some two of them share the same birthday. ZS the Coder finds this very interesting, and decides to test this with the inhabitants of Udayland.\n\nIn Udayland, there are 2^{n} days in a year. ZS the Coder wants to interview k people from Udayland, each of them has birthday in one of 2^{n} days (each day with equal probability). He is interested in the probability of at least two of them have the birthday at the same day. \n\nZS the Coder knows that the answer can be written as an irreducible fraction $\\frac{A}{B}$. He wants to find the values of A and B (he does not like to deal with floating point numbers). Can you help him?\n\n\n-----Input-----\n\nThe first and only line of the input contains two integers n and k (1 ≤ n ≤ 10^18, 2 ≤ k ≤ 10^18), meaning that there are 2^{n} days in a year and that ZS the Coder wants to interview exactly k people.\n\n\n-----Output-----\n\nIf the probability of at least two k people having the same birthday in 2^{n} days long year equals $\\frac{A}{B}$ (A ≥ 0, B ≥ 1, $\\operatorname{gcd}(A, B) = 1$), print the A and B in a single line.\n\nSince these numbers may be too large, print them modulo 10^6 + 3. Note that A and B must be coprime before their remainders modulo 10^6 + 3 are taken.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n1 8\nInput\n1 3\n\nOutput\n1 1\nInput\n4 3\n\nOutput\n23 128\n\n\n-----Note-----\n\nIn the first sample case, there are 2^3 = 8 days in Udayland. The probability that 2 people have the same birthday among 2 people is clearly $\\frac{1}{8}$, so A = 1, B = 8.\n\nIn the second sample case, there are only 2^1 = 2 days in Udayland, but there are 3 people, so it is guaranteed that two of them have the same birthday. Thus, the probability is 1 and A = B = 1.\n    \"\"\"\n",
        "canonical_solution": "\ndef imyZz():\n    m = 10** 6 + 3\n    \n    n, k = list(map(int, input().split()))\n    p = 1\n    for i in range(n):\n        p *= 2\n        if p > k:\n            break\n    if p < k:\n        print('1 1')\n        return\n    \n    gcd = tmp = k - 1\n    while tmp:\n        gcd -= tmp % 2\n        tmp //= 2\n    b = pow(2, (k - 1) * n - gcd, m)\n    a = 1\n    mem = [-1]*100\n    for i in range(1, k):\n        cnt = 0\n        while i % 2 == 0:\n            i //= 2\n            cnt += 1\n        if mem[cnt] == -1:\n            mem[cnt] = pow(2, n - cnt, m)\n        a = a * (mem[cnt] - i + m) % m\n        if a == 0:\n            break\n    print((b - a + m) % m, b)\n    ",
        "inputs": [
            "3 2\n",
            "1 3\n",
            "4 3\n"
        ],
        "outputs": [
            "1 8",
            "1 1",
            "23 128"
        ],
        "starter_code": "\ndef imyZz():\n",
        "scope": [
            [
                "Function Body",
                2,
                32
            ],
            [
                "For Loop Body",
                7,
                10
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "If Statement Body",
                11,
                13
            ],
            [
                "While Loop Body",
                16,
                18
            ],
            [
                "For Loop Body",
                22,
                31
            ],
            [
                "While Loop Body",
                24,
                26
            ],
            [
                "If Statement Body",
                27,
                28
            ],
            [
                "If Statement Body",
                30,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef VcnkR():\n    \"\"\"A penguin Rocher has $n$ sticks. He has exactly one stick with length $i$ for all $1 \\le i \\le n$.\n\nHe can connect some sticks. If he connects two sticks that have lengths $a$ and $b$, he gets one stick with length $a + b$. Two sticks, that were used in the operation disappear from his set and the new connected stick appears in his set and can be used for the next connections.\n\nHe wants to create the maximum number of sticks that have the same length. It is not necessary to make all sticks have the same length, some sticks can have the other length. How many sticks with the equal length he can create?\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nFor each test case, the only line contains a single integer $n$ ($1 \\le n \\le 10^{9}$).\n\n\n-----Output-----\n\nFor each test case, print a single integer  — the answer to the problem.\n\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n1\n1\n2\n2\n\n\n\n-----Note-----\n\nIn the third case, he can connect two sticks with lengths $1$ and $2$ and he will get one stick with length $3$. So, he will have two sticks with lengths $3$.\n\nIn the fourth case, he can connect two sticks with lengths $1$ and $3$ and he will get one stick with length $4$. After that, he will have three sticks with lengths $\\{2, 4, 4\\}$, so two sticks have the same length, and one stick has the other length.\n    \"\"\"\n",
        "canonical_solution": "\ndef VcnkR():\n    for __ in range(int(input())):\n        n = int(input())\n        print((n + 1) // 2)",
        "inputs": [
            "4\n1\n2\n3\n4\n"
        ],
        "outputs": [
            "1\n1\n2\n2\n"
        ],
        "starter_code": "\ndef VcnkR():\n",
        "scope": [
            [
                "Function Body",
                2,
                5
            ],
            [
                "For Loop Body",
                3,
                5
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef JHcOl():\n    \"\"\"VK news recommendation system daily selects interesting publications of one of $n$ disjoint categories for each user. Each publication belongs to exactly one category. For each category $i$ batch algorithm selects $a_i$ publications.\n\nThe latest A/B test suggests that users are reading recommended publications more actively if each category has a different number of publications within daily recommendations. The targeted algorithm can find a single interesting publication of $i$-th category within $t_i$ seconds. \n\nWhat is the minimum total time necessary to add publications to the result of batch algorithm execution, so all categories have a different number of publications? You can't remove publications recommended by the batch algorithm.\n\n\n-----Input-----\n\nThe first line of input consists of single integer $n$ — the number of news categories ($1 \\le n \\le 200\\,000$).\n\nThe second line of input consists of $n$ integers $a_i$ — the number of publications of $i$-th category selected by the batch algorithm ($1 \\le a_i \\le 10^9$).\n\nThe third line of input consists of $n$ integers $t_i$ — time it takes for targeted algorithm to find one new publication of category $i$ ($1 \\le t_i \\le 10^5)$.\n\n\n-----Output-----\n\nPrint one integer — the minimal required time for the targeted algorithm to get rid of categories with the same size.\n\n\n-----Examples-----\nInput\n5\n3 7 9 7 8\n5 2 5 7 5\n\nOutput\n6\n\nInput\n5\n1 2 3 4 5\n1 1 1 1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, it is possible to find three publications of the second type, which will take 6 seconds.\n\nIn the second example, all news categories contain a different number of publications.\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom heapq import heappush, heappop\ndef JHcOl():\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = {}\n    for x in a:\n    \tif x in count:\n    \t\tcount[x] = count[x] + 1\n    \telse:\n    \t\tcount[x] = 1\n    count = sorted(list(count.items()))\n    #print(count)\n    cost= list(map(int, input().split()))\n    max_cost = max(cost)\n    a = list(zip(a, cost))\n    a = sorted(a)\n    priority = list([max_cost - x for x in [x[1] for x in a]])\n    a = list(zip(priority, a))\n    i = 0\n    queue = []\n    queue_cost = 0\n    result = 0\n    #print(a)\n    for j in range(len(count)):\n    \tx, c = count[j]\n    \t#print('x = ', x)\n    \twhile i < len(a) and a[i][1][0] == x:\n    \t\tqueue_cost += a[i][1][1]\n    \t\theappush(queue, a[i])\n    \t\ti += 1\n    \t#print('queue = ', queue)\n    \ty = x\n    \twhile len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\n    \t\tpopped = heappop(queue)\n    \t\t#print(popped, queue)\n    \t\tqueue_cost -= popped[1][1]\n    \t\t#print(queue_cost)\n    \t\tresult += queue_cost\n    \t\ty += 1\n    # while len(queue) > 0:\n    # \tpopped = heappop(queue)\n    # \tqueue_cost -= popped[1][1]\n    # \tresult += queue_cost\n    print(result)",
        "inputs": [
            "5\n3 7 9 7 8\n5 2 5 7 5\n",
            "5\n1 2 3 4 5\n1 1 1 1 1\n",
            "5\n12 4 19 18 19\n15467 14873 66248 58962 90842\n"
        ],
        "outputs": [
            "6\n",
            "0\n",
            "66248\n"
        ],
        "starter_code": "\ndef JHcOl():\n",
        "scope": [
            [
                "Function Body",
                3,
                45
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "For Loop Body",
                25,
                40
            ],
            [
                "While Loop Body",
                28,
                31
            ],
            [
                "While Loop Body",
                34,
                40
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fFQsz():\n    \"\"\"Given a string consisting of only lowercase English alphabets, your task is to find the smallest palindromic substring.\nIn case there are multiple palindromic substrings of the same length present, print the lexicographically smallest substring. \nFormally, a substring is a contiguous sequence of characters within a string. So in a string \"abcdef\", \"abc\" is a substring whereas \"adf\" is not a substring.\nA palindrome is a word, phrase, or sequence that reads the same backwards as forwards, e.g. madam or mom.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains of two lines of input, two integers.\n- First, we have a single integer $N$ which signifies the length of the substring.\n- Next, we have a string of length $N$ that only has lowercase English alphabets.\n\n-----Output:-----\nFor each testcase, output in a single line the shortest palindromic substring.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $2 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n2\n2\nzy\n1\ncd\n\n-----Sample Output:-----\ny\nc\n\n-----EXPLANATION:-----\nThere are only two possibilities. \"z\" and \"y\". Since both of them have the same length. We print the lexicographically smaller substring which is y.\n    \"\"\"\n",
        "canonical_solution": "\ndef fFQsz():\n    # cook your dish here\n    T = int(input())\n    for t in range(T):\n      N = int(input())\n      s = sorted(list(str(input())))\n      print(s[0])",
        "inputs": [
            "2\n2\nzy\n1\ncd\n"
        ],
        "outputs": [
            "y\nc\n"
        ],
        "starter_code": "\ndef fFQsz():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "For Loop Body",
                5,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n            \"\"\"Given a list of non negative integers, arrange them such that they form the largest number.\n\nExample 1:\n\n\nInput: [10,2]\nOutput: \"210\"\n\nExample 2:\n\n\nInput: [3,30,34,5,9]\nOutput: \"9534330\"\n\n\nNote: The result may be very large, so you need to return a string instead of an integer.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def largestNumber(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: str\n         \"\"\"\n         nums = [str(n) for n in nums]\n         \n         nums.sort(reverse=True)\n         \n         for i in range(1, len(nums)):\n             if len(nums[i-1]) > len(nums[i]):\n                 ran = len(nums[i])\n                 j = i\n                 while j-1 >= 0 and nums[j-1][:ran] == nums[j] and nums[j-1]+nums[j]<=nums[j]+nums[j-1]:\n                     nums[j-1], nums[j] = nums[j], nums[j-1]\n                     j -= 1\n                     \n         return str(int(''.join(nums)))",
        "inputs": [
            [
                [
                    10,
                    2
                ]
            ]
        ],
        "outputs": [
            [
                "\"210\""
            ]
        ],
        "starter_code": "\nclass Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n",
        "scope": [
            [
                "Class Body",
                1,
                19
            ],
            [
                "Function Body",
                2,
                19
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                11,
                17
            ],
            [
                "If Statement Body",
                12,
                17
            ],
            [
                "While Loop Body",
                15,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef wljEs():\n    \"\"\"Vladik often travels by trains. He remembered some of his trips especially well and I would like to tell you about one of these trips:\n\nVladik is at initial train station, and now n people (including Vladik) want to get on the train. They are already lined up in some order, and for each of them the city code a_{i} is known (the code of the city in which they are going to).\n\nTrain chief selects some number of disjoint segments of the original sequence of people (covering entire sequence by segments is not necessary). People who are in the same segment will be in the same train carriage. The segments are selected in such way that if at least one person travels to the city x, then all people who are going to city x should be in the same railway carriage. This means that they can’t belong to different segments. Note, that all people who travel to the city x, either go to it and in the same railway carriage, or do not go anywhere at all.\n\nComfort of a train trip with people on segment from position l to position r is equal to XOR of all distinct codes of cities for people on the segment from position l to position r. XOR operation also known as exclusive OR.\n\nTotal comfort of a train trip is equal to sum of comfort for each segment.\n\nHelp Vladik to know maximal possible total comfort.\n\n\n-----Input-----\n\nFirst line contains single integer n (1 ≤ n ≤ 5000) — number of people.\n\nSecond line contains n space-separated integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 5000), where a_{i} denotes code of the city to which i-th person is going.\n\n\n-----Output-----\n\nThe output should contain a single integer — maximal possible total comfort.\n\n\n-----Examples-----\nInput\n6\n4 4 2 5 2 3\n\nOutput\n14\n\nInput\n9\n5 1 3 1 5 2 4 2 5\n\nOutput\n9\n\n\n\n-----Note-----\n\nIn the first test case best partition into segments is: [4, 4] [2, 5, 2] [3], answer is calculated as follows: 4 + (2 xor 5) + 3 = 4 + 7 + 3 = 14\n\nIn the second test case best partition into segments is: 5 1 [3] 1 5 [2, 4, 2] 5, answer calculated as follows: 3 + (2 xor 4) = 3 + 6 = 9.\n    \"\"\"\n",
        "canonical_solution": "\ndef wljEs():\n    def dp():\n    \tdparr = [0] * len(sections)\n    \tfor i in range(len(sections) - 1, -1, -1):\n    \t\t_, curend, curcomfort = sections[i]\n    \t\tnextsection = i + 1\n    \t\ttry:\n    \t\t\twhile sections[nextsection][0] <= curend:\n    \t\t\t\tnextsection += 1\n    \t\texcept IndexError:\n    \t\t\t# Loop til end\n    \t\t\tinc = curcomfort\n    \t\telse:\n    \t\t\tinc = curcomfort + dparr[nextsection]\n    \t\texc = 0 if i == len(sections) - 1 else dparr[i + 1]\n    \t\tdparr[i] = max(inc, exc)\n    \treturn dparr[0]\n    \n    \n    n = int(input())\n    zs = list(map(int, input().split()))\n    sections = []\n    seenstartz = set()\n    first = {z: i for i, z in reversed(list(enumerate(zs)))}\n    last = {z: i for i, z in enumerate(zs)}\n    for start, z in enumerate(zs):\n    \tif z in seenstartz:\n    \t\tcontinue\n    \tseenstartz.add(z)\n    \tend = last[z]\n    \tcomfort = 0\n    \ti = start\n    \twhile i <= end:\n    \t\tif first[zs[i]] < start:\n    \t\t\tbreak\n    \t\tif i == last[zs[i]]:\n    \t\t\tcomfort ^= zs[i]\n    \t\tend = max(end, last[zs[i]])\n    \t\ti += 1\n    \telse:\n    \t\tsections.append((start, end, comfort))\n    \n    ans = dp()\n    print(ans)\n    ",
        "inputs": [
            "6\n4 4 2 5 2 3\n",
            "9\n5 1 3 1 5 2 4 2 5\n",
            "5\n1558 4081 3591 1700 3232\n"
        ],
        "outputs": [
            "14\n",
            "9\n",
            "14162\n"
        ],
        "starter_code": "\ndef wljEs():\n",
        "scope": [
            [
                "Function Body",
                2,
                45
            ],
            [
                "Function Body",
                3,
                18
            ],
            [
                "For Loop Body",
                5,
                17
            ],
            [
                "Try Block",
                8,
                15
            ],
            [
                "Except Block",
                11,
                13
            ],
            [
                "While Loop Body",
                9,
                10
            ],
            [
                "Dict Comprehension",
                25,
                25
            ],
            [
                "Dict Comprehension",
                26,
                26
            ],
            [
                "For Loop Body",
                27,
                42
            ],
            [
                "If Statement Body",
                28,
                29
            ],
            [
                "While Loop Body",
                34,
                42
            ],
            [
                "If Statement Body",
                35,
                36
            ],
            [
                "If Statement Body",
                37,
                38
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef vxaOc():\n    \"\"\"There are $X$ people participating in a quiz competition and their IDs have been numbered from $1$ to $X$ (both inclusive). Beth needs to form a team among these $X$ participants. She has been given an integer $Y$. She can choose participants whose ID numbers are divisible by $Y$. \nNow that the team is formed, Beth wants to know the strength of her team. The strength of a team is the sum of all the last digits of the team members’ ID numbers.\nCan you help Beth in finding the strength of her team?\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. $T$ lines follow \n- The first line of each test case contains $X$ and $Y$. \n\n-----Output:-----\n- For each test case print the strength of Beth's team\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq X,Y \\leq 10^{20}$\n\n-----Sample Input:-----\n2\n10 3\n\n15 5\n\n-----Sample Output:-----\n18 \n\n10\n\n-----EXPLANATION:-----\n- Example case 1: ID numbers divisible by 3 are 3,6,9 and the sum of the last digits are 3+6+9=18\n    \"\"\"\n",
        "canonical_solution": "\ndef vxaOc():\n    for _ in range(int(input())):\r\n        x, y = map(int, input().split())\r\n        ans = 0\r\n        for i in range(y, x+1, y):\r\n            if i%y == 0:\r\n                ans += i%10\r\n        print(ans)",
        "inputs": [
            "2\n10 3\n15 5\n"
        ],
        "outputs": [
            "18\n10\n"
        ],
        "starter_code": "\ndef vxaOc():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                3,
                9
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "If Statement Body",
                7,
                8
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef rRUMY():\n    \"\"\"The zombies are gathering in their secret lair! Heidi will strike hard to destroy them once and for all. But there is a little problem... Before she can strike, she needs to know where the lair is. And the intel she has is not very good.\n\nHeidi knows that the lair can be represented as a rectangle on a lattice, with sides parallel to the axes. Each vertex of the polygon occupies an integer point on the lattice. For each cell of the lattice, Heidi can check the level of Zombie Contamination. This level is an integer between 0 and 4, equal to the number of corners of the cell that are inside or on the border of the rectangle.\n\nAs a test, Heidi wants to check that her Zombie Contamination level checker works. Given the output of the checker, Heidi wants to know whether it could have been produced by a single non-zero area rectangular-shaped lair (with axis-parallel sides). [Image]\n\n\n-----Input-----\n\nThe first line of each test case contains one integer N, the size of the lattice grid (5 ≤ N ≤ 50). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4.\n\nCells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n\n\n-----Output-----\n\nThe first line of the output should contain Yes if there exists a single non-zero area rectangular lair with corners on the grid for which checking the levels of Zombie Contamination gives the results given in the input, and No otherwise.\n\n\n-----Example-----\nInput\n6\n000000\n000000\n012100\n024200\n012100\n000000\n\nOutput\nYes\n\n\n\n-----Note-----\n\nThe lair, if it exists, has to be rectangular (that is, have corners at some grid points with coordinates (x_1, y_1), (x_1, y_2), (x_2, y_1), (x_2, y_2)), has a non-zero area and be contained inside of the grid (that is, 0 ≤ x_1 < x_2 ≤ N, 0 ≤ y_1 < y_2 ≤ N), and result in the levels of Zombie Contamination as reported in the input.\n    \"\"\"\n",
        "canonical_solution": "\ndef rRUMY():\n    N = int(input())\n    grid = []\n    x1 = 50\n    y1 = 50\n    x2 = -1\n    y2 = -1\n    for y in range(N):\n        grid.append(list(map(int, input())))\n        for x, num in enumerate(grid[-1]):\n            if num == 4:\n                x1 = min(x1, x)\n                y1 = min(y1, y)\n                x2 = max(x2, x)\n                y2 = max(y2, y)\n    \n    if x1 == 51:\n        print('No')\n    else:\n        for y in range(N):\n            for x in range(N):\n                ex = 0\n                if x1 <= x <= x2 and y1 <= y <= y2:\n                    ex = 4\n                elif (x == x1-1 or x == x2+1) and y1 <= y <= y2:\n                    ex = 2\n                elif (y == y1-1 or y == y2+1) and x1 <= x <= x2:\n                    ex = 2\n                elif (x == x1-1 or x == x2+1) and (y == y1-1 or y == y2+1):\n                    ex = 1\n                if ex != grid[y][x]:\n                    print('No')\n                    break\n            else:\n                continue\n            break\n        else:\n            print('Yes')\n    ",
        "inputs": [
            "6\n000000\n000000\n012100\n024200\n012100\n000000\n",
            "6\n000000\n012210\n024420\n012210\n000000\n000000\n",
            "6\n000100\n001210\n002420\n001210\n000000\n000000\n"
        ],
        "outputs": [
            "Yes\n",
            "Yes\n",
            "No\n"
        ],
        "starter_code": "\ndef rRUMY():\n",
        "scope": [
            [
                "Function Body",
                2,
                39
            ],
            [
                "For Loop Body",
                9,
                16
            ],
            [
                "For Loop Body",
                11,
                16
            ],
            [
                "If Statement Body",
                12,
                16
            ],
            [
                "If Statement Body",
                18,
                39
            ],
            [
                "For Loop Body",
                21,
                39
            ],
            [
                "For Loop Body",
                22,
                36
            ],
            [
                "If Statement Body",
                24,
                31
            ],
            [
                "If Statement Body",
                26,
                31
            ],
            [
                "If Statement Body",
                28,
                31
            ],
            [
                "If Statement Body",
                30,
                31
            ],
            [
                "If Statement Body",
                32,
                34
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n            \"\"\"In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \\, or blank space.  These characters divide the square into contiguous regions.\n(Note that backslash characters are escaped, so a \\ is represented as \"\\\\\".)\nReturn the number of regions.\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1:\nInput:\n[\n  \" /\",\n  \"/ \"\n]\nOutput: 2\nExplanation: The 2x2 grid is as follows:\n\n\n\nExample 2:\nInput:\n[\n  \" /\",\n  \"  \"\n]\nOutput: 1\nExplanation: The 2x2 grid is as follows:\n\n\n\nExample 3:\nInput:\n[\n  \"\\\\/\",\n  \"/\\\\\"\n]\nOutput: 4\nExplanation: (Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.)\nThe 2x2 grid is as follows:\n\n\n\nExample 4:\nInput:\n[\n  \"/\\\\\",\n  \"\\\\/\"\n]\nOutput: 5\nExplanation: (Recall that because \\ characters are escaped, \"/\\\\\" refers to /\\, and \"\\\\/\" refers to \\/.)\nThe 2x2 grid is as follows:\n\n\n\nExample 5:\nInput:\n[\n  \"//\",\n  \"/ \"\n]\nOutput: 3\nExplanation: The 2x2 grid is as follows:\n\n\n \nNote:\n\n1 <= grid.length == grid[0].length <= 30\ngrid[i][j] is either '/', '\\', or ' '.\n    \"\"\"\n",
        "canonical_solution": "from itertools import chain\nclass Solution:\n    def regionsBySlashes(self, grid):\n        grid = self.convert_grid(grid)\n        print(*(list(map(str, x)) for x in grid), sep='\\\n')\n        return len([self.destroy_island(x, y, grid) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v == 0])\n\n    @staticmethod\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for x,v in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(self, x, y, grid):\n        grid[y][x] = 1\n        for c in Solution.search(x, y, grid):\n            self.destroy_island(c[0], c[1], grid)\n\n    @staticmethod\n    def search(x, y, grid):\n        in_bounds = lambda c:0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c:in_bounds(c) and grid[c[1]][c[0]] == 0\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0: return False\n            d_x, d_y = c[0] - x, c[1] - y\n            sep = '\\\\\\\\' if ((d_x > 0 > d_y) or (d_x < 0 < d_y)) else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x-1, y), (x+1, y), (x, y-1), (x, y+1))),\n                         filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
        "inputs": [
            [
                [
                    "\" /\"",
                    "\"/ \""
                ]
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def regionsBySlashes(self, grid: List[str]) -> int:\n",
        "scope": [
            [
                "Class Body",
                2,
                32
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "Generator Expression",
                5,
                5
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "Function Body",
                10,
                15
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "For Loop Body",
                12,
                14
            ],
            [
                "Generator Expression",
                12,
                12
            ],
            [
                "Function Body",
                17,
                20
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "Function Body",
                23,
                32
            ],
            [
                "Lambda Expression",
                24,
                24
            ],
            [
                "Lambda Expression",
                25,
                25
            ],
            [
                "Function Body",
                26,
                30
            ],
            [
                "If Statement Body",
                27,
                27
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef UIZSH():\n    \"\"\"A sequence of square brackets is regular if by inserting symbols \"+\" and \"1\" into it, you can get a regular mathematical expression from it. For example, sequences \"[[]][]\", \"[]\" and \"[[][[]]]\" — are regular, at the same time \"][\", \"[[]\" and \"[[]]][\" — are irregular. \n\nDraw the given sequence using a minimalistic pseudographics in the strip of the lowest possible height — use symbols '+', '-' and '|'. For example, the sequence \"[[][]][]\" should be represented as: \n\n+-        -++- -+    \n\n|+- -++- -+||   |\n\n||   ||   |||   |\n\n|+- -++- -+||   |\n\n+-        -++- -+\n\n\n\nEach bracket should be represented with the hepl of one or more symbols '|' (the vertical part) and symbols '+' and '-' as on the example which is given above.\n\nBrackets should be drawn without spaces one by one, only dividing pairs of consecutive pairwise brackets with a single-space bar (so that the two brackets do not visually merge into one symbol). The image should have the minimum possible height. \n\nThe enclosed bracket is always smaller than the surrounding bracket, but each bracket separately strives to maximize the height of the image. So the pair of final brackets in the example above occupies the entire height of the image.\n\nStudy carefully the examples below, they adequately explain the condition of the problem. Pay attention that in this problem the answer (the image) is unique. \n\n\n-----Input-----\n\nThe first line contains an even integer n (2 ≤ n ≤ 100) — the length of the sequence of brackets.\n\nThe second line contains the sequence of brackets — these are n symbols \"[\" and \"]\". It is guaranteed that the given sequence of brackets is regular. \n\n\n-----Output-----\n\nPrint the drawn bracket sequence in the format which is given in the condition. Don't print extra (unnecessary) spaces. \n\n\n-----Examples-----\nInput\n8\n[[][]][]\n\nOutput\n+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n\nInput\n6\n[[[]]]\n\nOutput\n+-     -+\n|+-   -+|\n||+- -+||\n|||   |||\n||+- -+||\n|+-   -+|\n+-     -+\n\nInput\n6\n[[][]]\n\nOutput\n+-        -+\n|+- -++- -+|\n||   ||   ||\n|+- -++- -+|\n+-        -+\n\nInput\n2\n[]\n\nOutput\n+- -+\n|   |\n+- -+\n\nInput\n4\n[][]\n\nOutput\n+- -++- -+\n|   ||   |\n+- -++- -+\n    \"\"\"\n",
        "canonical_solution": "\ndef UIZSH():\n    n = int(input())\n    x = input()\n    d = [0] * n\n    cd = 0\n    xp = []\n    for i in range(n):\n    \tif x[i] == '[':\n    \t\td[i] = cd\n    \t\tcd = cd + 1\n    \telse:\n    \t\tcd = cd - 1\n    \t\td[i] = cd\n    for i in range(n-1):\n    \txp.append((x[i], d[i]))\n    \tif x[i] == '[' and x[i+1] == ']':\n    \t\txp.extend([(' ', d[i]), (' ', d[i]), (' ', d[i])])\n    xp.append((x[n-1], d[n-1]))\n    md = max(d)\n    h = md * 2 + 3\n    res = []\n    for i in range(h):\n    \tl = [' ' for j in xp]\n    \tres.append(l)\n    for i in range(len(xp)):\n    \tfor j in range(h):\n    \t\tif xp[i][0] == '[' and j > xp[i][1] and j < h - xp[i][1] - 1:\n    \t\t\tres[j][i] = '|'\n    \t\telif xp[i][0] == ']' and j > xp[i][1] and j < h - xp[i][1] - 1:\n    \t\t\tres[j][i] = '|'\n    \t\telif xp[i][0] == '[' and (j == xp[i][1] or j == h - xp[i][1] - 1):\n    \t\t\tres[j][i] = '+'\n    \t\t\tres[j][i+1] = '-'\n    \t\telif xp[i][0] == ']' and (j == xp[i][1] or j == h - xp[i][1] - 1):\n    \t\t\tres[j][i] = '+'\n    \t\t\tres[j][i-1] = '-'\n    \n    for i in range(h):\n    \tprint(''.join(res[i]))\n    \n    ",
        "inputs": [
            "8\n[[][]][]\n",
            "6\n[[[]]]\n",
            "6\n[[][]]\n"
        ],
        "outputs": [
            "+-        -++- -+\n|+- -++- -+||   |\n||   ||   |||   |\n|+- -++- -+||   |\n+-        -++- -+\n",
            "+-     -+\n|+-   -+|\n||+- -+||\n|||   |||\n||+- -+||\n|+-   -+|\n+-     -+\n",
            "+-        -+\n|+- -++- -+|\n||   ||   ||\n|+- -++- -+|\n+-        -+\n"
        ],
        "starter_code": "\ndef UIZSH():\n",
        "scope": [
            [
                "Function Body",
                2,
                40
            ],
            [
                "For Loop Body",
                8,
                14
            ],
            [
                "If Statement Body",
                9,
                14
            ],
            [
                "For Loop Body",
                15,
                18
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "For Loop Body",
                23,
                25
            ],
            [
                "List Comprehension",
                24,
                24
            ],
            [
                "For Loop Body",
                26,
                37
            ],
            [
                "For Loop Body",
                27,
                37
            ],
            [
                "If Statement Body",
                28,
                37
            ],
            [
                "If Statement Body",
                30,
                37
            ],
            [
                "If Statement Body",
                32,
                37
            ],
            [
                "If Statement Body",
                35,
                37
            ],
            [
                "For Loop Body",
                39,
                40
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef UZLgC():\n    \"\"\"There are $M$ levels for a building numbered from $1$ to $M$ from top to bottom, each level having $N$ parking spots numbered from $1$ to $N$ from left to right. Some spots might have a car while other may be empty, the information of which is given in form of two dimensional character array $C$ ($C_{i, j}$ denote parking spot at $j$-th position on $i$-th level).\nThere is a thief who wants to unlock all the cars. Now, he is skilled such that for the first time, he can directly reach in any parking spot in no time. Basically he can reach the first car to be stolen in 0 time.\nNow, he can move within the parking lot only in following manner, each taking 1 unit of time:\n- Move down a level. That is, if current position is $(i, j)$, then he reaches $(i+1, j)$\n- If current position is $(i, j)$ and if\n- $i$ is odd, then he can move from $(i, j)$ to $(i, j+1)$\n- $i$ is even, then he can move from $(i, j)$ to $(i, j-1)$\nNote that he wants to unlock the cars in minimum time and the car is unlocked as soon as the thief reaches that parking spot.If the parking lot is empty, then the time taken is considered to be 0.  \nFind the minimum time when all the cars would be unlocked. Note that once all cars are unlocked, the thief can escape instantly, so this time does not count.\n\n-----Input :-----\n- The first line of input contains a single integer $T$ (number of test cases).\n- First liine of each test case contains $M$ and $N$(number of levels and spots per each level)  \n- Next $M$ line contains $N$ space separated characters $C_{i, 1}, C_{i, 2} \\ldots C_{i, N}$  where $(1\\leq i\\leq M)$ and $C_{i, j}$ is either $'P'$ or $'N'$ (without quotes).\nIf the spot contains $'P'$, then a car is parked there. else, it’s not parked.\n\n-----Output :-----\nFor each test case print a single integer, the minimum time in which thief can unlock all cars.\n\n-----Constraints :-----\n- $1\\leq T \\leq100.$ \n- $1\\leq M,N \\leq300$ \n\n-----Subtasks :-----\n- \nSubtask 1 (20 points): $1\\leq M \\leq2.$ \n- \nSubtask 2 (80 points): Original Constraints\n\n-----Sample Input :-----\n2\n4 5\nN P N N P\nN N P N N\nN P N N N\nP N N N N\n3 3\nN P P\nP P P \nP P N\n\n-----Sample Output :-----\n10\n6\n\n-----Explanation:-----\nIn the first case, He will select the spot $(1,2)$ and the path he takes will be $(1,2)→(1,3)→(1,4)→(1,5)→(2,5)→(2,4)→(2,3)→(2,2)→(3,2)→(4,2)→(4,1)$\n\nSo, he takes 10 steps to unlock all the cars.\nIn the second case, He will select the spot $(1,2)$ and the path he takes will be $(1,2)→(1,3)→(2,3)→(2,2)→(2,1)→(3,1)→(3,2)$.\nSo, he takes 6 steps.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin\ndef UZLgC():\n    for _ in range(int(stdin.readline())):\n     m, n = list(map(int, stdin.readline().split()))\n     final = []\n     arr = []\n     val = 0\n     extra = 0\n     for j in range(m):\n      ans = list(map(str, stdin.readline().split()))\n      if ans.count('N') == n:\n       val += 1\n      else:\n       if val%2 == 0:\n        arr.append(ans)\n        extra += val\n       else:\n        arr.append(['N']*n)\n        arr.append(ans)\n        extra += (val-1)\n       val = 0\n     for j in range(len(arr)):\n      ans = arr[j]\n      start = -1\n      for i in range(n):\n       if ans[i] == 'P':\n        start = i\n        break\n      if start != -1:\n       for i in range(n-1, -1, -1):\n        if ans[i] == 'P':\n         end = i\n         break\n      if start != -1:\n       if len(final) == 0:\n        final.append([start, end])\n       else:\n        if j%2 == 0:\n         if final[-1][0] > start:\n          final[-1][0] = start\n         else:\n          start = final[-1][0]\n        else:\n         if final[-1][1] < end:\n          final[-1][1] = end\n         else:\n          end = final[-1][1]\n        final.append([start, end])\n      else:\n       if len(final) != 0:\n        start, end = 0, n-1\n        if j%2 == 0:\n         if final[-1][0] > start:\n          final[-1][0] = start\n         else:\n          start = final[-1][0]\n        else:\n         if final[-1][1] < end:\n          final[-1][1] = end\n         else:\n          end = final[-1][1]\n        final.append([start, end])\n     if len(final) == 0:\n      print(0)\n     else:\n      count = 0\n      for ele in final:\n       count += (ele[1]-ele[0]+1)\n      print(count-1+extra)\n          ",
        "inputs": [
            "2\n4 5\nN P N N P\nN N P N N\nN P N N N\nP N N N N\n3 3\nN P P\nP P P\nP P N\n"
        ],
        "outputs": [
            "10\n6\n"
        ],
        "starter_code": "\ndef UZLgC():\n",
        "scope": [
            [
                "Function Body",
                2,
                69
            ],
            [
                "For Loop Body",
                3,
                69
            ],
            [
                "For Loop Body",
                9,
                21
            ],
            [
                "If Statement Body",
                11,
                21
            ],
            [
                "If Statement Body",
                14,
                20
            ],
            [
                "For Loop Body",
                22,
                62
            ],
            [
                "For Loop Body",
                25,
                28
            ],
            [
                "If Statement Body",
                26,
                28
            ],
            [
                "If Statement Body",
                29,
                33
            ],
            [
                "For Loop Body",
                30,
                33
            ],
            [
                "If Statement Body",
                31,
                33
            ],
            [
                "If Statement Body",
                34,
                62
            ],
            [
                "If Statement Body",
                35,
                48
            ],
            [
                "If Statement Body",
                38,
                47
            ],
            [
                "If Statement Body",
                39,
                42
            ],
            [
                "If Statement Body",
                44,
                47
            ],
            [
                "If Statement Body",
                50,
                62
            ],
            [
                "If Statement Body",
                52,
                61
            ],
            [
                "If Statement Body",
                53,
                56
            ],
            [
                "If Statement Body",
                58,
                61
            ],
            [
                "If Statement Body",
                63,
                69
            ],
            [
                "For Loop Body",
                67,
                68
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef BgxPQ():\n    \"\"\"The only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 5000$) — the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 5000$) — the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $5000$.\n\n\n-----Output-----\n\nFor each test case print one integer — the minimum number of coins you have to spend so that everyone votes for you.\n\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\n\n\n-----Note-----\n\nIn the first test case you have to buy vote of the third voter. Then the set of people voting for you will change as follows: ${3} \\rightarrow {1, 3} \\rightarrow {1, 2, 3}$.\n\nIn the second example you don't need to buy votes. The set of people voting for you will change as follows: ${1} \\rightarrow {1, 3, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 5, 6, 7} \\rightarrow {1, 2, 3, 4, 5, 6, 7}$.\n\nIn the third test case you have to buy votes of the second and the fifth voters. Then the set of people voting for you will change as follows: ${2, 5} \\rightarrow {1, 2, 3, 4, 5} \\rightarrow {1, 2, 3, 4, 5, 6}$.\n    \"\"\"\n",
        "canonical_solution": "import heapq\ndef BgxPQ():\n    for _ in range(int(input())):\n        n = int(input())\n        voters = []\n        for i in range(n):\n            m,p = list(map(int, input().split()))\n            voters.append((m, -p))\n        voters.sort()\n        for i in range(n):\n            voters[i] = (voters[i][0], -voters[i][1])\n        ans = 0\n        costs = []\n        heapq.heapify(costs)\n        bought = 0\n        for i in range(n-1, -1, -1):\n            buysNeeded = voters[i][0] - i  - bought\n            heapq.heappush(costs, voters[i][1])\n            while buysNeeded > 0 and len(costs) > 0:\n                ans += heapq.heappop(costs)\n                bought += 1\n                buysNeeded -= 1\n        print(ans)",
        "inputs": [
            "3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n"
        ],
        "outputs": [
            "8\n0\n7\n"
        ],
        "starter_code": "\ndef BgxPQ():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "For Loop Body",
                3,
                23
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                16,
                22
            ],
            [
                "While Loop Body",
                19,
                22
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef uENqF():\n    \"\"\"Alice is the leader of the State Refactoring Party, and she is about to become the prime minister. \n\nThe elections have just taken place. There are $n$ parties, numbered from $1$ to $n$. The $i$-th party has received $a_i$ seats in the parliament.\n\nAlice's party has number $1$. In order to become the prime minister, she needs to build a coalition, consisting of her party and possibly some other parties. There are two conditions she needs to fulfil:   The total number of seats of all parties in the coalition must be a strict majority of all the seats, i.e. it must have strictly more than half of the seats. For example, if the parliament has $200$ (or $201$) seats, then the majority is $101$ or more seats.  Alice's party must have at least $2$ times more seats than any other party in the coalition. For example, to invite a party with $50$ seats, Alice's party must have at least $100$ seats. \n\nFor example, if $n=4$ and $a=[51, 25, 99, 25]$ (note that Alice'a party has $51$ seats), then the following set $[a_1=51, a_2=25, a_4=25]$ can create a coalition since both conditions will be satisfied. However, the following sets will not create a coalition:\n\n  $[a_2=25, a_3=99, a_4=25]$ since Alice's party is not there;  $[a_1=51, a_2=25]$ since coalition should have a strict majority;  $[a_1=51, a_2=25, a_3=99]$ since Alice's party should have at least $2$ times more seats than any other party in the coalition. \n\nAlice does not have to minimise the number of parties in a coalition. If she wants, she can invite as many parties as she wants (as long as the conditions are satisfied). If Alice's party has enough people to create a coalition on her own, she can invite no parties.\n\nNote that Alice can either invite a party as a whole or not at all. It is not possible to invite only some of the deputies (seats) from another party. In other words, if Alice invites a party, she invites all its deputies.\n\nFind and print any suitable coalition.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 100$) — the number of parties.\n\nThe second line contains $n$ space separated integers $a_1, a_2, \\dots, a_n$ ($1 \\leq a_i \\leq 100$) — the number of seats the $i$-th party has.\n\n\n-----Output-----\n\nIf no coalition satisfying both conditions is possible, output a single line with an integer $0$.\n\nOtherwise, suppose there are $k$ ($1 \\leq k \\leq n$) parties in the coalition (Alice does not have to minimise the number of parties in a coalition), and their indices are $c_1, c_2, \\dots, c_k$ ($1 \\leq c_i \\leq n$). Output two lines, first containing the integer $k$, and the second the space-separated indices $c_1, c_2, \\dots, c_k$. \n\nYou may print the parties in any order. Alice's party (number $1$) must be on that list. If there are multiple solutions, you may print any of them.\n\n\n-----Examples-----\nInput\n3\n100 50 50\n\nOutput\n2\n1 2\n\nInput\n3\n80 60 60\n\nOutput\n0\n\nInput\n2\n6 5\n\nOutput\n1\n1\n\nInput\n4\n51 25 99 25\n\nOutput\n3\n1 2 4\n\n\n\n-----Note-----\n\nIn the first example, Alice picks the second party. Note that she can also pick the third party or both of them. However, she cannot become prime minister without any of them, because $100$ is not a strict majority out of $200$.\n\nIn the second example, there is no way of building a majority, as both other parties are too large to become a coalition partner.\n\nIn the third example, Alice already has the majority. \n\nThe fourth example is described in the problem statement.\n    \"\"\"\n",
        "canonical_solution": "\ndef uENqF():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [0]\n    for i in range(1, n):\n    \tif a[i]*2 <= a[0]:\n    \t\tb += [i]\n    u=0\n    v=0\n    for i in range(n):\n    \tif i in b:\n    \t\tu += a[i]\n    \telse:\n    \t\tv += a[i]\n    if u > v:\n    \tprint(len(b))\n    \tfor x in b:\n    \t\tprint(x+1, end=' ')\n    else:\n    \tprint('0')",
        "inputs": [
            "3\n100 50 50\n",
            "3\n80 60 60\n",
            "2\n6 5\n"
        ],
        "outputs": [
            "3\n1 2 3\n",
            "0\n",
            "1\n1\n"
        ],
        "starter_code": "\ndef uENqF():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "If Statement Body",
                7,
                8
            ],
            [
                "For Loop Body",
                11,
                15
            ],
            [
                "If Statement Body",
                12,
                15
            ],
            [
                "If Statement Body",
                16,
                21
            ],
            [
                "For Loop Body",
                18,
                19
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef AgPlw():\n    \"\"\"The Department of economic development of IT City created a model of city development till year 2100.\n\nTo prepare report about growth perspectives it is required to get growth estimates from the model.\n\nTo get the growth estimates it is required to solve a quadratic equation. Since the Department of economic development of IT City creates realistic models only, that quadratic equation has a solution, moreover there are exactly two different real roots.\n\nThe greater of these roots corresponds to the optimistic scenario, the smaller one corresponds to the pessimistic one. Help to get these estimates, first the optimistic, then the pessimistic one.\n\n\n-----Input-----\n\nThe only line of the input contains three integers a, b, c ( - 1000 ≤ a, b, c ≤ 1000) — the coefficients of ax^2 + bx + c = 0 equation.\n\n\n-----Output-----\n\nIn the first line output the greater of the equation roots, in the second line output the smaller one. Absolute or relative error should not be greater than 10^{ - 6}.\n\n\n-----Examples-----\nInput\n1 30 200\n\nOutput\n-10.000000000000000\n-20.000000000000000\n    \"\"\"\n",
        "canonical_solution": "import math\ndef AgPlw():\n    a,b,c=map(int,input().split())\n    D = b ** 2 - 4 * a * c\n    x1 = (-b + math.sqrt(D)) / (2 * a)\n    x2 = (-b - math.sqrt(D)) / (2 * a)\n    ans1=max(x1,x2)\n    ans=min(x1,x2)\n    print(ans1)\n    print(ans)",
        "inputs": [
            "1 30 200\n",
            "1 1 -1\n",
            "-1 1 1\n"
        ],
        "outputs": [
            "-10.0\n-20.0",
            "0.6180339887498949\n-1.618033988749895",
            "1.618033988749895\n-0.6180339887498949"
        ],
        "starter_code": "\ndef AgPlw():\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FmIAX():\n    \"\"\"Vasya's house is situated in a forest, and there is a mushroom glade near it. The glade consists of two rows, each of which can be divided into n consecutive cells. For each cell Vasya knows how fast the mushrooms grow in this cell (more formally, how many grams of mushrooms grow in this cell each minute). Vasya spends exactly one minute to move to some adjacent cell. Vasya cannot leave the glade. Two cells are considered adjacent if they share a common side. When Vasya enters some cell, he instantly collects all the mushrooms growing there.\n\nVasya begins his journey in the left upper cell. Every minute Vasya must move to some adjacent cell, he cannot wait for the mushrooms to grow. He wants to visit all the cells exactly once and maximize the total weight of the collected mushrooms. Initially, all mushrooms have a weight of 0. Note that Vasya doesn't need to return to the starting cell.\n\nHelp Vasya! Calculate the maximum total weight of mushrooms he can collect.\n\n\n-----Input-----\n\nThe first line contains the number n (1 ≤ n ≤ 3·10^5) — the length of the glade.\n\nThe second line contains n numbers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^6) — the growth rate of mushrooms in the first row of the glade.\n\nThe third line contains n numbers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 10^6) is the growth rate of mushrooms in the second row of the glade.\n\n\n-----Output-----\n\nOutput one number — the maximum total weight of mushrooms that Vasya can collect by choosing the optimal route. Pay attention that Vasya must visit every cell of the glade exactly once.\n\n\n-----Examples-----\nInput\n3\n1 2 3\n6 5 4\n\nOutput\n70\n\nInput\n3\n1 1000 10000\n10 100 100000\n\nOutput\n543210\n\n\n\n-----Note-----\n\nIn the first test case, the optimal route is as follows:  [Image]  Thus, the collected weight of mushrooms will be 0·1 + 1·2 + 2·3 + 3·4 + 4·5 + 5·6 = 70.\n\nIn the second test case, the optimal route is as follows:  [Image]  Thus, the collected weight of mushrooms will be 0·1 + 1·10 + 2·100 + 3·1000 + 4·10000 + 5·100000 = 543210.\n    \"\"\"\n",
        "canonical_solution": "\ndef FmIAX():\n    n = int(input())\n    \n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    def f(l):\n        s = sum(l)\n        sume = [s for i in range(n)]\n        s3 = [0 for i in range(n)]\n        ts = 0\n        for i in range(1, n):\n            sume[i] = sume[i - 1] - l[i - 1]\n            ts += i * l[i]\n            s3[n - i - 1] = s3[n - i] + i * l[n - i - 1]\n        s2 = [ts for i in range(n)]\n        for i in range(1, n):\n            s2[i] = s2[i - 1] - (i - 1) * l[i - 1]\n        return sume, s2, s3\n    \n    a1, a2, a3 = f(a)\n    b1, b2, b3 = f(b)\n    \n    best = 0\n    curr, t = 0, 0\n    for i in range(n):\n        if i % 2 == 0:\n            pot = curr + t * a1[i] + a2[i] - i * a1[i] +\\\n                    (t + n - i) * b1[i] + b3[i]\n        else:\n            pot = curr + t * b1[i] + b2[i] - i * b1[i] +\\\n                    (t + n - i) * a1[i] + a3[i]\n        best = max(best, pot)\n        if i % 2 == 0:\n            curr += t * a[i] + (t + 1) * b[i]\n        else:\n            curr += t * b[i] + (t + 1) * a[i]\n        t += 2\n    print(max(best, curr))\n    ",
        "inputs": [
            "3\n1 2 3\n6 5 4\n",
            "3\n1 1000 10000\n10 100 100000\n",
            "6\n12 8 12 17 20 5\n17 4 8 8 8 4\n"
        ],
        "outputs": [
            "70\n",
            "543210\n",
            "705\n"
        ],
        "starter_code": "\ndef FmIAX():\n",
        "scope": [
            [
                "Function Body",
                2,
                40
            ],
            [
                "Function Body",
                8,
                20
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "List Comprehension",
                11,
                11
            ],
            [
                "For Loop Body",
                13,
                16
            ],
            [
                "List Comprehension",
                17,
                17
            ],
            [
                "For Loop Body",
                18,
                19
            ],
            [
                "For Loop Body",
                27,
                39
            ],
            [
                "If Statement Body",
                28,
                33
            ],
            [
                "If Statement Body",
                35,
                38
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n            \"\"\"Given an array nums and an integer target.\nReturn the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n \nExample 1:\nInput: nums = [1,1,1,1,1], target = 2\nOutput: 2\nExplanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\nExample 2:\nInput: nums = [-1,3,5,1,4,2,-9], target = 6\nOutput: 2\nExplanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\nExample 3:\nInput: nums = [-2,6,6,3,5,4,1,2,8], target = 10\nOutput: 3\n\nExample 4:\nInput: nums = [0,0,0], target = 0\nOutput: 3\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n0 <= target <= 10^6\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sum_set = set()\n        sum_set.add(0)\n        temp = 0\n        count = 0\n        for num in nums:\n            temp += num\n            if temp - target in sum_set:\n                count += 1\n                sum_set.clear()\n                sum_set.add(0)\n                temp = 0\n                continue\n            sum_set.add(temp)\n        return count\n\n",
        "inputs": [
            [
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ],
                2
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                16
            ],
            [
                "Function Body",
                2,
                16
            ],
            [
                "For Loop Body",
                7,
                15
            ],
            [
                "If Statement Body",
                9,
                14
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef whYkC():\n    \"\"\"As we all know caterpillars love to eat leaves. Usually, a caterpillar sits on leaf, eats as much of it as it can (or wants), then stretches out to its full length to reach a new leaf with its front end, and finally \"hops\" to it by contracting its back end to that leaf.\nWe have with us a very long, straight branch of a tree with leaves distributed uniformly along its length, and a set of caterpillars sitting on the first leaf. (Well, our leaves are big enough to accommodate upto $20$ caterpillars!). As time progresses our caterpillars eat and hop repeatedly, thereby damaging many leaves. Not all caterpillars are of the same length, so different caterpillars may eat different sets of leaves. We would like to find out the number of leaves that will be undamaged at the end of this eating spree. We assume that adjacent leaves are a unit distance apart and the length of the caterpillars is also given in the same unit.\nFor example suppose our branch had $20$ leaves (placed $1$ unit apart) and $3$ caterpillars of length $3, 2$ and $5$ units respectively. Then, first caterpillar would first eat leaf $1$, then hop to leaf $4$ and eat it and then hop to leaf $7$ and eat it and so on. So the first caterpillar would end up eating the leaves at positions $1,4,7,10,13,16$ and $19$. The second caterpillar would eat the leaves at positions $1,3,5,7,9,11,13,15,17$ and $19$. The third caterpillar would eat the leaves at positions $1,6,11$ and $16$. Thus we would have undamaged leaves at positions $2,8,12,14,18$ and $20$. So the answer to this example is $6$.\n\n-----Input:-----\nThe first line of the input contains two integers $N$ and $K$, where $N$ is the number of leaves and $K$ is the number of caterpillars. Lines $2,3,...,K+1$ describe the lengths of the $K$ caterpillars. Line $i+1$ ($1 \\leq i \\leq K$) contains a single integer representing the length of the $i^{th}$ caterpillar.\n\n-----Output:-----\nA line containing a single integer, which is the number of leaves left on the branch after all the caterpillars have finished their eating spree.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 1000000000$.\n- $1 \\leq K \\leq 20$.\n- The length of the caterpillars lie between $1$ and $N$.\n- $50 \\%$ of test cases will also satisfy $1 \\leq N \\leq 10000000$ and $1 \\leq K \\leq 16$.\n\n-----Sample Input:-----\n20 3\n3\n2\n5\n\n-----Sample Output:-----\n6\n\n-----Hint:-----\nYou may use $64$-bit integers (long long in C/C++) to avoid errors while multiplying large integers. The maximum value you can store in a $32$-bit integer is $2^{31}-1$, which is approximately $2 \\cdot 10^9$. $64$-bit integers can store values greater than $10^{18}$.\n    \"\"\"\n",
        "canonical_solution": "from math import gcd\ndef whYkC():\n    n, k = list(map(int, input().split()))\r\n    a = []\r\n    for i in range(k):\r\n        try:\r\n            a += list(map(int, input().split()))\r\n        except:\r\n            pass\r\n    ans = n\r\n    for i in range(1, 2**k):\r\n        b = bin(i)[2:].rjust(k, \"0\")\r\n        c = []\r\n        for j in range(k):\r\n            if(b[j] == '1'):\r\n                c.append(a[j])\r\n        lcm = c[0]\r\n        for j in c[1:]:\r\n            lcm *= j // gcd(lcm, j)\r\n        temp = ((n - 1) // lcm) + 1\r\n        if(b.count('1')&1):\r\n            ans -= temp\r\n        else:\r\n            ans += temp\r\n    print(ans)\r\n    \r",
        "inputs": [
            "20 3\n3\n2\n5\n"
        ],
        "outputs": [
            "6\n"
        ],
        "starter_code": "\ndef whYkC():\n",
        "scope": [
            [
                "Function Body",
                2,
                25
            ],
            [
                "For Loop Body",
                5,
                9
            ],
            [
                "Try Block",
                6,
                9
            ],
            [
                "Except Block",
                8,
                9
            ],
            [
                "For Loop Body",
                11,
                24
            ],
            [
                "For Loop Body",
                14,
                16
            ],
            [
                "If Statement Body",
                15,
                16
            ],
            [
                "For Loop Body",
                18,
                19
            ],
            [
                "If Statement Body",
                21,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef xDhLO():\n    \"\"\"Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to n (n ≥ 2) burles and the amount of tax he has to pay is calculated as the maximum divisor of n (not equal to n, of course). For example, if n = 6 then Funt has to pay 3 burles, while for n = 25 he needs to pay 5 and if n = 2 he pays only 1 burle.\n\nAs mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial n in several parts n_1 + n_2 + ... + n_{k} = n (here k is arbitrary, even k = 1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition n_{i} ≥ 2 should hold for all i from 1 to k.\n\nOstap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split n in parts.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 ≤ n ≤ 2·10^9) — the total year income of mr. Funt.\n\n\n-----Output-----\n\nPrint one integer — minimum possible number of burles that mr. Funt has to pay as a tax.\n\n\n-----Examples-----\nInput\n4\n\nOutput\n2\n\nInput\n27\n\nOutput\n3\n    \"\"\"\n",
        "canonical_solution": "\ndef xDhLO():\n    def is_izi(k):\n        i = 2\n        while (i * i <= k):\n            if (k % i == 0):\n                return 0\n            i += 1\n        return 1\n    n = int(input())\n    if (is_izi(n)):\n        print(1)\n    elif n % 2 == 0:\n        print(2)\n    elif n % 2 == 1:\n        if (is_izi(n - 2)):\n            print(2)\n        else:\n            print(3)",
        "inputs": [
            "4\n",
            "27\n",
            "3\n"
        ],
        "outputs": [
            "2\n",
            "3\n",
            "1\n"
        ],
        "starter_code": "\ndef xDhLO():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "Function Body",
                3,
                9
            ],
            [
                "While Loop Body",
                5,
                8
            ],
            [
                "If Statement Body",
                6,
                7
            ],
            [
                "If Statement Body",
                11,
                19
            ],
            [
                "If Statement Body",
                13,
                19
            ],
            [
                "If Statement Body",
                15,
                19
            ],
            [
                "If Statement Body",
                16,
                19
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef GUCFW():\n    \"\"\"Given a string s. Can you make it a palindrome by deleting exactly one character? Note that size of the string after deletion would be one less than it was before. \n\n-----Input-----\nFirst line of the input contains a single integer T denoting number of test cases.\nFor each test case, you are given a single line containing string  s. \n\n-----Output-----\nFor each test case, print YES or NO depending on the answer of the problem. \n\n-----Constraints-----\nSubtask 1, 35 points \n-  1 ≤ T ≤ 100\n- 2 ≤  size of string s ≤ 1000\n-  String s contains lowercase English alphabets (ie. from 'a' to 'z').\n\nSubtask 2, 65 points \n- 2 ≤  size of string s ≤ 10^5\n-  Sum of size of string s over all the input test cases won't exceed 10^6\n-  String s contains lowercase English alphabets (ie. from 'a' to 'z').\n\n-----Example-----\nInput:\n4\naaa\nabc\nabdbca\nabba\n\nOutput:\nYES\nNO\nYES\nYES\n\n-----Explanation-----\nExample case 1. Delete any one 'a', resulting string is \"aa\" which is a palindrome.\nExample case 2. It is not possible to delete exactly one character and having a palindrome.\nExample case 3. Delete 'c', resulting string is \"abdba\" which is a palindrome. \nExample case 4. Delete 'b', resulting string is \"aba\" which is a palindrome.\n    \"\"\"\n",
        "canonical_solution": "\ndef GUCFW():\n    for _ in range(int(input())):\n     s=str(input())\n     n=len(s)\n     k=s[::-1]\n     a,b=\"\",\"\"\n     for i in range(n):\n      if s[i]!=k[i]:\n       a+=s[i+1:]\n       b+=k[i+1:]\n       break\n      else:\n       a+=s[i]\n       b+=k[i]\n     #print(a,b)\n     if a==a[::-1] or b==b[::-1]:\n      print(\"YES\")\n     else:\n      print(\"NO\")\n    ",
        "inputs": [
            "4\naaa\nabc\nabdbca\nabba\n"
        ],
        "outputs": [
            "YES\nNO\nYES\nYES\n"
        ],
        "starter_code": "\ndef GUCFW():\n",
        "scope": [
            [
                "Function Body",
                2,
                20
            ],
            [
                "For Loop Body",
                3,
                20
            ],
            [
                "For Loop Body",
                8,
                15
            ],
            [
                "If Statement Body",
                9,
                15
            ],
            [
                "If Statement Body",
                17,
                20
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n            \"\"\"Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.\n\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\n\nThe matching should cover the entire input string (not partial).\n\nNote:\n\n\n       s could be empty and contains only lowercase letters a-z.\n       p could be empty and contains only lowercase letters a-z, and characters like ? or *.\n\n\nExample 1:\n\n\nInput:\ns = \"aa\"\np = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput:\ns = \"aa\"\np = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n\n\nExample 3:\n\n\nInput:\ns = \"cb\"\np = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n\nExample 4:\n\n\nInput:\ns = \"adceb\"\np = \"*a*b\"\nOutput: true\nExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\n\n\nExample 5:\n\n\nInput:\ns = \"acdcb\"\np = \"a*c?b\"\nOutput: false\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def isMatch(self, s, p):\n         \"\"\"\n         :type s: str\n         :type p: str\n         :rtype: bool\n         \"\"\"\n         '''维护两个下标，逐个比较，如果pj为*，则记录*的位置，将*后一个元素与si进行比较，如果不相等，则将i从记录的位置+1，重新比较'''\n         i=0\n         j=0\n         star=-1\n         lenp=len(p)\n         while i<len(s):\n             if j<lenp and (s[i]==p[j] or p[j]=='?'):\n                 i+=1\n                 j+=1\n             elif j<lenp and p[j]=='*':\n                 star=j\n                 mi=i\n                 j+=1\n             elif star!=-1:\n                 mi+=1\n                 i=mi\n                 j=star+1\n             else:\n                 return False\n         while j<lenp and p[j]=='*':\n             j+=1\n         \n         return j==lenp",
        "inputs": [
            [
                "\"aa\"",
                "\"a\""
            ]
        ],
        "outputs": [
            [
                false
            ]
        ],
        "starter_code": "\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                30
            ],
            [
                "Function Body",
                2,
                30
            ],
            [
                "While Loop Body",
                13,
                26
            ],
            [
                "If Statement Body",
                14,
                26
            ],
            [
                "If Statement Body",
                17,
                26
            ],
            [
                "If Statement Body",
                21,
                26
            ],
            [
                "While Loop Body",
                27,
                28
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef RLfVP():\n    \"\"\"You are given a string $s$ such that each its character is either 1, 2, or 3. You have to choose the shortest contiguous substring of $s$ such that it contains each of these three characters at least once.\n\nA contiguous substring of string $s$ is a string that can be obtained from $s$ by removing some (possibly zero) characters from the beginning of $s$ and some (possibly zero) characters from the end of $s$.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 20000$) — the number of test cases.\n\nEach test case consists of one line containing the string $s$ ($1 \\le |s| \\le 200000$). It is guaranteed that each character of $s$ is either 1, 2, or 3.\n\nThe sum of lengths of all strings in all test cases does not exceed $200000$.\n\n\n-----Output-----\n\nFor each test case, print one integer — the length of the shortest contiguous substring of $s$ containing all three types of characters at least once. If there is no such substring, print $0$ instead.\n\n\n-----Example-----\nInput\n7\n123\n12222133333332\n112233\n332211\n12121212\n333333\n31121\n\nOutput\n3\n3\n4\n4\n0\n0\n4\n\n\n\n-----Note-----\n\nConsider the example test:\n\nIn the first test case, the substring 123 can be used.\n\nIn the second test case, the substring 213 can be used.\n\nIn the third test case, the substring 1223 can be used.\n\nIn the fourth test case, the substring 3221 can be used.\n\nIn the fifth test case, there is no character 3 in $s$.\n\nIn the sixth test case, there is no character 1 in $s$.\n\nIn the seventh test case, the substring 3112 can be used.\n    \"\"\"\n",
        "canonical_solution": "\ndef RLfVP():\n    t=int(input())\n    no_of_chars = 256\n      \n    # Function to find smallest window  \n    # containing all characters of 'pat'  \n    def findSubString(string, pat):  \n        len1 = len(string)  \n        len2 = len(pat)  \n        if len1 < len2:  \n          \n            return 0\n        hash_pat = [0] * no_of_chars \n        hash_str = [0] * no_of_chars  \n        for i in range(0, len2):  \n            hash_pat[ord(pat[i])] += 1\n      \n        start, start_index, min_len = 0, -1, float('inf')  \n        count = 0 # count of characters  \n        for j in range(0, len1):  \n            hash_str[ord(string[j])] += 1\n            if (hash_pat[ord(string[j])] != 0 and\n                hash_str[ord(string[j])] <= \n                hash_pat[ord(string[j])]):  \n                count += 1\n            if count == len2:  \n                while (hash_str[ord(string[start])] >  \n                       hash_pat[ord(string[start])] or\n                       hash_pat[ord(string[start])] == 0):  \n                  \n                    if (hash_str[ord(string[start])] >  \n                        hash_pat[ord(string[start])]):  \n                        hash_str[ord(string[start])] -= 1\n                    start += 1\n                len_window = j - start + 1\n                if min_len > len_window:  \n                  \n                    min_len = len_window  \n                    start_index = start  \n        if start_index == -1: \n            return 0\n          \n        # Return substring starting from  \n        # start_index and length min_len  \n        return min_len\n    while t:\n        t-=1\n        a=input()\n        x=\"123\"\n        print(findSubString(a,x))\n        \n    ",
        "inputs": [
            "7\n123\n12222133333332\n112233\n332211\n12121212\n333333\n31121\n",
            "1\n11111111111111111111111123\n",
            "1\n1111111111111111111111123\n"
        ],
        "outputs": [
            "3\n3\n4\n4\n0\n0\n4\n",
            "3\n",
            "3\n"
        ],
        "starter_code": "\ndef RLfVP():\n",
        "scope": [
            [
                "Function Body",
                2,
                51
            ],
            [
                "Function Body",
                8,
                46
            ],
            [
                "If Statement Body",
                11,
                13
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "For Loop Body",
                21,
                40
            ],
            [
                "If Statement Body",
                23,
                26
            ],
            [
                "If Statement Body",
                27,
                40
            ],
            [
                "While Loop Body",
                28,
                35
            ],
            [
                "If Statement Body",
                32,
                34
            ],
            [
                "If Statement Body",
                37,
                40
            ],
            [
                "If Statement Body",
                41,
                42
            ],
            [
                "While Loop Body",
                47,
                51
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef execute(code):\n\t    \"\"\"# RoboScript #3 - Implement the RS2 Specification\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nLast time, you implemented the RS1 specification which allowed your customers to write more concise scripts for their robots by allowing them to simplify consecutive repeated commands by postfixing a non-negative integer onto the selected command.  For example, if your customers wanted to make their robot move 20 steps to the right, instead of typing `FFFFFFFFFFFFFFFFFFFF`, they could simply type `F20` which made their scripts more concise.  However, you later realised that this simplification wasn't enough.  What if a set of commands/moves were to be repeated?  The code would still appear cumbersome.  Take the program that makes the robot move in a snake-like manner, for example.  The shortened code for it was `F4LF4RF4RF4LF4LF4RF4RF4LF4LF4RF4RF4` which still contained a lot of repeated commands.\n\n## Task\n\nYour task is to allow your customers to further shorten their scripts and make them even more concise by implementing the newest specification of RoboScript (at the time of writing) that is RS2.  RS2 syntax is a superset of RS1 syntax which means that all valid RS1 code from the previous Kata of this Series should still work with your RS2 interpreter.  The only main addition in RS2 is that the customer should be able to group certain sets of commands using round brackets.  For example, the last example used in the previous Kata in this Series:\n\n\nLF5RF3RF3RF7\n \n\n... can be expressed in RS2 as:\n\n\nLF5(RF3)(RF3R)F7\n\n\nOr ... \n\n\n(L(F5(RF3))(((R(F3R)F7))))\n\n\nSimply put, your interpreter should be able to deal with nested brackets of any level.\n\nAnd of course, brackets are useless if you cannot use them to repeat a sequence of movements!  Similar to how individual commands can be postfixed by a non-negative integer to specify how many times to repeat that command, a sequence of commands grouped by round brackets `()` should also be repeated `n` times provided a non-negative integer is postfixed onto the brackets, like such:\n\n\n(SEQUENCE_OF_COMMANDS)n\n\n\n... is equivalent to ... \n\n\nSEQUENCE_OF_COMMANDS...SEQUENCE_OF_COMMANDS (repeatedly executed \"n\" times)\n\n\nFor example, this RS1 program:\n\n\nF4LF4RF4RF4LF4LF4RF4RF4LF4LF4RF4RF4\n\n\n... can be rewritten in RS2 as:\n\n\nF4L(F4RF4RF4LF4L)2F4RF4RF4\n\n\nOr:\n\n\nF4L((F4R)2(F4L)2)2(F4R)2F4\n\n\nAll 4 example tests have been included for you.  Good luck :D\n\n## Kata in this Series\n\n1. [RoboScript #1 - Implement Syntax Highlighting](https://www.codewars.com/kata/roboscript-number-1-implement-syntax-highlighting)\n2. [RoboScript #2 - Implement the RS1 Specification](https://www.codewars.com/kata/roboscript-number-2-implement-the-rs1-specification)\n3. **RoboScript #3 - Implement the RS2 Specification**\n4. [RoboScript #4 - RS3 Patterns to the Rescue](https://www.codewars.com/kata/594b898169c1d644f900002e)\n5. [RoboScript #5 - The Final Obstacle (Implement RSU)](https://www.codewars.com/kata/5a12755832b8b956a9000133)\n    \"\"\"\n",
        "canonical_solution": "from collections import deque\nimport re\n\nTOKENIZER = re.compile(r'(R+|F+|L+|\\)|\\()(\\d*)')\n\ndef parseCode(code):\n    cmds = [[]]\n    for cmd,n in TOKENIZER.findall(code):\n        s,r = cmd[0], int(n or '1') + len(cmd)-1\n        if   cmd == '(': cmds.append([])\n        elif cmd == ')': lst = cmds.pop() ; cmds[-1].extend(lst*r)\n        else:            cmds[-1] += [(s, r)]\n    return cmds[0]\n\ndef execute(code):\n\n    pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\n    seens = {pos}\n    \n    for s,r in parseCode(code):\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\n                seens.add(pos)\n        else:\n            dirs.rotate( (r%4) * (-1)**(s == 'R') )\n    \n    miX, maX = min(x for x,y in seens), max(x for x,y in seens)\n    miY, maY = min(y for x,y in seens), max(y for x,y in seens)\n    \n    return '\\r\\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \n                        for x in range(miX, maX+1) )",
        "inputs": [
            [
                "\"LF5(RF3)(RF3R)F7\""
            ],
            [
                "\"(L(F5(RF3))(((R(F3R)F7))))\""
            ],
            [
                "\"F4L(F4RF4RF4LF4L)2F4RF4RF4\""
            ]
        ],
        "outputs": [
            [
                "\"    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   \""
            ],
            [
                "\"    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   \""
            ],
            [
                "\"    *****   *****   *****\\r\\n    *   *   *   *   *   *\\r\\n    *   *   *   *   *   *\\r\\n    *   *   *   *   *   *\\r\\n*****   *****   *****   *\""
            ]
        ],
        "starter_code": "\ndef execute(code):\n",
        "scope": [
            [
                "Function Body",
                6,
                13
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "Function Body",
                15,
                32
            ],
            [
                "For Loop Body",
                20,
                26
            ],
            [
                "If Statement Body",
                21,
                26
            ],
            [
                "For Loop Body",
                22,
                24
            ],
            [
                "Generator Expression",
                23,
                23
            ],
            [
                "Generator Expression",
                28,
                28
            ],
            [
                "Generator Expression",
                28,
                28
            ],
            [
                "Generator Expression",
                29,
                29
            ],
            [
                "Generator Expression",
                29,
                29
            ],
            [
                "Generator Expression",
                31,
                32
            ],
            [
                "Generator Expression",
                31,
                31
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef imNHo():\n    \"\"\"PolandBall has such a convex polygon with n veritces that no three of its diagonals intersect at the same point. PolandBall decided to improve it and draw some red segments. \n\nHe chose a number k such that gcd(n, k) = 1. Vertices of the polygon are numbered from 1 to n in a clockwise way. PolandBall repeats the following process n times, starting from the vertex 1: \n\nAssume you've ended last operation in vertex x (consider x = 1 if it is the first operation). Draw a new segment from vertex x to k-th next vertex in clockwise direction. This is a vertex x + k or x + k - n depending on which of these is a valid index of polygon's vertex.\n\nYour task is to calculate number of polygon's sections after each drawing. A section is a clear area inside the polygon bounded with drawn diagonals or the polygon's sides.\n\n\n-----Input-----\n\nThere are only two numbers in the input: n and k (5 ≤ n ≤ 10^6, 2 ≤ k ≤ n - 2, gcd(n, k) = 1).\n\n\n-----Output-----\n\nYou should print n values separated by spaces. The i-th value should represent number of polygon's sections after drawing first i lines.\n\n\n-----Examples-----\nInput\n5 2\n\nOutput\n2 3 5 8 11 \nInput\n10 3\n\nOutput\n2 3 4 6 9 12 16 21 26 31 \n\n\n-----Note-----\n\nThe greatest common divisor (gcd) of two integers a and b is the largest positive integer that divides both a and b without a remainder.\n\nFor the first sample testcase, you should output \"2 3 5 8 11\". Pictures below correspond to situations after drawing lines. [Image] [Image] [Image] [Image] [Image] [Image]\n    \"\"\"\n",
        "canonical_solution": "\ndef imNHo():\n    n, m = [int(i) for i in input().split()]\n    if m > n//2:\n        m = n-m\n    ans = [1]\n    count = 0\n    c = 1\n    for i in range(n):\n        count+=m\n        if count>n:\n            c+=1\n            count-=n\n            ans.append(ans[-1] +c)\n            c+=1\n        else:\n            ans.append(ans[-1] +c)\n    ans = ans[1:]\n    print(*ans)",
        "inputs": [
            "5 2\n",
            "10 3\n",
            "17 5\n"
        ],
        "outputs": [
            "2 3 5 8 11 ",
            "2 3 4 6 9 12 16 21 26 31 ",
            "2 3 4 6 9 12 16 21 26 31 37 44 51 59 68 77 86 "
        ],
        "starter_code": "\ndef imNHo():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "List Comprehension",
                3,
                3
            ],
            [
                "If Statement Body",
                4,
                5
            ],
            [
                "For Loop Body",
                9,
                17
            ],
            [
                "If Statement Body",
                11,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef qelYX():\n    \"\"\"Blob is a computer science student. He recently got an internship from Chef's enterprise. Along with the programming he has various other skills too like graphic designing, digital marketing and social media management. Looking at his skills Chef has provided him different tasks A[1…N] which have their own scores. Blog wants to maximize the  value of the expression A[d]-A[c]+A[b]-A[a] such that d>c>b>a.\n\nCan you help him in this?\n\n-----Input:-----\n- The first line contain the integer N\n- The second line contains N space separated integers representing A[1], A[2] … A[N]\n\n-----Output:-----\nThe maximum score that is possible\n\n-----Constraints-----\n- $4 \\leq N \\leq 10^4$\n- $0 \\leq A[i] \\leq 10^5$\n\n-----Sample Input:-----\n6\n\n3 9 10 1 30 40\n\n-----Sample Output:-----\n46\n    \"\"\"\n",
        "canonical_solution": "\ndef qelYX():\n    def maxval(arr):\n        fn = [float('-inf')]*(len(arr)+1)\n        sn = [float('-inf')]*len(arr)\n        tn = [float('-inf')]*(len(arr)-1)\n        fon = [float('-inf')]*(len(arr)-2)\n        for i in reversed(list(range(len(arr)))):\n            fn[i] = max(fn[i + 1], arr[i])\n        for i in reversed(list(range(len(arr) - 1))):\n            sn[i] = max(sn[i + 1], fn[i + 1] - arr[i])\n    \n        for i in reversed(list(range(len(arr) - 2))):\n            tn[i] = max(tn[i + 1], sn[i + 1] + arr[i])\n    \n        for i in reversed(list(range(len(arr) - 3))):\n            fon[i] = max(fon[i + 1], tn[i + 1] - arr[i])\n        return fon[0]\n    n = int(input())\n    arr = list(map(int,input().split()))\n    print(maxval(arr))\n        \n    ",
        "inputs": [
            "6\n3 9 10 1 30 40\n"
        ],
        "outputs": [
            "46\n"
        ],
        "starter_code": "\ndef qelYX():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "Function Body",
                3,
                18
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "For Loop Body",
                10,
                11
            ],
            [
                "For Loop Body",
                13,
                14
            ],
            [
                "For Loop Body",
                16,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef ktwco():\n    \"\"\"Alice likes snow a lot! Unfortunately, this year's winter is already over, and she can't expect to have any more of it. Bob has thus bought her a gift — a large snow maker. He plans to make some amount of snow every day. On day i he will make a pile of snow of volume V_{i} and put it in her garden.\n\nEach day, every pile will shrink a little due to melting. More precisely, when the temperature on a given day is T_{i}, each pile will reduce its volume by T_{i}. If this would reduce the volume of a pile to or below zero, it disappears forever. All snow piles are independent of each other. \n\nNote that the pile made on day i already loses part of its volume on the same day. In an extreme case, this may mean that there are no piles left at the end of a particular day.\n\nYou are given the initial pile sizes and the temperature on each day. Determine the total volume of snow melted on each day. \n\n\n-----Input-----\n\nThe first line contains a single integer N (1 ≤ N ≤ 10^5) — the number of days. \n\nThe second line contains N integers V_1, V_2, ..., V_{N} (0 ≤ V_{i} ≤ 10^9), where V_{i} is the initial size of a snow pile made on the day i.\n\nThe third line contains N integers T_1, T_2, ..., T_{N} (0 ≤ T_{i} ≤ 10^9), where T_{i} is the temperature on the day i.\n\n\n-----Output-----\n\nOutput a single line with N integers, where the i-th integer represents the total volume of snow melted on day i.\n\n\n-----Examples-----\nInput\n3\n10 10 5\n5 7 2\n\nOutput\n5 12 4\n\nInput\n5\n30 25 20 15 10\n9 10 12 4 13\n\nOutput\n9 20 35 11 25\n\n\n\n-----Note-----\n\nIn the first sample, Bob first makes a snow pile of volume 10, which melts to the size of 5 on the same day. On the second day, he makes another pile of size 10. Since it is a bit warmer than the day before, the first pile disappears completely while the second pile shrinks to 3. At the end of the second day, he has only a single pile of size 3. On the third day he makes a smaller pile than usual, but as the temperature dropped too, both piles survive till the end of the day.\n    \"\"\"\n",
        "canonical_solution": "\ndef ktwco():\n    n = int(input())\n    vs = [int(x) for x in input().split()]\n    ts = [int(x) for x in input().split()]\n    \n    sumt = 0\n    for i, t in enumerate(ts):\n        vs[i]+=sumt\n        sumt+=t\n    \n    vs.sort()\n    \n    tl, tr = 0, 0\n    il, ir = 0, 0\n    for ind, t in enumerate(ts): #check\n        tl = tr\n        tr += t\n        while ir < n and vs[ir] <= tr: ir += 1\n        cur_sum = 0\n        while il < ir:\n            cur_sum += vs[il]-tl\n            il+=1\n    ##    print(ir, tl, tr,  cur_sum)\n        cur_sum += t * ((n-ir) - (n-ind-1))\n        print(cur_sum, end=\" \")\n        \n    ",
        "inputs": [
            "3\n10 10 5\n5 7 2\n",
            "5\n30 25 20 15 10\n9 10 12 4 13\n",
            "4\n0 0 0 0\n1 2 3 4\n"
        ],
        "outputs": [
            "5 12 4\n",
            "9 20 35 11 25\n",
            "0 0 0 0\n"
        ],
        "starter_code": "\ndef ktwco():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "For Loop Body",
                16,
                26
            ],
            [
                "While Loop Body",
                19,
                19
            ],
            [
                "While Loop Body",
                21,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef TOolg():\n    \"\"\"Recall the definition of the Fibonacci numbers:\n\n\nf1 := 1\n\nf2 := 2\n\nfn := fn-1 + fn-2 (n>=3)\n\nGiven two numbers a and b, calculate how many Fibonacci numbers are in the range [a,b].\n\n\n-----Input-----\n\nThe input contains several test cases. Each test case consists of two non-negative integer numbers a and b. Input is terminated by a=b=0. Otherwise, a<=b<=10^100. The numbers a and b are given with no superfluous leading zeros.\n\n-----Output-----\n\nFor each test case output on a single line the number of Fibonacci numbers fi with a<=fi<=b.\n\n-----Example-----\nInput:\n\n10 100\n1234567890 9876543210\n0 0\n\nOutput:\n\n5\n4\n    \"\"\"\n",
        "canonical_solution": "\ndef TOolg():\n    #!/usr/bin/env python\n    \n    F = [1,1]\n    def fibo():\n     for i in range(500):\n      F.append(F[-2] + F[-1])\n    \n    def main():\n     fibo()\n     #print len(str(F[-1]))\n     #print len(str(10**100))\n     while True:\n      try:\n       A, B = list(map(int, input().strip().split()[:2]))\n       if A == 0 and B == 0: break\n       print(len([x for x in F if x >= A and x <= B]))\n      except:\n       break\n    \n    main()\n    \n    ",
        "inputs": [
            "10 100\n1234567890 9876543210\n0 0\n"
        ],
        "outputs": [
            "5\n4\n"
        ],
        "starter_code": "\ndef TOolg():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "Function Body",
                6,
                8
            ],
            [
                "For Loop Body",
                7,
                8
            ],
            [
                "Function Body",
                10,
                20
            ],
            [
                "While Loop Body",
                14,
                20
            ],
            [
                "Try Block",
                15,
                20
            ],
            [
                "Except Block",
                19,
                20
            ],
            [
                "If Statement Body",
                17,
                17
            ],
            [
                "List Comprehension",
                18,
                18
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef productsum(n):\n\t    \"\"\"A product-sum number is a natural number N which can be expressed as both the product and the sum of the same set of numbers.\n\nN = a1 × a2 × ... × ak = a1 + a2 + ... + ak\n\nFor example, 6 = 1 × 2 × 3 = 1 + 2 + 3.\n\nFor a given set of size, k, we shall call the smallest N with this property a minimal product-sum number. The minimal product-sum numbers for sets of size, k = 2, 3, 4, 5, and 6 are as follows.\n```\nk=2: 4 = 2 × 2 = 2 + 2\nk=3: 6 = 1 × 2 × 3 = 1 + 2 + 3\nk=4: 8 = 1 × 1 × 2 × 4 = 1 + 1 + 2 + 4\nk=5: 8 = 1 × 1 × 2 × 2 × 2 = 1 + 1 + 2 + 2 + 2\nk=6: 12 = 1 × 1 × 1 × 1 × 2 × 6 = 1 + 1 + 1 + 1 + 2 + 6\n```\n\nHence for 2 ≤ k ≤ 6, the sum of all the minimal product-sum numbers is 4+6+8+12 = 30; note that 8 is only counted once in the sum.\n\nYour task is to write an algorithm to compute the sum of all minimal product-sum numbers where 2 ≤ k ≤ n.\n\nCourtesy of ProjectEuler.net\n    \"\"\"\n",
        "canonical_solution": "def productsum(n):\n    pass # Your code here\n    \ndef productsum(kmax):\n    def prodsum2(p, s, c, start):\n        k = p - s + c     # product - sum + number of factors\n        if k < kmax:\n            if p < n[k]: n[k] = p\n            for i in range(start, kmax//p*2 + 1):\n                prodsum2(p*i, s+i, c+1, i)\n\n    kmax += 1\n    n = [2*kmax] * kmax\n    prodsum2(1, 1, 1, 2)\n\n    return sum(set(n[2:]))",
        "inputs": [
            [
                3
            ],
            [
                6
            ],
            [
                12
            ]
        ],
        "outputs": [
            [
                10
            ],
            [
                30
            ],
            [
                61
            ]
        ],
        "starter_code": "\ndef productsum(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Function Body",
                4,
                16
            ],
            [
                "Function Body",
                5,
                10
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "If Statement Body",
                8,
                8
            ],
            [
                "For Loop Body",
                9,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef QZbCs():\n    \"\"\"International Abbreviation Olympiad takes place annually starting from 1989. Each year the competition receives an abbreviation of form IAO'y, where y stands for some number of consequent last digits of the current year. Organizers always pick an abbreviation with non-empty string y that has never been used before. Among all such valid abbreviations they choose the shortest one and announce it to be the abbreviation of this year's competition.\n\nFor example, the first three Olympiads (years 1989, 1990 and 1991, respectively) received the abbreviations IAO'9, IAO'0 and IAO'1, while the competition in 2015 received an abbreviation IAO'15, as IAO'5 has been already used in 1995.\n\nYou are given a list of abbreviations. For each of them determine the year it stands for.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 1000) — the number of abbreviations to process. \n\nThen n lines follow, each containing a single abbreviation. It's guaranteed that each abbreviation contains at most nine digits.\n\n\n-----Output-----\n\nFor each abbreviation given in the input, find the year of the corresponding Olympiad.\n\n\n-----Examples-----\nInput\n5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0\n\nOutput\n2015\n12015\n1991\n1989\n1990\n\nInput\n4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999\n\nOutput\n1989\n1999\n2999\n9999\n    \"\"\"\n",
        "canonical_solution": "\ndef QZbCs():\n    def main():\n        l = []\n        for i in range(int(input())):\n            y, n, m = 1989, 0, 1\n            for d in input()[-1:3:-1]:\n                n += (ord(d) - 48) * m\n                m *= 10\n                t = n - y % m\n                y += (m + t if t < 0 else t) + m\n            l.append(y - m)\n        print('\\n'.join(map(str, l)))\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "5\nIAO'15\nIAO'2015\nIAO'1\nIAO'9\nIAO'0\n",
            "4\nIAO'9\nIAO'99\nIAO'999\nIAO'9999\n",
            "1\nIAO'111110\n"
        ],
        "outputs": [
            "2015\n12015\n1991\n1989\n1990\n",
            "1989\n1999\n2999\n9999\n",
            "1111110\n"
        ],
        "starter_code": "\ndef QZbCs():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "Function Body",
                3,
                13
            ],
            [
                "For Loop Body",
                5,
                12
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "Function Body",
                16,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef qdKZg():\n    \"\"\"Bizon the Champion isn't just charming, he also is very smart.\n\nWhile some of us were learning the multiplication table, Bizon the Champion had fun in his own manner. Bizon the Champion painted an n × m multiplication table, where the element on the intersection of the i-th row and j-th column equals i·j (the rows and columns of the table are numbered starting from 1). Then he was asked: what number in the table is the k-th largest number? Bizon the Champion always answered correctly and immediately. Can you repeat his success?\n\nConsider the given multiplication table. If you write out all n·m numbers from the table in the non-decreasing order, then the k-th number you write out is called the k-th largest number.\n\n\n-----Input-----\n\nThe single line contains integers n, m and k (1 ≤ n, m ≤ 5·10^5; 1 ≤ k ≤ n·m).\n\n\n-----Output-----\n\nPrint the k-th largest number in a n × m multiplication table.\n\n\n-----Examples-----\nInput\n2 2 2\n\nOutput\n2\n\nInput\n2 3 4\n\nOutput\n3\n\nInput\n1 10 5\n\nOutput\n5\n\n\n\n-----Note-----\n\nA 2 × 3 multiplication table looks like this:\n\n1 2 3\n\n2 4 6\n    \"\"\"\n",
        "canonical_solution": "\ndef qdKZg():\n    def main():\n        from math import sqrt\n        m, n, k = list(map(int, input().split()))\n        if n < m:\n            n, m = m, n\n        lo, hi = 1, k + 1\n        while lo + 1 < hi:\n            mid = (lo + hi) // 2\n            t = mid - 1\n            v = min(int(sqrt(t)), m)\n            tn, tm = (t - 1) // m, t // n\n            vv = [t // i for i in range(tm + 1, v + 1)]\n            if t // n * (n + m) + sum(vv) * 2 + max(min((tn - tm), len(vv)) * m, 0) - v * v - sum(\n                    vv[:max(min(tn - tm, len(vv)), 0)]) < k:\n                lo = mid\n            else:\n                hi = mid\n        print(lo)\n    \n    \n    def __starting_point():\n        main()\n    \n    __starting_point()",
        "inputs": [
            "2 2 2\n",
            "2 3 4\n",
            "1 10 5\n"
        ],
        "outputs": [
            "2\n",
            "3\n",
            "5\n"
        ],
        "starter_code": "\ndef qdKZg():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "Function Body",
                3,
                20
            ],
            [
                "If Statement Body",
                6,
                7
            ],
            [
                "While Loop Body",
                9,
                19
            ],
            [
                "List Comprehension",
                14,
                14
            ],
            [
                "If Statement Body",
                15,
                19
            ],
            [
                "Function Body",
                23,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef zynLU():\n    \"\"\"We have N integers A_1, A_2, ..., A_N.\nThere are \\frac{N(N-1)}{2} ways to choose two of them and form a pair. If we compute the product of each of those pairs and sort the results in ascending order, what will be the K-th number in that list?\n\n-----Constraints-----\n - All values in input are integers.\n - 2 \\leq N \\leq 2 \\times 10^5\n - 1 \\leq K \\leq \\frac{N(N-1)}{2}\n - -10^9 \\leq A_i \\leq 10^9\\ (1 \\leq i \\leq N)\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\nA_1 A_2 \\dots A_N\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n4 3\n3 3 -4 -2\n\n-----Sample Output-----\n-6\n\nThere are six ways to form a pair. The products of those pairs are 9, -12, -6, -12, -6, 8.\nSorting those numbers in ascending order, we have -12, -12, -6, -6, 8, 9. The third number in this list is -6.\n    \"\"\"\n",
        "canonical_solution": "import numpy as np\ndef zynLU():\n    n,k = map(int,input().split())\n    a = np.array(list(map(int,input().split())))\n    a.sort()\n    posi = a[a>0]\n    zero = a[a==0]\n    nega = a[a<0]\n    def cnt(x):\n        c = 0\n        if x >= 0:\n            c += len(zero)*n\n        c += np.searchsorted(a, x // posi, side = 'right').sum()\n        c += (n-np.searchsorted(a, (- x - 1) // (-nega), side = 'right')).sum()\n        c -= np.count_nonzero(a * a <= x)\n        return c // 2\n    l = - 10 ** 18\n    r = 10 ** 18\n    while l + 1 < r:\n        m = (l + r) // 2\n        if cnt(m) < k:\n            l = m\n        else:\n            r = m\n    print(r)",
        "inputs": [
            "4 3\n3 3 -4 -2\n",
            "10 40\n5 4 3 2 -1 0 0 0 0 0\n",
            "30 413\n-170202098 -268409015 537203564 983211703 21608710 -443999067 -937727165 -97596546 -372334013 398994917 -972141167 798607104 -949068442 -959948616 37909651 0 886627544 -20098238 0 -948955241 0 -214720580 277222296 -18897162 834475626 0 -425610555 110117526 663621752 0\n"
        ],
        "outputs": [
            "-6\n",
            "6\n",
            "448283280358331064\n"
        ],
        "starter_code": "\ndef zynLU():\n",
        "scope": [
            [
                "Function Body",
                2,
                25
            ],
            [
                "Function Body",
                9,
                16
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "While Loop Body",
                19,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef DRZGe():\n    \"\"\"Dima loves Inna very much. He decided to write a song for her. Dima has a magic guitar with n strings and m frets. Dima makes the guitar produce sounds like that: to play a note, he needs to hold one of the strings on one of the frets and then pull the string. When Dima pulls the i-th string holding it on the j-th fret the guitar produces a note, let's denote it as a_{ij}. We know that Dima's guitar can produce k distinct notes. It is possible that some notes can be produced in multiple ways. In other words, it is possible that a_{ij} = a_{pq} at (i, j) ≠ (p, q).\n\nDima has already written a song — a sequence of s notes. In order to play the song, you need to consecutively produce the notes from the song on the guitar. You can produce each note in any available way. Dima understood that there are many ways to play a song and he wants to play it so as to make the song look as complicated as possible (try to act like Cobein).\n\nWe'll represent a way to play a song as a sequence of pairs (x_{i}, y_{i}) (1 ≤ i ≤ s), such that the x_{i}-th string on the y_{i}-th fret produces the i-th note from the song. The complexity of moving between pairs (x_1, y_1) and (x_2, y_2) equals $|x_{1} - x_{2}|$ + $|y_{1} - y_{2}|$. The complexity of a way to play a song is the maximum of complexities of moving between adjacent pairs.\n\nHelp Dima determine the maximum complexity of the way to play his song! The guy's gotta look cool!\n\n\n-----Input-----\n\nThe first line of the input contains four integers n, m, k and s (1 ≤ n, m ≤ 2000, 1 ≤ k ≤ 9, 2 ≤ s ≤ 10^5). \n\nThen follow n lines, each containing m integers a_{ij} (1 ≤ a_{ij} ≤ k). The number in the i-th row and the j-th column (a_{ij}) means a note that the guitar produces on the i-th string and the j-th fret.\n\nThe last line of the input contains s integers q_{i} (1 ≤ q_{i} ≤ k) — the sequence of notes of the song.\n\n\n-----Output-----\n\nIn a single line print a single number — the maximum possible complexity of the song.\n\n\n-----Examples-----\nInput\n4 6 5 7\n3 1 2 2 3 1\n3 2 2 2 5 5\n4 2 2 2 5 3\n3 2 2 1 4 3\n2 3 1 4 1 5 1\n\nOutput\n8\n\nInput\n4 4 9 5\n4 7 9 5\n1 2 1 7\n8 3 4 9\n5 7 7 2\n7 1 9 2 5\n\nOutput\n4\n    \"\"\"\n",
        "canonical_solution": "\ndef DRZGe():\n    def solution() : # 最大的距离来自于角落附近的点\n    \tn,m,k,s = map(int, input().split())\n    \tdis = lambda a,b : abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \tcorner = [(0,0), (0,m-1), (n-1,0), (n-1,m-1)]\n    \tvertex = [[(n,m), (n,-1), (-1,m), (-1,-1)] for _ in range(k+1)]\n    \tfor i in range(n) :\n    \t\tfor j,note in enumerate(map(int, input().split())) :\n    \t\t\tvertex[note] = [\n    \t\t\t\t(i,j) if dis((i,j), c) < dis(v, c) else v\n    \t\t\t\tfor v,c in zip(vertex[note], corner)]\n    \tmaxdis = [[-1] * (k+1) for _ in range(k+1)]\n    \tpairs = [(0,3),(3,0),(1,2),(2,1)]\n    \tfor i in range(1, k+1) :\n    \t\tfor j in range(i, k+1) :\n    \t\t\tvi,vj = vertex[i],vertex[j]\n    \t\t\tmaxdis[i][j] = max(dis(vi[a], vj[b]) for a,b in pairs)\n    \t\t\tmaxdis[j][i] = maxdis[i][j]\n    \ts = list(map(int, input().split()))\n    \tprint(max(maxdis[s[i]][s[i+1]] for i in range(len(s) - 1)))\n    solution()",
        "inputs": [
            "4 6 5 7\n3 1 2 2 3 1\n3 2 2 2 5 5\n4 2 2 2 5 3\n3 2 2 1 4 3\n2 3 1 4 1 5 1\n",
            "4 4 9 5\n4 7 9 5\n1 2 1 7\n8 3 4 9\n5 7 7 2\n7 1 9 2 5\n",
            "5 5 2 2\n2 2 2 1 2\n2 1 2 2 2\n2 2 2 2 2\n1 2 2 2 2\n2 2 2 2 1\n1 1\n"
        ],
        "outputs": [
            "8\n",
            "4\n",
            "6\n"
        ],
        "starter_code": "\ndef DRZGe():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "Function Body",
                3,
                21
            ],
            [
                "Lambda Expression",
                5,
                5
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                8,
                12
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "List Comprehension",
                10,
                12
            ],
            [
                "List Comprehension",
                13,
                13
            ],
            [
                "For Loop Body",
                15,
                19
            ],
            [
                "For Loop Body",
                16,
                19
            ],
            [
                "Generator Expression",
                18,
                18
            ],
            [
                "Generator Expression",
                21,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef hIRsk():\n    \"\"\"Joe has been hurt on the Internet. Now he is storming around the house, destroying everything in his path.\n\nJoe's house has n floors, each floor is a segment of m cells. Each cell either contains nothing (it is an empty cell), or has a brick or a concrete wall (always something one of three). It is believed that each floor is surrounded by a concrete wall on the left and on the right.\n\nNow Joe is on the n-th floor and in the first cell, counting from left to right. At each moment of time, Joe has the direction of his gaze, to the right or to the left (always one direction of the two). Initially, Joe looks to the right.\n\nJoe moves by a particular algorithm. Every second he makes one of the following actions:   If the cell directly under Joe is empty, then Joe falls down. That is, he moves to this cell, the gaze direction is preserved.  Otherwise consider the next cell in the current direction of the gaze.   If the cell is empty, then Joe moves into it, the gaze direction is preserved.  If this cell has bricks, then Joe breaks them with his forehead (the cell becomes empty), and changes the direction of his gaze to the opposite.  If this cell has a concrete wall, then Joe just changes the direction of his gaze to the opposite (concrete can withstand any number of forehead hits).  \n\nJoe calms down as soon as he reaches any cell of the first floor.\n\nThe figure below shows an example Joe's movements around the house.\n\n [Image] \n\nDetermine how many seconds Joe will need to calm down.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (2 ≤ n ≤ 100, 1 ≤ m ≤ 10^4).\n\nNext n lines contain the description of Joe's house. The i-th of these lines contains the description of the (n - i + 1)-th floor of the house — a line that consists of m characters: \".\" means an empty cell, \"+\" means bricks and \"#\" means a concrete wall.\n\nIt is guaranteed that the first cell of the n-th floor is empty.\n\n\n-----Output-----\n\nPrint a single number — the number of seconds Joe needs to reach the first floor; or else, print word \"Never\" (without the quotes), if it can never happen.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3 5\n..+.#\n#+..+\n+.#+.\n\nOutput\n14\nInput\n4 10\n...+.##+.+\n+#++..+++#\n++.#++++..\n.+##.++#.+\n\nOutput\n42\n\nInput\n2 2\n..\n++\n\nOutput\nNever\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom math import *\ndef hIRsk():\n    def minp():\n    \treturn sys.stdin.readline().strip()\n    def mint():\n    \treturn int(minp())\n    def mints():\n    \treturn map(int, minp().split())\n    n, m = mints()\n    a = list(minp())\n    x = 0\n    t = 0\n    d = 1\n    for i in range(n-1):\n    \tb = list(minp())\n    \tl = x\n    \tr = x\n    \twall = 0\n    \twhile True:\n    \t\tt += 1\n    \t\tif b[x] == '.':\n    \t\t\tbreak\n    \t\tif x + d == m or x + d < 0 or a[x+d] == '#':\n    \t\t\twall += 1\n    \t\t\td = -d\n    \t\t\tif wall == 2:\n    \t\t\t\tprint(\"Never\")\n    \t\t\t\treturn\n    \t\telif a[x+d] == '+':\n    \t\t\twall = 0\n    \t\t\ta[x+d] = '.'\n    \t\t\td = -d\n    \t\telif l <= x+d and x+d <= r:\n    \t\t\tif d == 1:\n    \t\t\t\tt += r-x-1\n    \t\t\t\tx = r\n    \t\t\telse:\n    \t\t\t\tt += x-l-1\n    \t\t\t\tx = l\n    \t\telse:\n    \t\t\tx += d\n    \t\t\tr = max(r,x)\n    \t\t\tl = min(l,x)\n    \ta, b = b, a\n    print(t)",
        "inputs": [
            "3 5\n..+.#\n#+..+\n+.#+.\n",
            "4 10\n...+.##+.+\n+#++..+++#\n++.#++++..\n.+##.++#.+\n",
            "2 2\n..\n++\n"
        ],
        "outputs": [
            "14",
            "42",
            "Never"
        ],
        "starter_code": "\ndef hIRsk():\n",
        "scope": [
            [
                "Function Body",
                3,
                46
            ],
            [
                "Function Body",
                4,
                5
            ],
            [
                "Function Body",
                6,
                7
            ],
            [
                "Function Body",
                8,
                9
            ],
            [
                "For Loop Body",
                15,
                45
            ],
            [
                "While Loop Body",
                20,
                44
            ],
            [
                "If Statement Body",
                22,
                23
            ],
            [
                "If Statement Body",
                24,
                44
            ],
            [
                "If Statement Body",
                27,
                29
            ],
            [
                "If Statement Body",
                30,
                44
            ],
            [
                "If Statement Body",
                34,
                44
            ],
            [
                "If Statement Body",
                35,
                40
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef PUzIj():\n    \"\"\"Vanya loves playing. He even has a special set of cards to play with. Each card has a single integer. The number on the card can be positive, negative and can even be equal to zero. The only limit is, the number on each card doesn't exceed x in the absolute value.\n\nNatasha doesn't like when Vanya spends a long time playing, so she hid all of his cards. Vanya became sad and started looking for the cards but he only found n of them. Vanya loves the balance, so he wants the sum of all numbers on found cards equal to zero. On the other hand, he got very tired of looking for cards. Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero?\n\nYou can assume that initially Vanya had infinitely many cards with each integer number from  - x to x.\n\n \n\n\n-----Input-----\n\nThe first line contains two integers: n (1 ≤ n ≤ 1000) — the number of found cards and x (1 ≤ x ≤ 1000) — the maximum absolute value of the number on a card. The second line contains n space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed x in their absolute value.\n\n\n-----Output-----\n\nPrint a single number — the answer to the problem.\n\n\n-----Examples-----\nInput\n3 2\n-1 1 2\n\nOutput\n1\n\nInput\n2 3\n-2 -2\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first sample, Vanya needs to find a single card with number -2.\n\nIn the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.\n    \"\"\"\n",
        "canonical_solution": "\ndef PUzIj():\n    n,x=list(map(int,input().split()))\n    \n    L=list(map(int,input().split()))\n    \n    s=sum(L)\n    \n    s=abs(s)\n    ans=0\n    while(s>0):\n        s-=x\n        ans+=1\n    print(ans)\n    ",
        "inputs": [
            "3 2\n-1 1 2\n",
            "2 3\n-2 -2\n",
            "4 4\n1 2 3 4\n"
        ],
        "outputs": [
            "1\n",
            "2\n",
            "3\n"
        ],
        "starter_code": "\ndef PUzIj():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "While Loop Body",
                11,
                13
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef fjrAV():\n    \"\"\"Takahashi has decided to work on K days of his choice from the N days starting with tomorrow.\nYou are given an integer C and a string S. Takahashi will choose his workdays as follows:\n - After working for a day, he will refrain from working on the subsequent C days.\n - If the i-th character of S is x, he will not work on Day i, where Day 1 is tomorrow, Day 2 is the day after tomorrow, and so on.\nFind all days on which Takahashi is bound to work.\n\n-----Constraints-----\n - 1 \\leq N \\leq 2 \\times 10^5\n - 1 \\leq K \\leq N\n - 0 \\leq C \\leq N\n - The length of S is N.\n - Each character of S is o or x.\n - Takahashi can choose his workdays so that the conditions in Problem Statement are satisfied.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K C\nS\n\n-----Output-----\nPrint all days on which Takahashi is bound to work in ascending order, one per line.\n\n-----Sample Input-----\n11 3 2\nooxxxoxxxoo\n\n-----Sample Output-----\n6\n\nTakahashi is going to work on 3 days out of the 11 days. After working for a day, he will refrain from working on the subsequent 2 days.\nThere are four possible choices for his workdays: Day 1,6,10, Day 1,6,11, Day 2,6,10, and Day 2,6,11.\nThus, he is bound to work on Day 6.\n    \"\"\"\n",
        "canonical_solution": "\ndef fjrAV():\n    N,K,C = map(int,input().split())\n    S = input()\n    L = []\n    R = []\n    i = 0\n    while i < N:\n        if S[i] == \"o\":\n            L.append(i)\n            i += C\n        i += 1\n    j = N-1\n    while j >= 0:\n        if S[j] == \"o\":\n            R.append(j)\n            j -= C\n        j -= 1   \n    for i in range(K):\n        if L[i] == R[K-1-i]:\n            print(L[i]+1)",
        "inputs": [
            "11 3 2\nooxxxoxxxoo\n",
            "5 2 3\nooxoo\n",
            "5 1 0\nooooo\n"
        ],
        "outputs": [
            "6\n",
            "1\n5\n",
            ""
        ],
        "starter_code": "\ndef fjrAV():\n",
        "scope": [
            [
                "Function Body",
                2,
                21
            ],
            [
                "While Loop Body",
                8,
                12
            ],
            [
                "If Statement Body",
                9,
                11
            ],
            [
                "While Loop Body",
                14,
                18
            ],
            [
                "If Statement Body",
                15,
                17
            ],
            [
                "For Loop Body",
                19,
                21
            ],
            [
                "If Statement Body",
                20,
                21
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef Vzdcm():\n    \"\"\"Chefina has two sequences $A_1, A_2, \\ldots, A_N$ and $B_1, B_2, \\ldots, B_N$. She views two sequences with length $N$ as identical if, after they are sorted in non-decreasing order, the $i$-th element of one sequence is equal to the $i$-th element of the other sequence for each $i$ ($1 \\le i \\le N$).\nTo impress Chefina, Chef wants to make the sequences identical. He may perform the following operation zero or more times: choose two integers $i$ and $j$ $(1 \\le i,j \\le N)$ and swap $A_i$ with $B_j$. The cost of each such operation is $\\mathrm{min}(A_i, B_j)$.\nYou have to find the minimum total cost with which Chef can make the two sequences identical.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n- The third line contains $N$ space-separated integers $B_1, B_2, \\ldots, B_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the minimum cost, or $-1$ if no valid sequence of operations exists.\n\n-----Constraints-----\n- $1 \\le T \\le 2,000$\n- $1 \\le N \\le 2 \\cdot 10^5$\n- $1 \\le A_i, B_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $2 \\cdot 10^6$\n\n-----Subtasks-----\nSubtask #1 (15 points):\n- $T \\le 20$\n- $N \\le 20$\nSubtask #2 (85 points): original constraints\n\n-----Example Input-----\n3\n1\n1\n2\n2\n1 2\n2 1\n2\n1 1\n2 2\n\n-----Example Output-----\n-1\n0\n1\n\n-----Explanation-----\nExample case 1: There is no way to make the sequences identical, so the answer is $-1$.\nExample case 2: The sequence are identical initially, so the answer is $0$.\nExample case 3: We can swap $A_1$ with $B_2$, which makes the two sequences identical, so the answer is $1$.\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter\ndef Vzdcm():\n    tc=int(input())\n    for k in range(tc):\n     n=int(input())\n     a=list(map(int, input().rstrip().split()))\n     b= list(map(int, input().rstrip().split()))\n     cc=sorted(a+b)\n     #print('cc = ',cc)\n     p=[]\n     q=[]\n     #print('len(cc) = ',len(cc))\n     #print('len = ',(2*n))\n     #rx=0\n     for i in range(0,(2*n),2):\n      p.append(cc[i])\n      #rx+=1\n     for i in range(1,(2*n)+1,2):\n      q.append(cc[i])\n     \n     if(p!=q):\n      print('-1')\n      continue\n     a.sort()\n     b.sort()\n     #print(p)\n     #print(q)\n     if(a==b):\n      print('0')\n      continue\n     xx = list((Counter(a) - Counter(p)).elements())\n     yy = list((Counter(b) - Counter(p)).elements())\n     #print('xx = ',xx)\n     #print('yy = ',yy)\n     iu=len(xx)\n     gb=sorted(xx+yy)\n     #print(iu)\n     uu=xx[0]\n     vv=yy[0]\n     #print('uu = ',uu)\n     #print('vv = ',vv)\n     zz=min(cc[0],uu,vv)\n     #print('zz = ',zz)\n     ans=0\n     for i in range(iu):\n      if(gb[i]<=(zz*2)):\n       ans+=gb[i]\n      else:\n       ans+=(zz*2)\n     print(ans)\n     \n    #a = [1, 1, 1, 2, 3, 3]\n    #b = [1, 1, 2, 2, 3, 4]\n    '''c = []\n    i, j = 0, 0\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n         c.append(a[i])\n         i += 1\n         j += 1\n        elif a[i] > b[j]:\n         j += 1\n        else:\n         i += 1'''\n    #print(c)",
        "inputs": [
            "3\n1\n1\n2\n2\n1 2\n2 1\n2\n1 1\n2 2\n"
        ],
        "outputs": [
            "-1\n0\n1\n"
        ],
        "starter_code": "\ndef Vzdcm():\n",
        "scope": [
            [
                "Function Body",
                2,
                64
            ],
            [
                "For Loop Body",
                4,
                50
            ],
            [
                "For Loop Body",
                15,
                16
            ],
            [
                "For Loop Body",
                18,
                19
            ],
            [
                "If Statement Body",
                21,
                23
            ],
            [
                "If Statement Body",
                28,
                30
            ],
            [
                "For Loop Body",
                45,
                49
            ],
            [
                "If Statement Body",
                46,
                49
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef uxfbU():\n    \"\"\"New Year is coming! Vasya has prepared a New Year's verse and wants to recite it in front of Santa Claus.\n\nVasya's verse contains $n$ parts. It takes $a_i$ seconds to recite the $i$-th part. Vasya can't change the order of parts in the verse: firstly he recites the part which takes $a_1$ seconds, secondly — the part which takes $a_2$ seconds, and so on. After reciting the verse, Vasya will get the number of presents equal to the number of parts he fully recited.\n\nVasya can skip at most one part of the verse while reciting it (if he skips more than one part, then Santa will definitely notice it).\n\nSanta will listen to Vasya's verse for no more than $s$ seconds. For example, if $s = 10$, $a = [100, 9, 1, 1]$, and Vasya skips the first part of verse, then he gets two presents.\n\nNote that it is possible to recite the whole verse (if there is enough time). \n\nDetermine which part Vasya needs to skip to obtain the maximum possible number of gifts. If Vasya shouldn't skip anything, print 0. If there are multiple answers, print any of them.\n\nYou have to process $t$ test cases.\n\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 100$) — the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $s$ ($1 \\le n \\le 10^5, 1 \\le s \\le 10^9$) — the number of parts in the verse and the maximum number of seconds Santa will listen to Vasya, respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — the time it takes to recite each part of the verse.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print one integer — the number of the part that Vasya needs to skip to obtain the maximum number of gifts. If Vasya shouldn't skip any parts, print 0.\n\n\n-----Example-----\nInput\n3\n7 11\n2 9 1 3 18 1 4\n4 35\n11 9 10 7\n1 8\n5\n\nOutput\n2\n1\n0\n\n\n\n-----Note-----\n\nIn the first test case if Vasya skips the second part then he gets three gifts.\n\nIn the second test case no matter what part of the verse Vasya skips.\n\nIn the third test case Vasya can recite the whole verse.\n    \"\"\"\n",
        "canonical_solution": "\ndef uxfbU():\n    t = int(input())\n    for i in range(t):\n        n, s = [int(x) for x in input().split()]\n        a= [int(x) for x in input().split()]\n        need = -1\n        if (sum(a)) <= s:\n            print(0)\n        else:\n            for i in range(n):\n                if a[i] > need:\n                    need= a[i]\n                    index = i\n                if s - a[i] < 0:\n                    print(index + 1)\n                    break\n                s -= a[i]\n            \n    ",
        "inputs": [
            "3\n7 11\n2 9 1 3 18 1 4\n4 35\n11 9 10 7\n1 8\n5\n",
            "1\n10 1000000000\n5 6 7 4 1000000000 10 74 1000000000 1000000000 1000000000\n",
            "1\n24 1\n2 1 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000 100000000\n"
        ],
        "outputs": [
            "2\n1\n0\n",
            "5\n",
            "1\n"
        ],
        "starter_code": "\ndef uxfbU():\n",
        "scope": [
            [
                "Function Body",
                2,
                18
            ],
            [
                "For Loop Body",
                4,
                18
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "If Statement Body",
                8,
                18
            ],
            [
                "For Loop Body",
                11,
                18
            ],
            [
                "If Statement Body",
                12,
                14
            ],
            [
                "If Statement Body",
                15,
                17
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef eTqNE():\n    \"\"\"Everyone knows that agents in Valorant decide, who will play as attackers, and who will play as defenders. To do that Raze and Breach decided to play $t$ matches of a digit game...\n\nIn each of $t$ matches of the digit game, a positive integer is generated. It consists of $n$ digits. The digits of this integer are numerated from $1$ to $n$ from the highest-order digit to the lowest-order digit. After this integer is announced, the match starts.\n\nAgents play in turns. Raze starts. In one turn an agent can choose any unmarked digit and mark it. Raze can choose digits on odd positions, but can not choose digits on even positions. Breach can choose digits on even positions, but can not choose digits on odd positions. The match ends, when there is only one unmarked digit left. If the single last digit is odd, then Raze wins, else Breach wins.\n\nIt can be proved, that before the end of the match (for every initial integer with $n$ digits) each agent has an ability to make a turn, i.e. there is at least one unmarked digit, that stands on a position of required parity.\n\nFor each of $t$ matches find out, which agent wins, if both of them want to win and play optimally.\n\n\n-----Input-----\n\nFirst line of input contains an integer $t$ $(1 \\le t \\le 100)$  — the number of matches.\n\nThe first line of each match description contains an integer $n$ $(1 \\le n \\le 10^3)$  — the number of digits of the generated number.\n\nThe second line of each match description contains an $n$-digit positive integer without leading zeros.\n\n\n-----Output-----\n\nFor each match print $1$, if Raze wins, and $2$, if Breach wins.\n\n\n-----Example-----\nInput\n4\n1\n2\n1\n3\n3\n102\n4\n2069\n\nOutput\n2\n1\n1\n2\n\n\n\n-----Note-----\n\nIn the first match no one can make a turn, the only digit left is $2$, it's even, so Breach wins.\n\nIn the second match the only digit left is $3$, it's odd, so Raze wins.\n\nIn the third match Raze can mark the last digit, after that Breach can only mark $0$. $1$ will be the last digit left, it's odd, so Raze wins.\n\nIn the fourth match no matter how Raze plays, Breach can mark $9$, and in the end there will be digit $0$. It's even, so Breach wins.\n    \"\"\"\n",
        "canonical_solution": "\ndef eTqNE():\n    for _ in range(int(input())):\n        n = int(input())\n        digits = list(map(int,list(input())))\n        if n % 2 == 1:\n            containsOdd = False\n            for i in range(0,n,2):\n                if digits[i] % 2 == 1:\n                    containsOdd = True\n            if containsOdd:\n                print(1)\n            else:\n                print(2)\n        else:\n            containsEven = False\n            for i in range(1,n,2):\n                if digits[i] % 2 == 0:\n                    containsEven = True\n            if containsEven:\n                print(2)\n            else:\n                print(1)\n    ",
        "inputs": [
            "4\n1\n2\n1\n3\n3\n102\n4\n2069\n",
            "2\n3\n212\n2\n11\n",
            "1\n33\n200000000000000000000000000000022\n"
        ],
        "outputs": [
            "2\n1\n1\n2\n",
            "2\n1\n",
            "2\n"
        ],
        "starter_code": "\ndef eTqNE():\n",
        "scope": [
            [
                "Function Body",
                2,
                23
            ],
            [
                "For Loop Body",
                3,
                23
            ],
            [
                "If Statement Body",
                6,
                23
            ],
            [
                "For Loop Body",
                8,
                10
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "If Statement Body",
                11,
                14
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "If Statement Body",
                20,
                23
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef FZXAb():\n    \"\"\"Due to the COVID pandemic, maintaining social distancing is of utmost importance. In this problem, you'd calculate how many days would it take to reach an apocalypse from an initial case if nobody maintains social distancing.\nThe Earth is flat (for this question) and it's dimensions are $R$ x $C$\nThe whole Earth is already divided into blocks and the virus can spread in all directions except diagonally. The virus from each newly infected person will spread in all directions in the next day, thus growing exponentially.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Next line contains $R$ and $C$ respectively separated by a space.\n- Next line contains $x$ and $y$ respectively separated by a space, denoting the indices of the initial case in the world.\n\n-----Output:-----\nFor each testcase, output in a single line an integer denoting the number of days after which everyone will be infected.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^4$\n- $2 \\leq R,C \\leq 10^7$\n- $0 \\leq x,y \\leq 10^7$\n\n-----Subtasks-----\n- 10 points : $1 \\leq T \\leq 5$ and $2 \\leq R,C \\leq 10$\n- 20 points : $2 \\leq R,C \\leq 10^5$\n- 70 points : Original constraints\n\n-----Sample Input:-----\n2\n4 5\n2 1\n3 4\n1 1\n\n-----Sample Output:-----\n5\n3\n\n-----EXPLANATION:-----\n2nd test case:\nAssuming, it's a small world of $3$ x $4$\n0 is not infected. 1 is infected.\nWorld indexing is like a 2D array:\n(0,0) (0,1) (0,2) (0,3)\n(1,0) (1,1) (1,2) (1,3)\n(2,0) (2,1) (2,2) (2,3)\nIf this is the case on Day 0:\n0 0 0 0\n0 1 0 0\n0 0 0 0\nThis will be the case on Day 1:\n0 1 0 0\n1 1 1 0\n0 1 0 0\nThis will be the case on Day 2:\n1 1 1 0\n1 1 1 1\n1 1 1 0\nThe End on Day 3:\n1 1 1 1\n1 1 1 1\n1 1 1 1\nThus, answer will be 3\n    \"\"\"\n",
        "canonical_solution": "\ndef FZXAb():\n    #AUTHOR:: AMAN VERMA\n    try:\n     for _ in range(int(input())):\n      row,column=list(map(int,input().split(\" \")))\n      x_x,y_y=list(map(int,input().split(\" \")))\n      ab=max((x_x-0),(row-x_x-1))\n      ba=max((y_y-0),(column-y_y-1))\n      print(ab+ba)\n    except:\n     pass\n    ",
        "inputs": [
            "2\n4 5\n2 1\n3 4\n1 1\n"
        ],
        "outputs": [
            "5\n3\n"
        ],
        "starter_code": "\ndef FZXAb():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "Try Block",
                4,
                12
            ],
            [
                "Except Block",
                11,
                12
            ],
            [
                "For Loop Body",
                5,
                10
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef tNgwV():\n    \"\"\"Vasiliy has a car and he wants to get from home to the post office. The distance which he needs to pass equals to d kilometers.\n\nVasiliy's car is not new — it breaks after driven every k kilometers and Vasiliy needs t seconds to repair it. After repairing his car Vasiliy can drive again (but after k kilometers it will break again, and so on). In the beginning of the trip the car is just from repair station.\n\nTo drive one kilometer on car Vasiliy spends a seconds, to walk one kilometer on foot he needs b seconds (a < b).\n\nYour task is to find minimal time after which Vasiliy will be able to reach the post office. Consider that in every moment of time Vasiliy can left his car and start to go on foot.\n\n\n-----Input-----\n\nThe first line contains 5 positive integers d, k, a, b, t (1 ≤ d ≤ 10^12; 1 ≤ k, a, b, t ≤ 10^6; a < b), where:  d — the distance from home to the post office;  k — the distance, which car is able to drive before breaking;  a — the time, which Vasiliy spends to drive 1 kilometer on his car;  b — the time, which Vasiliy spends to walk 1 kilometer on foot;  t — the time, which Vasiliy spends to repair his car. \n\n\n-----Output-----\n\nPrint the minimal time after which Vasiliy will be able to reach the post office.\n\n\n-----Examples-----\nInput\n5 2 1 4 10\n\nOutput\n14\n\nInput\n5 2 1 4 5\n\nOutput\n13\n\n\n\n-----Note-----\n\nIn the first example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds) and then to walk on foot 3 kilometers (in 12 seconds). So the answer equals to 14 seconds.\n\nIn the second example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds), then repair his car (in 5 seconds) and drive 2 kilometers more on the car (in 2 seconds). After that he needs to walk on foot 1 kilometer (in 4 seconds). So the answer equals to 13 seconds.\n    \"\"\"\n",
        "canonical_solution": "\ndef tNgwV():\n    d, k, a, b, t = list(map(int, input().split()))\n    \n    t1 = d * b\n    t2 = d * a + ((d - 1) // k) * t\n    t3 = max(0, d - k) * b + min(k, d) * a\n    dd = d % k\n    d1 = d - dd\n    t4 = d1 * a + max(0, (d1 // k - 1) * t) + dd * b\n    \n    print(min([t1, t2, t3, t4]))\n    ",
        "inputs": [
            "5 2 1 4 10\n",
            "5 2 1 4 5\n",
            "1 1 1 2 1\n"
        ],
        "outputs": [
            "14\n",
            "13\n",
            "1\n"
        ],
        "starter_code": "\ndef tNgwV():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef MAsCU():\n    \"\"\"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $x$, Egor on the floor $y$ (not on the same floor with Masha).\n\nThe house has a staircase and an elevator. If Masha uses the stairs, it takes $t_1$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $t_2$ seconds. The elevator moves with doors closed. The elevator spends $t_3$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.\n\nComing out of the apartment on her floor, Masha noticed that the elevator is now on the floor $z$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. \n\nIf the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.\n\nHelp Mary to understand whether to use the elevator or the stairs.\n\n\n-----Input-----\n\nThe only line contains six integers $x$, $y$, $z$, $t_1$, $t_2$, $t_3$ ($1 \\leq x, y, z, t_1, t_2, t_3 \\leq 1000$) — the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors.\n\nIt is guaranteed that $x \\ne y$.\n\n\n-----Output-----\n\nIf the time it will take to use the elevator is not greater than the time it will take to use the stairs, print «YES» (without quotes), otherwise print «NO> (without quotes).\n\nYou can print each letter in any case (upper or lower).\n\n\n-----Examples-----\nInput\n5 1 4 4 2 1\n\nOutput\nYES\nInput\n1 6 6 2 1 1\n\nOutput\nNO\nInput\n4 1 7 4 1 2\n\nOutput\nYES\n\n\n-----Note-----\n\nIn the first example:\n\nIf Masha goes by the stairs, the time she spends is $4 \\cdot 4 = 16$, because she has to go $4$ times between adjacent floors and each time she spends $4$ seconds. \n\nIf she chooses the elevator, she will have to wait $2$ seconds while the elevator leaves the $4$-th floor and goes to the $5$-th. After that the doors will be opening for another $1$ second. Then Masha will enter the elevator, and she will have to wait for $1$ second for the doors closing. Next, the elevator will spend $4 \\cdot 2 = 8$ seconds going from the $5$-th floor to the $1$-st, because the elevator has to pass $4$ times between adjacent floors and spends $2$ seconds each time. And finally, it will take another $1$ second before the doors are open and Masha can come out. \n\nThus, all the way by elevator will take $2 + 1 + 1 + 8 + 1 = 13$ seconds, which is less than $16$ seconds, so Masha has to choose the elevator.\n\nIn the second example, it is more profitable for Masha to use the stairs, because it will take $13$ seconds to use the elevator, that is more than the $10$ seconds it will takes to go by foot.\n\nIn the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $12$ seconds. That means Masha will take the elevator.\n    \"\"\"\n",
        "canonical_solution": "\ndef MAsCU():\n    x, y, z, t1, t2, t3 = map(int, input().split())\n    ladder = abs(x - y) * t1\n    elevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2\n    if elevator > ladder:\n    \tprint(\"NO\")\n    else:\n    \tprint(\"YES\")",
        "inputs": [
            "5 1 4 4 2 1\n",
            "1 6 6 2 1 1\n",
            "4 1 7 4 1 2\n"
        ],
        "outputs": [
            "YES",
            "NO",
            "YES"
        ],
        "starter_code": "\ndef MAsCU():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "If Statement Body",
                6,
                9
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n            \"\"\"Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\n\nNote:\n\nThe length of num is less than 10002 and will be ≥ k.\nThe given num does not contain any leading zero.\n\n\n\n\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n\n\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n\n\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def removeKdigits(self, num, k):\n         \"\"\"\n         :type num: str\n         :type k: int\n         :rtype: str\n         \"\"\"\n         out=[]\n         for digit in num:\n             while k and out and out[-1] > digit:\n                 out.pop()\n                 k-=1\n             out.append(digit)\n         return ''.join(out[:-k or None]).lstrip('0') or \"0\"",
        "inputs": [
            [
                "\"1432219\"",
                3
            ]
        ],
        "outputs": [
            [
                "\"1219\""
            ]
        ],
        "starter_code": "\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n",
        "scope": [
            [
                "Class Body",
                1,
                14
            ],
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "While Loop Body",
                10,
                12
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\nclass Solution:\n    def longestArithSeqLength(self, A: List[int]) -> int:\n            \"\"\"Given an array A of integers, return the length of the longest arithmetic subsequence in A.\nRecall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).\n \nExample 1:\nInput: A = [3,6,9,12]\nOutput: 4\nExplanation: \nThe whole array is an arithmetic sequence with steps of length = 3.\n\nExample 2:\nInput: A = [9,4,7,2,10]\nOutput: 3\nExplanation: \nThe longest arithmetic subsequence is [4,7,10].\n\nExample 3:\nInput: A = [20,1,15,3,10,5,8]\nOutput: 4\nExplanation: \nThe longest arithmetic subsequence is [20,15,10,5].\n\n \nConstraints:\n\n2 <= A.length <= 1000\n0 <= A[i] <= 500\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter\nclass Solution:\n    def longestArithSeqLength(self, A: List[int]) -> int:\n        c = dict(Counter(A).most_common())\n        # print(c)\n        m1 = max(c.values())\n        # A = list(set(A))\n        # A.sort()\n        index = {}\n        # for i in range(len(A)):\n            # index[A[i]]=i\n        dp = [[2] * len(A) for i in A]\n        m = 2\n        for i in range(len(A)):\n            # print(\\\"I=\\\", i)\n            # index[A[i+1]]=(i+1)\n            for j in range(i+1, len(A)):\n                # index[A[j]]=(j)\n                a = A[i]\n                \n                c = A[j]\n                b = 2 * a - c\n                # print(b,a,c)\n                if b in index :\n                    # print(\\\"B {} in index \\\".format(b))\n                    # print(b,a,c,i,j)\n                    dp[i][j] = dp[index[b]][i] + 1\n            index[A[i]]=i\n            m = max(m, max(dp[i]))\n        # # print(A)\n        # for i,d in enumerate(dp):\n        #     print(A[i],d)\n        return max(m,m1)",
        "inputs": [
            [
                [
                    3,
                    6,
                    9,
                    12
                ]
            ]
        ],
        "outputs": [
            [
                4
            ]
        ],
        "starter_code": "\nclass Solution:\n    def longestArithSeqLength(self, A: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                2,
                33
            ],
            [
                "Function Body",
                3,
                33
            ],
            [
                "List Comprehension",
                12,
                12
            ],
            [
                "For Loop Body",
                14,
                29
            ],
            [
                "For Loop Body",
                17,
                27
            ],
            [
                "If Statement Body",
                24,
                27
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef PjWVC():\n    \"\"\"The Resistance is trying to take control over as many planets of a particular solar system as possible. Princess Heidi is in charge of the fleet, and she must send ships to some planets in order to maximize the number of controlled planets.\n\nThe Galaxy contains N planets, connected by bidirectional hyperspace tunnels in such a way that there is a unique path between every pair of the planets.\n\nA planet is controlled by the Resistance if there is a Resistance ship in its orbit, or if the planet lies on the shortest path between some two planets that have Resistance ships in their orbits.\n\nHeidi has not yet made up her mind as to how many ships to use. Therefore, she is asking you to compute, for every K = 1, 2, 3, ..., N, the maximum number of planets that can be controlled with a fleet consisting of K ships.\n\n\n-----Input-----\n\nThe first line of the input contains an integer N (1 ≤ N ≤ 10^5) – the number of planets in the galaxy.\n\nThe next N - 1 lines describe the hyperspace tunnels between the planets. Each of the N - 1 lines contains two space-separated integers u and v (1 ≤ u, v ≤ N) indicating that there is a bidirectional hyperspace tunnel between the planets u and v. It is guaranteed that every two planets are connected by a path of tunnels, and that each tunnel connects a different pair of planets.\n\n\n-----Output-----\n\nOn a single line, print N space-separated integers. The K-th number should correspond to the maximum number of planets that can be controlled by the Resistance using a fleet of K ships.\n\n\n-----Examples-----\nInput\n3\n1 2\n2 3\n\nOutput\n1 3 3 \nInput\n4\n1 2\n3 2\n4 2\n\nOutput\n1 3 4 4 \n\n\n-----Note-----\n\nConsider the first example. If K = 1, then Heidi can only send one ship to some planet and control it. However, for K ≥ 2, sending ships to planets 1 and 3 will allow the Resistance to control all planets.\n    \"\"\"\n",
        "canonical_solution": "from sys import stdin\nfrom collections import defaultdict\nimport heapq\ndef PjWVC():\n    n = int(stdin.readline())\n    a = [[] for _ in range(n)]\n    for _ in range(n-1):\n        e = stdin.readline().split(' ')\n        u, v = int(e[0]), int(e[1])\n        a[u-1].append(v-1)\n        a[v-1].append(u-1)\n    leaves = [i for i in range(n) if len(a[i]) == 1]\n    def dfs_from(root):\n        depth = defaultdict(int)\n        child = {}\n        parent = defaultdict(lambda: -1)\n        stack = [root]\n        visited = [False for _ in range(n)]\n        while len(stack) > 0:\n            crt = stack[-1]\n            if visited[crt]:\n                stack.pop(-1)\n                if len(a[crt]) > 1:  # not a leaf\n                    child[crt], depth[crt] = max([(c, depth[c]+1) for c in a[crt]\n                                                  if c != parent[crt]],\n                                                 key=lambda x: x[1])\n                else:\n                    child[crt] = -1\n                    depth[crt] = 0\n                continue\n            visited[crt] = True\n            for next in a[crt]:\n                if next != parent[crt]:\n                    stack.append(next)\n                    parent[next] = crt\n        return depth, child\n    first_choice = leaves[0]\n    d1, child1 = dfs_from(first_choice)\n    root = max([(a[leaf][0], d1[a[leaf][0]]) for leaf in leaves],\n               key=lambda leaf_depth: leaf_depth[1])[0]\n    while child1[root] != -1:\n        root = child1[root]\n    depth, child = dfs_from(root)\n    solution = [1]\n    pq = []\n    for k, v in list(depth.items()):\n        heapq.heappush(pq, (-v, k))\n    seen = [False for _ in range(n)]\n    seen[root] = True\n    while len(pq) > 0:\n        _, best = heapq.heappop(pq)\n        if seen[best]:\n            continue\n        path = []\n        c = best\n        s = 0\n        while c != -1:\n            seen[c] = True\n            c = child[c]\n            s = s+1\n        s = s + solution[-1]\n        solution.append(s)\n    for _ in range(n - min(len(solution), n)):\n        solution.append(n)\n    print(' '.join([str(s) for s in solution]))",
        "inputs": [
            "3\n1 2\n2 3\n",
            "4\n1 2\n3 2\n4 2\n",
            "19\n2 19\n7 15\n8 10\n16 1\n12 5\n11 5\n6 18\n12 14\n14 15\n2 6\n9 14\n4 17\n16 10\n4 2\n7 18\n3 2\n9 13\n11 10\n"
        ],
        "outputs": [
            "1 3 3 ",
            "1 3 4 4 ",
            "1 14 16 17 18 19 19 19 19 19 19 19 19 19 19 19 19 19 19 "
        ],
        "starter_code": "\ndef PjWVC():\n",
        "scope": [
            [
                "Function Body",
                4,
                65
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "List Comprehension",
                12,
                12
            ],
            [
                "Function Body",
                13,
                36
            ],
            [
                "Lambda Expression",
                16,
                16
            ],
            [
                "List Comprehension",
                18,
                18
            ],
            [
                "While Loop Body",
                19,
                35
            ],
            [
                "If Statement Body",
                21,
                30
            ],
            [
                "If Statement Body",
                23,
                29
            ],
            [
                "List Comprehension",
                24,
                25
            ],
            [
                "Lambda Expression",
                26,
                26
            ],
            [
                "For Loop Body",
                32,
                35
            ],
            [
                "If Statement Body",
                33,
                35
            ],
            [
                "List Comprehension",
                39,
                39
            ],
            [
                "Lambda Expression",
                40,
                40
            ],
            [
                "While Loop Body",
                41,
                42
            ],
            [
                "For Loop Body",
                46,
                47
            ],
            [
                "List Comprehension",
                48,
                48
            ],
            [
                "While Loop Body",
                50,
                62
            ],
            [
                "If Statement Body",
                52,
                53
            ],
            [
                "While Loop Body",
                57,
                60
            ],
            [
                "For Loop Body",
                63,
                64
            ],
            [
                "List Comprehension",
                65,
                65
            ]
        ],
        "difficulty": "interview"
    },
    {
        "prompt": "\ndef accum(s):\n\t    \"\"\"This time no story, no theory. The examples below show you how to write function `accum`:\n\n**Examples:**\n```\naccum(\"abcd\") -> \"A-Bb-Ccc-Dddd\"\naccum(\"RqaEzty\") -> \"R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy\"\naccum(\"cwAt\") -> \"C-Ww-Aaa-Tttt\"\n```\n\nThe parameter of accum is a string which includes only letters from `a..z` and `A..Z`.\n    \"\"\"\n",
        "canonical_solution": "def accum(s):\n    return '-'.join(c.upper() + c.lower() * i for i, c in enumerate(s))",
        "inputs": [
            [
                "\"ZpglnRxqenU\""
            ],
            [
                "\"NyffsGeyylB\""
            ],
            [
                "\"MjtkuBovqrU\""
            ]
        ],
        "outputs": [
            [
                "\"Z-Pp-Ggg-Llll-Nnnnn-Rrrrrr-Xxxxxxx-Qqqqqqqq-Eeeeeeeee-Nnnnnnnnnn-Uuuuuuuuuuu\""
            ],
            [
                "\"N-Yy-Fff-Ffff-Sssss-Gggggg-Eeeeeee-Yyyyyyyy-Yyyyyyyyy-Llllllllll-Bbbbbbbbbbb\""
            ],
            [
                "\"M-Jj-Ttt-Kkkk-Uuuuu-Bbbbbb-Ooooooo-Vvvvvvvv-Qqqqqqqqq-Rrrrrrrrrr-Uuuuuuuuuuu\""
            ]
        ],
        "starter_code": "\ndef accum(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef svdIE():\n    \"\"\"There are $n$ boxers, the weight of the $i$-th boxer is $a_i$. Each of them can change the weight by no more than $1$ before the competition (the weight cannot become equal to zero, that is, it must remain positive). Weight is always an integer number.\n\nIt is necessary to choose the largest boxing team in terms of the number of people, that all the boxers' weights in the team are different (i.e. unique).\n\nWrite a program that for given current values ​$a_i$ will find the maximum possible number of boxers in a team.\n\nIt is possible that after some change the weight of some boxer is $150001$ (but no more).\n\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 150000$) — the number of boxers. The next line contains $n$ integers $a_1, a_2, \\dots, a_n$, where $a_i$ ($1 \\le a_i \\le 150000$) is the weight of the $i$-th boxer.\n\n\n-----Output-----\n\nPrint a single integer — the maximum possible number of people in a team.\n\n\n-----Examples-----\nInput\n4\n3 2 4 1\n\nOutput\n4\n\nInput\n6\n1 1 1 4 4 4\n\nOutput\n5\n\n\n\n-----Note-----\n\nIn the first example, boxers should not change their weights — you can just make a team out of all of them.\n\nIn the second example, one boxer with a weight of $1$ can be increased by one (get the weight of $2$), one boxer with a weight of $4$ can be reduced by one, and the other can be increased by one (resulting the boxers with a weight of $3$ and $5$, respectively). Thus, you can get a team consisting of boxers with weights of $5, 4, 3, 2, 1$.\n    \"\"\"\n",
        "canonical_solution": "\ndef svdIE():\n    n=int(input())\n    arr=list(map(int,input().split()))\n    arr=sorted(arr)\n    s=set()\n    for val in arr:\n      if val!=1 and val-1 not in s:\n          s.add(val-1)\n      elif val not in s:\n        s.add(val)\n      elif val+1 not in s:\n        s.add(val+1)\n    print(len(s))",
        "inputs": [
            "4\n3 2 4 1\n",
            "6\n1 1 1 4 4 4\n",
            "10\n8 9 4 9 6 10 8 2 7 1\n"
        ],
        "outputs": [
            "4\n",
            "5\n",
            "10\n"
        ],
        "starter_code": "\ndef svdIE():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                7,
                13
            ],
            [
                "If Statement Body",
                8,
                13
            ],
            [
                "If Statement Body",
                10,
                13
            ],
            [
                "If Statement Body",
                12,
                13
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef reindeer(presents):\n\t    \"\"\"Santa puts all the presents into the huge sack. In order to let his reindeers rest a bit, he only takes as many reindeers with him as he is required to do. The others may take a nap.\n\nTwo reindeers are always required for the sleigh and Santa himself. Additionally he needs 1 reindeer per 30 presents. As you know, Santa has 8 reindeers in total, so he can deliver up to 180 presents at once (2 reindeers for Santa and the sleigh + 6 reindeers with 30 presents each).\n\nComplete the function `reindeers()`, which takes a number of presents and returns the minimum numbers of required reindeers. If the number of presents is too high, throw an error.\n\nExamles:\n\n```python\nreindeer(0) # must return 2\nreindeer(1) # must return 3\nreindeer(30) # must return 3\nreindeer(200) # must throw an error\n```\n    \"\"\"\n",
        "canonical_solution": "from math import ceil\ndef reindeer(presents):\n  if presents > 180: raise ValueError(\"Too many presents\")\n  return ceil(presents / 30.0) + 2",
        "inputs": [
            [
                0
            ],
            [
                1
            ],
            [
                5
            ]
        ],
        "outputs": [
            [
                2
            ],
            [
                3
            ],
            [
                3
            ]
        ],
        "starter_code": "\ndef reindeer(presents):\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ],
            [
                "If Statement Body",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef capitals_first(text):\n\t    \"\"\"Create a function that takes an input String and returns a String, where all the uppercase words of the input String are in front and all the lowercase words at the end.\nThe order of the uppercase and lowercase words should be the order in which they occur.\n\nIf a word starts with a number or special character, skip the word and leave it out of the result. \n\nInput String will not be empty.\n\nFor an input String: \"hey You, Sort me Already!\" \nthe function should return: \"You, Sort Already! hey me\"\n    \"\"\"\n",
        "canonical_solution": "def capitals_first(string):\n    return ' '.join([word for word in string.split() if word[0].isupper()] + [word for word in string.split() if word[0].islower()])\n",
        "inputs": [
            [
                "\"hey You, Sort me Already\""
            ],
            [
                "\"sense Does to That Make you?\""
            ],
            [
                "\"i First need Thing In coffee The Morning\""
            ]
        ],
        "outputs": [
            [
                "\"You, Sort Already hey me\""
            ],
            [
                "\"Does That Make sense to you?\""
            ],
            [
                "\"First Thing In The Morning i need coffee\""
            ]
        ],
        "starter_code": "\ndef capitals_first(text):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef dqWPt():\n    \"\"\"-----Input-----\n\nThe input contains a single integer a (10 ≤ a ≤ 999).\n\n\n-----Output-----\n\nOutput 0 or 1.\n\n\n-----Examples-----\nInput\n13\n\nOutput\n1\n\nInput\n927\n\nOutput\n1\n\nInput\n48\n\nOutput\n0\n    \"\"\"\n",
        "canonical_solution": "\ndef dqWPt():\n    x = int(input())\n    print(x%2)",
        "inputs": [
            "13\n",
            "927\n",
            "48\n"
        ],
        "outputs": [
            "1\n",
            "1\n",
            "0\n"
        ],
        "starter_code": "\ndef dqWPt():\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef KAJBu():\n    \"\"\"The only difference between problems C1 and C2 is that all values in input of problem C1 are distinct (this condition may be false for problem C2).\n\nYou are given a sequence $a$ consisting of $n$ integers.\n\nYou are making a sequence of moves. During each move you must take either the leftmost element of the sequence or the rightmost element of the sequence, write it down and remove it from the sequence. Your task is to write down a strictly increasing sequence, and among all such sequences you should take the longest (the length of the sequence is the number of elements in it).\n\nFor example, for the sequence $[1, 2, 4, 3, 2]$ the answer is $4$ (you take $1$ and the sequence becomes $[2, 4, 3, 2]$, then you take the rightmost element $2$ and the sequence becomes $[2, 4, 3]$, then you take $3$ and the sequence becomes $[2, 4]$ and then you take $4$ and the sequence becomes $[2]$, the obtained increasing sequence is $[1, 2, 3, 4]$).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of elements in $a$.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nIn the first line of the output print $k$ — the maximum number of elements in a strictly increasing sequence you can obtain.\n\nIn the second line print a string $s$ of length $k$, where the $j$-th character of this string $s_j$ should be 'L' if you take the leftmost element during the $j$-th move and 'R' otherwise. If there are multiple answers, you can print any.\n\n\n-----Examples-----\nInput\n5\n1 2 4 3 2\n\nOutput\n4\nLRRR\n\nInput\n7\n1 3 5 6 5 4 2\n\nOutput\n6\nLRLRRR\n\nInput\n3\n2 2 2\n\nOutput\n1\nR\n\nInput\n4\n1 2 4 3\n\nOutput\n4\nLLRR\n\n\n\n-----Note-----\n\nThe first example is described in the problem statement.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef KAJBu():\n    # AC\n    class Main:\n        def __init__(self):\n            self.buff = None\n            self.index = 0\n        def __next__(self):\n            if self.buff is None or self.index == len(self.buff):\n                self.buff = sys.stdin.readline().split()\n                self.index = 0\n            val = self.buff[self.index]\n            self.index += 1\n            return val\n        def next_int(self):\n            return int(next(self))\n        def solve(self):\n            n = self.next_int()\n            x = [self.next_int() for _ in range(0, n)]\n            d = 0\n            l = 0\n            r = n - 1\n            rs = []\n            while l <= r:\n                if x[l] <= d and x[r] <= d:\n                    break\n                if x[l] <= d:\n                    rs.append('R')\n                    d = x[r]\n                    r -= 1\n                elif x[r] <= d:\n                    rs.append('L')\n                    d = x[l]\n                    l += 1\n                elif x[r] < x[l] or l == r:\n                    rs.append('R')\n                    d = x[r]\n                    r -= 1\n                elif x[l] < x[r]:\n                    rs.append('L')\n                    d = x[l]\n                    l += 1\n                else:\n                    ll = l + 1\n                    while x[ll] > x[ll - 1]:\n                        ll += 1\n                    rr = r - 1\n                    while x[rr] > x[rr + 1]:\n                        rr -= 1\n                    if ll - l > r - rr:\n                        rs.append('L')\n                        d = x[l]\n                        l += 1\n                    else:\n                        rs.append('R')\n                        d = x[r]\n                        r -= 1\n            print(len(rs))\n            print(''.join(rs))\n    def __starting_point():\n        Main().solve()\n    __starting_point()",
        "inputs": [
            "5\n1 2 4 3 2\n",
            "7\n1 3 5 6 5 4 2\n",
            "3\n2 2 2\n"
        ],
        "outputs": [
            "4\nLRRR\n",
            "6\nLRLRRR\n",
            "1\nR\n"
        ],
        "starter_code": "\ndef KAJBu():\n",
        "scope": [
            [
                "Function Body",
                2,
                62
            ],
            [
                "Class Body",
                4,
                59
            ],
            [
                "Function Body",
                5,
                7
            ],
            [
                "Function Body",
                8,
                14
            ],
            [
                "If Statement Body",
                9,
                11
            ],
            [
                "Function Body",
                15,
                16
            ],
            [
                "Function Body",
                17,
                59
            ],
            [
                "List Comprehension",
                19,
                19
            ],
            [
                "While Loop Body",
                24,
                57
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "If Statement Body",
                27,
                57
            ],
            [
                "If Statement Body",
                31,
                57
            ],
            [
                "If Statement Body",
                35,
                57
            ],
            [
                "If Statement Body",
                39,
                57
            ],
            [
                "While Loop Body",
                45,
                46
            ],
            [
                "While Loop Body",
                48,
                49
            ],
            [
                "If Statement Body",
                50,
                57
            ],
            [
                "Function Body",
                60,
                61
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef ojNIR():\n    \"\"\"Snuke has N sticks.\nThe length of the i-th stick is l_i.\nSnuke is making a snake toy by joining K of the sticks together.\nThe length of the toy is represented by the sum of the individual sticks that compose it.\nFind the maximum possible length of the toy.\n\n-----Constraints-----\n - 1 \\leq K \\leq N \\leq 50\n - 1 \\leq l_i \\leq 50\n - l_i is an integer.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN K\nl_1 l_2 l_3 ... l_{N}\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n5 3\n1 2 3 4 5\n\n-----Sample Output-----\n12\n\nYou can make a toy of length 12 by joining the sticks of lengths 3, 4 and 5, which is the maximum possible length.\n    \"\"\"\n",
        "canonical_solution": "\ndef ojNIR():\n    N,K=map(int,input().split())\n    l=list(map(int,input().split()))\n    l.sort(reverse=True)\n    sum=0\n    for i in range(K) :\n      sum+=l[i]\n    print(sum)",
        "inputs": [
            "5 3\n1 2 3 4 5\n",
            "15 14\n50 26 27 21 41 7 42 35 7 5 5 36 39 1 45\n"
        ],
        "outputs": [
            "12\n",
            "386\n"
        ],
        "starter_code": "\ndef ojNIR():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                7,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef has_subpattern(string):\n\t    \"\"\"Similarly to the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-i/), you will need to return a boolean value if the base string can be expressed as the repetition of one subpattern.\n\nThis time there are two small changes:\n\n* if a subpattern has been used, it will be repeated at least twice, meaning the subpattern has to be shorter than the original string;\n* the strings you will be given might or might not be created repeating a given subpattern, then shuffling the result.\n\nFor example:\n\n```python\nhas_subpattern(\"a\") == False #no repeated shorter sub-pattern, just one character\nhas_subpattern(\"aaaa\") == True #just one character repeated\nhas_subpattern(\"abcd\") == False #no repetitions\nhas_subpattern(\"babababababababa\") == True #repeated \"ba\"\nhas_subpattern(\"bbabbaaabbaaaabb\") == True #same as above, just shuffled\n```\nStrings will never be empty and can be composed of any character (just consider upper- and lowercase letters as different entities) and can be pretty long (keep an eye on performances!).\n\nIf you liked it, go for either the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-i/) or the [next kata](https://www.codewars.com/kata/string-subpattern-recognition-iii/) of the series!\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter\nfrom functools import reduce\nfrom math import gcd\n\ndef has_subpattern(string):\n    return reduce(gcd, Counter(string).values()) != 1",
        "inputs": [
            [
                "\"a\""
            ],
            [
                "\"aaaa\""
            ],
            [
                "\"abcd\""
            ]
        ],
        "outputs": [
            [
                false
            ],
            [
                true
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef has_subpattern(string):\n",
        "scope": [
            [
                "Function Body",
                5,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef choose(n,k):\n\t    \"\"\"You may be familiar with the concept of combinations: for example, if you take 5 cards from a 52 cards deck as you would playing poker, you can have a certain number (2,598,960, would you say?) of different combinations.\n\nIn mathematics the number of *k* combinations you can have taking from a set of *n* elements is called the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient) of n and k, more popularly called **n choose k**.\n\nThe formula to compute it is relatively simple: `n choose k`==`n!/(k!*(n-k)!)`, where `!` of course denotes the factorial operator.\n\nYou are now to create a choose function that computes the binomial coefficient, like this:\n\n```\nchoose(1,1)==1\nchoose(5,4)==5\nchoose(10,5)==252\nchoose(10,20)==0\nchoose(52,5)==2598960\n```\n\nBe warned: a certain degree of optimization is expected, both to deal with larger numbers precision (and their rounding errors in languages like JS) and computing time.\n    \"\"\"\n",
        "canonical_solution": "from math import factorial\n\ndef choose(n, k):\n    return factorial(n) / ( factorial(k) * factorial(n-k) ) if k <=n else 0",
        "inputs": [
            [
                1,
                1
            ],
            [
                5,
                4
            ],
            [
                10,
                5
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                5
            ],
            [
                252
            ]
        ],
        "starter_code": "\ndef choose(n,k):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef checkchoose(m, n):\n\t    \"\"\"You know combinations: for example, \nif you take 5 cards from a 52 cards deck you have 2,598,960 different combinations.\n\nIn mathematics the number of x combinations you can take from a set of n elements\nis called the binomial coefficient of n and x, or more often `n choose x`.\nThe formula to compute `m = n choose x` is: `m = n! / (x! * (n - x)!)`\nwhere ! is the factorial operator.\n\nYou are a renowned poster designer and painter. You are asked to provide 6 posters \nall having the same design each in 2 colors. Posters must all have a different color combination and you have the choice of 4 colors: red, blue, yellow, green. \nHow many colors can you choose for each poster?\n\nThe answer is two since `4 choose 2 = 6`. The combinations will be:\n{red, blue}, {red, yellow}, {red, green}, {blue, yellow}, {blue, green}, {yellow, green}.\n\nNow same question but you have 35 posters to provide and 7 colors available. How many colors for each poster?\nIf you take combinations `7 choose 2` you will get 21 with the above formula.\nBut 21 schemes aren't enough for 35 posters. If you take `7 choose 5` combinations you will get 21 too.\nFortunately if you take `7 choose 3` or `7 choose 4` combinations you get 35 and so each poster will have a different combination of\n3 colors or 5 colors. You will take 3 colors because it's less expensive.\n\nHence the problem is: \n\nknowing `m` (number of posters to design), \nknowing `n` (total number of available colors), \nlet us \nsearch `x` (number of colors for each poster so that each poster has a unique combination of colors and the number of combinations is exactly the same as the number of posters).\n\nIn other words we must find **x** such as `n choose x = m (1)` for a given m and a given n;\n`m >= 0 and n > 0`. If many x are solutions give as result the smallest x.\nIt can happen that when m is given at random there are no x satisfying `equation (1)` then\nreturn -1.\n\nExamples:\n```\ncheckchoose(6, 4) --> 2\ncheckchoose(4, 4) --> 1\ncheckchoose(4, 2) --> -1\ncheckchoose(35, 7) --> 3\ncheckchoose(36, 7) --> -1\n\na = 47129212243960\ncheckchoose(a, 50) --> 20\ncheckchoose(a + 1, 50) --> -1\n```\n    \"\"\"\n",
        "canonical_solution": "def checkchoose(m, n):\n    c = 1\n    for x in range(n // 2 + 1):\n        if c == m: return x\n        c = c * (n-x) // (x+1)\n    else: return -1\n",
        "inputs": [
            [
                1,
                6
            ],
            [
                6,
                4
            ],
            [
                4,
                4
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                2
            ],
            [
                1
            ]
        ],
        "starter_code": "\ndef checkchoose(m, n):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "For Loop Body",
                3,
                6
            ],
            [
                "If Statement Body",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef maxlen(l1, l2):\n\t    \"\"\"Imagine that you are given two sticks. You want to end up with three sticks of equal length. You are allowed to cut either or both of the sticks to accomplish this, and can throw away leftover pieces.\n\nWrite a function, maxlen, that takes the lengths of the two sticks (L1 and L2, both positive values), that will return the maximum length you can make the three sticks.\n    \"\"\"\n",
        "canonical_solution": "def maxlen(s1, s2):\n    sm, lg = sorted((s1, s2))\n    return min(max(lg / 3, sm), lg / 2)",
        "inputs": [
            [
                5,
                12
            ],
            [
                12,
                5
            ],
            [
                5,
                17
            ]
        ],
        "outputs": [
            [
                5
            ],
            [
                5
            ],
            [
                5.666666666666667
            ]
        ],
        "starter_code": "\ndef maxlen(l1, l2):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef sort_array(value):\n\t    \"\"\"Failed Sort - Bug Fixing #4\nOh no, Timmy's Sort doesn't seem to be working? Your task is to fix the sortArray function to sort all numbers in ascending order\n    \"\"\"\n",
        "canonical_solution": "def sort_array(value):\n    return \"\".join(sorted(value))",
        "inputs": [
            [
                "\"12345\""
            ],
            [
                "\"54321\""
            ],
            [
                "\"34251\""
            ]
        ],
        "outputs": [
            [
                "\"12345\""
            ],
            [
                "\"12345\""
            ],
            [
                "\"12345\""
            ]
        ],
        "starter_code": "\ndef sort_array(value):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef textin(st):\n\t    \"\"\"Write a function that replaces 'two', 'too' and 'to' with the number '2'. Even if the sound is found mid word (like in octopus) or not in lowercase grandma still thinks that should be replaced with a 2. Bless her.\n\n```text\n'I love to text' becomes 'I love 2 text'\n'see you tomorrow' becomes 'see you 2morrow'\n'look at that octopus' becomes 'look at that oc2pus'\n```\n\nNote that 'too' should become '2', not '2o'\n    \"\"\"\n",
        "canonical_solution": "import re\n\ndef textin(txt ):\n  return re.sub(r'(two|too|to)', '2', txt, flags=re.I)",
        "inputs": [
            [
                "\"I love to text\""
            ],
            [
                "\"see you tomorrow\""
            ],
            [
                "\"look at that octopus\""
            ]
        ],
        "outputs": [
            [
                "\"I love 2 text\""
            ],
            [
                "\"see you 2morrow\""
            ],
            [
                "\"look at that oc2pus\""
            ]
        ],
        "starter_code": "\ndef textin(st):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef cycle(sequence):\n\t    \"\"\"In computer science, cycle detection is the algorithmic problem of finding a cycle in a sequence of iterated function values.\n\nFor any function ƒ, and any initial value x0 in S, the sequence of iterated function values\n\n    x0,x1=f(x0), x2=f(x1), ...,xi=f(x{i-1}),...\n\nmay eventually use the same value twice under some assumptions: S finite, f periodic ... etc. So there will be some `i ≠ j` such that `xi = xj`. Once this happens, the sequence must continue by repeating the cycle of values from `xi to xj−1`. Cycle detection is the problem of finding `i` and `j`, given `ƒ` and `x0`. Let `μ` be the smallest index such that the value associated will reappears and `λ` the smallest value such that `xμ = xλ+μ, λ` is the loop length.\n\nExample:\n\nConsider the sequence: \n```\n2, 0, 6, 3, 1, 6, 3, 1, 6, 3, 1, ....\n```\n\nThe cycle in this value sequence is 6, 3, 1.\nμ is 2 (first 6)\nλ is 3 (length of the sequence or difference between position of consecutive 6).\n\nThe goal of this kata is to build a function that will return `[μ,λ]` when given a short sequence. Simple loops will be sufficient. The sequence will be given in the form of an array. All array will be valid sequence associated with deterministic function. It means that the sequence will repeat itself when a value is reached a second time. (So you treat two cases: non repeating [1,2,3,4] and repeating [1,2,1,2], no hybrid cases like [1,2,1,4]). If there is no repetition you should return []. \n\n\nThis kata is followed by two other cycle detection algorithms: \nLoyd's: http://www.codewars.com/kata/cycle-detection-floyds-tortoise-and-the-hare\nBret's: http://www.codewars.com/kata/cycle-detection-brents-tortoise-and-hare\n    \"\"\"\n",
        "canonical_solution": "def cycle(sequence):\n    for j, x in enumerate(sequence):\n        i = sequence.index(x)\n        if 0 <= i < j:\n            return [i, j - i]\n    return []\n",
        "inputs": [
            [
                [
                    2,
                    3,
                    4,
                    2,
                    3,
                    4
                ]
            ],
            [
                [
                    1,
                    2,
                    3,
                    4,
                    2,
                    3,
                    4
                ]
            ],
            [
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]
        ],
        "outputs": [
            [
                [
                    0,
                    3
                ]
            ],
            [
                [
                    1,
                    3
                ]
            ],
            [
                [
                    0,
                    1
                ]
            ]
        ],
        "starter_code": "\ndef cycle(sequence):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "For Loop Body",
                2,
                5
            ],
            [
                "If Statement Body",
                4,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef what_century(year):\n\t    \"\"\"Return the century of the input year. The input will always be a 4 digit string, so there is no need for validation. \n\n### Examples\n```\n\"1999\" --> \"20th\"\n\"2011\" --> \"21st\"\n\"2154\" --> \"22nd\"\n\"2259\" --> \"23rd\"\n\"1124\" --> \"12th\"\n\"2000\" --> \"20th\"\n```\n    \"\"\"\n",
        "canonical_solution": "def what_century(year):\n    n = (int(year) - 1) // 100 + 1\n    return str(n) + (\"th\" if n < 20 else {1: \"st\", 2: \"nd\", 3: \"rd\"}.get(n % 10, \"th\"))",
        "inputs": [
            [
                "\"1999\""
            ]
        ],
        "outputs": [
            [
                "\"20th\""
            ]
        ],
        "starter_code": "\ndef what_century(year):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def balancedStringSplit(self, s: str) -> int:\n            \"\"\"Balanced strings are those who have equal quantity of 'L' and 'R' characters.\nGiven a balanced string s split it in the maximum amount of balanced strings.\nReturn the maximum amount of splitted balanced strings.\n \nExample 1:\nInput: s = \"RLRRLLRLRL\"\nOutput: 4\nExplanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\n\nExample 2:\nInput: s = \"RLLLLRRRLR\"\nOutput: 3\nExplanation: s can be split into \"RL\", \"LLLRRR\", \"LR\", each substring contains same number of 'L' and 'R'.\n\nExample 3:\nInput: s = \"LLLLRRRR\"\nOutput: 1\nExplanation: s can be split into \"LLLLRRRR\".\n\nExample 4:\nInput: s = \"RLRRRLLRLL\"\nOutput: 2\nExplanation: s can be split into \"RL\", \"RRRLLRLL\", since each substring contains an equal number of 'L' and 'R'\n\n \nConstraints:\n\n1 <= s.length <= 1000\ns[i] = 'L' or 'R'\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def balancedStringSplit(self, s: str) -> int:\n        lCount = rCount = 0\n        retVal = 0\n        \n        for char in s:\n            if char == 'R':\n                rCount += 1\n            else:\n                lCount += 1\n                \n            if rCount == lCount:\n                retVal += 1\n                lCount = rCount = 0\n        return retVal\n",
        "inputs": [
            [
                "\"RLRRLLRLRL\""
            ]
        ],
        "outputs": [
            [
                4
            ]
        ],
        "starter_code": "\nclass Solution:\n    def balancedStringSplit(self, s: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                15
            ],
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                6,
                14
            ],
            [
                "If Statement Body",
                7,
                10
            ],
            [
                "If Statement Body",
                12,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef hamming_weight(x):\n\t    \"\"\"The __Hamming weight__ of a string is the number of symbols that are different from the zero-symbol of the alphabet used. There are several algorithms for efficient computing of the Hamming weight for numbers. In this Kata, speaking technically, you have to find out the number of '1' bits in a binary representation of a number. Thus,\n\nThe interesting part of this task is that you have to do it *without* string operation (hey, it's not really interesting otherwise)\n\n ;)\n    \"\"\"\n",
        "canonical_solution": "def hamming_weight(x):return bin(x).count('1')",
        "inputs": [
            [
                0
            ],
            [
                1
            ],
            [
                2
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                1
            ],
            [
                1
            ]
        ],
        "starter_code": "\ndef hamming_weight(x):\n",
        "scope": [
            [
                "Function Body",
                1,
                1
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef fisHex(name):\n\t    \"\"\"# How much is the fish! (- Scooter )\nThe ocean is full of colorful fishes. We as programmers want to know the hexadecimal value of these fishes.\n\n## Task\nTake all hexadecimal valid characters (a,b,c,d,e,f) of the given name and XOR them. Return the result as an integer.\n\n## Input\nThe input is always a string, which can contain spaces, upper and lower case letters but no digits. \n\n## Example\n\n`fisHex(\"redlionfish\") -> e,d,f -> XOR -> 12`\n    \"\"\"\n",
        "canonical_solution": "from functools import reduce\nVALID = frozenset('abcdefABCDEF')\n\n\ndef fisHex(s):\n    return reduce(lambda b, c: b ^ c, (int(a, 16) for a in s if a in VALID), 0)\n",
        "inputs": [
            [
                "\"pufferfish\""
            ],
            [
                "\"puffers\""
            ],
            [
                "\"balloonfish\""
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                14
            ],
            [
                14
            ]
        ],
        "starter_code": "\ndef fisHex(name):\n",
        "scope": [
            [
                "Function Body",
                5,
                6
            ],
            [
                "Lambda Expression",
                6,
                6
            ],
            [
                "Generator Expression",
                6,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef is_happy(n):\n\t    \"\"\"A happy number is a number defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\nThose numbers for which this process ends in 1 are **happy numbers**, while those that do not end in 1 are unhappy numbers (or sad numbers) (Wikipedia).\n\nWrite a function that takes `n` as parameter and return `true` if and only if `n` is an happy number, `false` otherwise.\n\n\n## Examples\n\nFor example number `7` is happy because after a number of steps the computed sequence ends up with a 1: `7, 49, 97, 130, 10, 1 `\n\nWhile `3` is not, and would give us an infinite sequence: `3, 9, 81, 65, 61, 37, 58, 89, 145, 42, 20, 4, 16, 37, 58, 89, 145, 42, 20, 4, 16, 37, ...`\n\n\nHappy coding!\n    \"\"\"\n",
        "canonical_solution": "def is_happy(n):\n    seen = set()\n    while n!=1:\n        n = sum(int(d)**2 for d in str(n))\n        if n not in seen: seen.add(n)\n        else:             return False\n    return True",
        "inputs": [
            [
                1
            ],
            [
                7
            ],
            [
                16
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                true
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef is_happy(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                7
            ],
            [
                "While Loop Body",
                3,
                6
            ],
            [
                "Generator Expression",
                4,
                4
            ],
            [
                "If Statement Body",
                5,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n            \"\"\"Given two integer arrays of equal length target and arr.\nIn one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.\nReturn True if you can make arr equal to target, or False otherwise.\n \nExample 1:\nInput: target = [1,2,3,4], arr = [2,4,1,3]\nOutput: true\nExplanation: You can follow the next steps to convert arr to target:\n1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]\n2- Reverse sub-array [4,2], arr becomes [1,2,4,3]\n3- Reverse sub-array [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\n\nExample 2:\nInput: target = [7], arr = [7]\nOutput: true\nExplanation: arr is equal to target without any reverses.\n\nExample 3:\nInput: target = [1,12], arr = [12,1]\nOutput: true\n\nExample 4:\nInput: target = [3,7,9], arr = [3,7,11]\nOutput: false\nExplanation: arr doesn't have value 9 and it can never be converted to target.\n\nExample 5:\nInput: target = [1,1,1,1,1], arr = [1,1,1,1,1]\nOutput: true\n\n \nConstraints:\n\ntarget.length == arr.length\n1 <= target.length <= 1000\n1 <= target[i] <= 1000\n1 <= arr[i] <= 1000\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return sorted(target) == sorted(arr)",
        "inputs": [
            [
                [
                    1,
                    2,
                    3,
                    4
                ],
                [
                    2,
                    4,
                    1,
                    3
                ]
            ]
        ],
        "outputs": [
            [
                true
            ]
        ],
        "starter_code": "\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                3
            ],
            [
                "Function Body",
                2,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n            \"\"\"Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n \nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\n \nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n        count=0\n        for i in arr1:\n            flag=0\n            for j in arr2:\n                if abs(i-j)<=d:\n                    flag=1\n                    break\n            if flag == 0:\n                count+=1\n        return count",
        "inputs": [
            [
                [
                    4,
                    5,
                    8
                ],
                [
                    10,
                    9,
                    1,
                    8
                ],
                2
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                12
            ],
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                4,
                11
            ],
            [
                "For Loop Body",
                6,
                9
            ],
            [
                "If Statement Body",
                7,
                9
            ],
            [
                "If Statement Body",
                10,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef hop_across(lst):\n\t    \"\"\"You are trying to cross a river by jumping along stones. Every time you land on a stone, you hop forwards by the value of that stone. If you skip *over* a stone then its value doesn't affect you in any way. Eg:\n\n```\n x--x-----x-->\n[1][2][5][1]\n\n```\n\nOf course, crossing from the other side might give you a different answer:\n\n```\n <--------x--x\n   [1][2][5][1]\n\n```\n\nGiven an array of positive integers, return the total number of steps it would take to go all the way across the river (and past the end of the array) and then all the way back. All arrays will contain at least one element, and may contain up to 100 elements. \n\n### Examples\n\n```\n  x--x-----x-->\n [1][2][1][2]\n<----x-----x\n\ntherefore hop_across([1,2,1,2]) = 3 + 2 = 5\n\n   x-----x--------x------>\n  [2][2][3][1][1][2][1]\n<--------x--x-----x--x\n\ntherefore hop_across([2,2,3,1,1,2,1]) = 3 + 4 = 7\n\n```\n    \"\"\"\n",
        "canonical_solution": "def hop_across(lst):\n    def one_side(lst):\n        i = 0\n        steps = 0\n        while i < len(lst):\n            i += lst[i]\n            steps += 1\n        return steps\n    return one_side(lst) + one_side(lst[::-1])",
        "inputs": [
            [
                [
                    1
                ]
            ],
            [
                [
                    2
                ]
            ],
            [
                [
                    1,
                    1
                ]
            ]
        ],
        "outputs": [
            [
                2
            ],
            [
                2
            ],
            [
                4
            ]
        ],
        "starter_code": "\ndef hop_across(lst):\n",
        "scope": [
            [
                "Function Body",
                1,
                9
            ],
            [
                "Function Body",
                2,
                8
            ],
            [
                "While Loop Body",
                5,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef sort_by_perfsq(arr):\n\t    \"\"\"You will be given an array of positive integers. The array should be sorted by the amount of distinct perfect squares and reversed, that can be generated from each number permuting its digits.\n\nE.g.: ```arr = [715, 112, 136, 169, 144]``` \n``` \nNumber   Perfect Squares w/ its Digits   Amount\n 715                -                       0\n 112               121                      1\n 136               361                      1\n 169           169, 196, 961                3\n 144             144, 441                   2\n``` \nSo the output will have the following order:\n```[169, 144, 112, 136, 715]``` \n\nWhen we have two or more numbers with the same amount of perfect squares in their permutations, we sorted by their values.\n\nIn the example given above, we can see that 112 and 136 both generate a perfect square. So 112 comes first.\n\nExamples for this kata:\n```python\nsort_by_perfsq([715, 112, 136, 169, 144]) == [169, 144, 112, 136, 715]\n# number of perfect squares:                   3    2    1    1    0\n``` \nWe may have in the array numbers that belongs to the same set of permutations.\n```python\nsort_by_perfsq([234, 61, 16, 441, 144, 728]) == [144, 441, 16, 61, 234, 728]\n# number of perfect squares:                      2    2    1   0   0    0\n```\n\nFeatures of the random tests:\n~~~if:ruby,python\n- Number of tests: 80\n- Arrays between 4 and 20 elements\n- Integers having from 1 to 7 digits included\n~~~\n~~~if:js\n- Number of tests: 30\n- Arrays between 4 and 16 elements\n- Integers having from 1 to 7 digits included\n~~~\n\nEnjoy it!!\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\nSQUARES = [x**2 for x in range(1, 3163)]\nDIGITS  = defaultdict(int)\nfor sqr in SQUARES:\n    DIGITS[''.join(sorted(str(sqr)))] += 1\n\ndef sort_by_perfsq(arr):\n    return sorted(arr, key=lambda n: (-DIGITS[''.join(sorted(str(n)))], n))",
        "inputs": [
            [
                [
                    715,
                    112,
                    136,
                    169,
                    144
                ]
            ],
            [
                [
                    234,
                    61,
                    16,
                    441,
                    144,
                    728
                ]
            ]
        ],
        "outputs": [
            [
                [
                    169,
                    144,
                    112,
                    136,
                    715
                ]
            ],
            [
                [
                    144,
                    441,
                    16,
                    61,
                    234,
                    728
                ]
            ]
        ],
        "starter_code": "\ndef sort_by_perfsq(arr):\n",
        "scope": [
            [
                "List Comprehension",
                2,
                2
            ],
            [
                "For Loop Body",
                4,
                5
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Lambda Expression",
                8,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef digits_average(input):\n\t    \"\"\"Given an integer, take the (mean) average of each pair of consecutive digits. Repeat this process until you have a single integer, then return that integer. e.g.\n\nNote: if the average of two digits is not an integer, round the result **up** (e.g. the average of 8 and 9 will be 9)\n\n## Examples\n\n```\ndigitsAverage(246)  ==>  4\n\noriginal: 2   4   6\n           \\ / \\ /\n1st iter:   3   5\n             \\ /\n2nd iter:     4\n\n\ndigitsAverage(89)  ==>  9\n\noriginal: 8   9\n           \\ /\n1st iter:   9\n```\n\np.s. for a bigger challenge, check out the [one line version](https://www.codewars.com/kata/one-line-task-digits-average) of this kata by myjinxin2015!\n    \"\"\"\n",
        "canonical_solution": "def digits_average(input):\n    digits = [int(c) for c in str(input)]\n    while len(digits) > 1:\n        digits = [(a + b + 1) // 2 for a, b in zip(digits, digits[1:])]\n    return digits[0]",
        "inputs": [
            [
                246
            ],
            [
                89
            ],
            [
                2
            ]
        ],
        "outputs": [
            [
                4
            ],
            [
                9
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef digits_average(input):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "List Comprehension",
                2,
                2
            ],
            [
                "While Loop Body",
                3,
                4
            ],
            [
                "List Comprehension",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef tower_of_hanoi(rings):\n\t    \"\"\"The Tower of Hanoi problem involves 3 towers.  A number of rings decreasing in size are placed on one tower.  All rings must then be moved to another tower, but at no point can a larger ring be placed on a smaller ring.\n\nYour task:  Given a number of rings, return the MINIMUM number of moves needed to move all the rings from one tower to another.\n\nReference: Tower of Hanoi, Courtesy of Coolmath Games\n\nNB:  This problem may seem very complex, but in reality there is an amazingly simple formula to calculate the minimum number.  Just Learn how to solve the problem via the above link (if you are not familiar with it), and then think hard.  Your solution should be in no way extraordinarily long and complex.  The Kata ranking is for figuring out the solution, but the coding skills required are minimal.\n    \"\"\"\n",
        "canonical_solution": "def tower_of_hanoi(rings):\n    return 2**rings - 1",
        "inputs": [
            [
                4
            ],
            [
                5
            ],
            [
                10
            ]
        ],
        "outputs": [
            [
                15
            ],
            [
                31
            ],
            [
                1023
            ]
        ],
        "starter_code": "\ndef tower_of_hanoi(rings):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef how_many_light_sabers_do_you_own(*name):\n\t    \"\"\"Inspired by the development team at Vooza, write the function `howManyLightsabersDoYouOwn`/`how_many_light_sabers_do_you_own` that \n\n* accepts the name of a programmer, and\n* returns the number of lightsabers owned by that person.\n\nThe only person who owns lightsabers is Zach, by the way. He owns 18, which is an awesome number of lightsabers. Anyone else owns 0.\n\n```if:coffeescript,javascript,php,python,ruby,typescript\n**Note**: your function should have a default parameter.\n```\n\n```c#\nKata.HowManyLightsabersDoYouOwn(\"Adam\") == 0\nKata.HowManyLightsabersDoYouOwn(\"Zach\") == 18\n```\n```python\nhow_many_light_sabers_do_you_own('Zach') == 18\nhow_many_light_sabers_do_you_own('Adam') == 0\nhow_many_light_sabers_do_you_own()       == 0\n```\n    \"\"\"\n",
        "canonical_solution": "def how_many_light_sabers_do_you_own(name=\"\"):\n    return (18 if name==\"Zach\" else 0)",
        "inputs": [
            [
                "\"Zach\""
            ],
            [
                "\"zach\""
            ]
        ],
        "outputs": [
            [
                18
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef how_many_light_sabers_do_you_own(*name):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef vOWpg():\n    \"\"\"You are given a permutation of length $n$. Recall that the permutation is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2, 3, 1, 5, 4]$ is a permutation, but $[1, 2, 2]$ is not a permutation ($2$ appears twice in the array) and $[1, 3, 4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\n\nYou can perform at most $n-1$ operations with the given permutation (it is possible that you don't perform any operations at all). The $i$-th operation allows you to swap elements of the given permutation on positions $i$ and $i+1$. Each operation can be performed at most once. The operations can be performed in arbitrary order.\n\nYour task is to find the lexicographically minimum possible permutation obtained by performing some of the given operations in some order.\n\nYou can see the definition of the lexicographical order in the notes section.\n\nYou have to answer $q$ independent test cases.\n\nFor example, let's consider the permutation $[5, 4, 1, 3, 2]$. The minimum possible permutation we can obtain is $[1, 5, 2, 4, 3]$ and we can do it in the following way:\n\n  perform the second operation (swap the second and the third elements) and obtain the permutation $[5, 1, 4, 3, 2]$;  perform the fourth operation (swap the fourth and the fifth elements) and obtain the permutation $[5, 1, 4, 2, 3]$;  perform the third operation (swap the third and the fourth elements) and obtain the permutation $[5, 1, 2, 4, 3]$.  perform the first operation (swap the first and the second elements) and obtain the permutation $[1, 5, 2, 4, 3]$; \n\nAnother example is $[1, 2, 4, 3]$. The minimum possible permutation we can obtain is $[1, 2, 3, 4]$ by performing the third operation (swap the third and the fourth elements).\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 100$) — the number of test cases. Then $q$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 100$) — the number of elements in the permutation.\n\nThe second line of the test case contains $n$ distinct integers from $1$ to $n$ — the given permutation.\n\n\n-----Output-----\n\nFor each test case, print the answer on it — the lexicograhically minimum possible permutation obtained by performing some of the given operations in some order.\n\n\n-----Example-----\nInput\n4\n5\n5 4 1 3 2\n4\n1 2 4 3\n1\n1\n4\n4 3 2 1\n\nOutput\n1 5 2 4 3 \n1 2 3 4 \n1 \n1 4 3 2 \n\n\n\n-----Note-----\n\nRecall that the permutation $p$ of length $n$ is lexicographically less than the permutation $q$ of length $n$ if there is such index $i \\le n$ that for all $j$ from $1$ to $i - 1$ the condition $p_j = q_j$ is satisfied, and $p_i < q_i$. For example:\n\n  $p = [1, 3, 5, 2, 4]$ is less than $q = [1, 3, 5, 4, 2]$ (such $i=4$ exists, that $p_i < q_i$ and for each $j < i$ holds $p_j = q_j$),  $p = [1, 2]$ is less than $q = [2, 1]$ (such $i=1$ exists, that $p_i < q_i$ and for each $j < i$ holds $p_j = q_j$).\n    \"\"\"\n",
        "canonical_solution": "\ndef vOWpg():\n    q = int(input())\n    for qi in range(q):\n        n = int(input())\n        a = list(map(int, input().split()))\n        used = [False] * n\n        for t in range(n):\n            for i in range(len(a) - 1, 0, -1):\n                if used[i]:\n                    continue\n                if a[i] < a[i - 1]:\n                    a[i], a[i - 1] = a[i - 1], a[i]\n                    used[i] = True\n        print(' '.join(str(x) for x in a))",
        "inputs": [
            "4\n5\n5 4 1 3 2\n4\n1 2 4 3\n1\n1\n4\n4 3 2 1\n",
            "1\n5\n4 2 3 5 1\n"
        ],
        "outputs": [
            "1 5 2 4 3 \n1 2 3 4 \n1 \n1 4 3 2 \n",
            "1 4 2 3 5 \n"
        ],
        "starter_code": "\ndef vOWpg():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                4,
                15
            ],
            [
                "For Loop Body",
                8,
                14
            ],
            [
                "For Loop Body",
                9,
                14
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "If Statement Body",
                12,
                14
            ],
            [
                "Generator Expression",
                15,
                15
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef Enmyf():\n    \"\"\"You are given the array $a$ consisting of $n$ positive (greater than zero) integers.\n\nIn one move, you can choose two indices $i$ and $j$ ($i \\ne j$) such that the absolute difference between $a_i$ and $a_j$ is no more than one ($|a_i - a_j| \\le 1$) and remove the smallest of these two elements. If two elements are equal, you can remove any of them (but exactly one).\n\nYour task is to find if it is possible to obtain the array consisting of only one element using several (possibly, zero) such moves or not.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) — the length of $a$. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 100$), where $a_i$ is the $i$-th element of $a$.\n\n\n-----Output-----\n\nFor each test case, print the answer: \"YES\" if it is possible to obtain the array consisting of only one element using several (possibly, zero) moves described in the problem statement, or \"NO\" otherwise.\n\n\n-----Example-----\nInput\n5\n3\n1 2 2\n4\n5 5 5 5\n3\n1 2 4\n4\n1 3 4 4\n1\n100\n\nOutput\nYES\nYES\nNO\nNO\nYES\n\n\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:  choose $i=1$ and $j=3$ and remove $a_i$ (so $a$ becomes $[2; 2]$);  choose $i=1$ and $j=2$ and remove $a_j$ (so $a$ becomes $[2]$). \n\nIn the second test case of the example, we can choose any possible $i$ and $j$ any move and it doesn't matter which element we remove.\n\nIn the third test case of the example, there is no way to get rid of $2$ and $4$.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport math\ndef Enmyf():\n    def II():\n    \treturn int(sys.stdin.readline())\n    def LI():\n    \treturn list(map(int, sys.stdin.readline().split()))\n    def MI():\n    \treturn list(map(int, sys.stdin.readline().split()))\n    def SI():\n    \treturn sys.stdin.readline().strip()\n    t = II()\n    for q in range(t):\n    \tn = II()\n    \ta = sorted(LI())\n    \tboo = True\n    \tfor i in range(1,n):\n    \t\tif a[i]-a[i-1]>1:\n    \t\t\tboo = False\n    \t\t\tbreak\n    \tprint(\"YES\" if boo else \"NO\")",
        "inputs": [
            "5\n3\n1 2 2\n4\n5 5 5 5\n3\n1 2 4\n4\n1 3 4 4\n1\n100\n",
            "2\n3\n1 2 2\n4\n5 5 5 5\n",
            "2\n3\n1 2 3\n4\n1 2 3 4\n"
        ],
        "outputs": [
            "YES\nYES\nNO\nNO\nYES\n",
            "YES\nYES\n",
            "YES\nYES\n"
        ],
        "starter_code": "\ndef Enmyf():\n",
        "scope": [
            [
                "Function Body",
                3,
                21
            ],
            [
                "Function Body",
                4,
                5
            ],
            [
                "Function Body",
                6,
                7
            ],
            [
                "Function Body",
                8,
                9
            ],
            [
                "Function Body",
                10,
                11
            ],
            [
                "For Loop Body",
                13,
                21
            ],
            [
                "For Loop Body",
                17,
                20
            ],
            [
                "If Statement Body",
                18,
                20
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef ranking(people):\n\t    \"\"\"In some ranking people collects points. The challenge is sort by points and calulate position for every person. But remember if two or more persons have same number of points, they should have same position number and sorted by name (name is unique).\n\nFor example:\nInput structure:\n\nOutput should be:\n    \"\"\"\n",
        "canonical_solution": "def ranking(a):\n    a.sort(key=lambda x: (-x[\"points\"], x[\"name\"]))\n    for i, x in enumerate(a):\n        x[\"position\"] = i + 1 if not i or x[\"points\"] < a[i-1][\"points\"] else a[i-1][\"position\"]\n    return a",
        "inputs": [
            [
                []
            ]
        ],
        "outputs": [
            [
                []
            ]
        ],
        "starter_code": "\ndef ranking(people):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "Lambda Expression",
                2,
                2
            ],
            [
                "For Loop Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n            \"\"\"Write an algorithm to determine if a number is \"happy\".\n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\nExample: \n\n\nInput: 19\nOutput: true\nExplanation: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def isHappy(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         former = set()\n         while True:\n             h = 0\n             while n > 0:\n                 d = n % 10\n                 h += (d*d)\n                 n = n // 10\n             if h == 1:\n                 return True\n             elif h in former:\n                 return False\n             n = h\n             former.add(n)",
        "inputs": [
            [
                19
            ]
        ],
        "outputs": [
            [
                true
            ]
        ],
        "starter_code": "\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                19
            ],
            [
                "Function Body",
                2,
                19
            ],
            [
                "While Loop Body",
                8,
                19
            ],
            [
                "While Loop Body",
                10,
                13
            ],
            [
                "If Statement Body",
                14,
                17
            ],
            [
                "If Statement Body",
                16,
                17
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n            \"\"\"Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n \nExample 1:\n\nInput: text = \"nlaebolko\"\nOutput: 1\n\nExample 2:\n\nInput: text = \"loonbalxballpoon\"\nOutput: 2\n\nExample 3:\nInput: text = \"leetcode\"\nOutput: 0\n\n \nConstraints:\n\n1 <= text.length <= 10^4\ntext consists of lower case English letters only.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        memo = defaultdict(int)\n        for t in text:\n            if t in 'balon':\n                memo[t] += 1\n        count_once = min(memo['b'], memo['a'], memo['n'])\n        count_twice = min(memo['l'], memo['o'])\n        return min(count_once, count_twice // 2)",
        "inputs": [
            [
                "\"nlaebolko\""
            ]
        ],
        "outputs": [
            [
                1
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                9
            ],
            [
                "Function Body",
                2,
                9
            ],
            [
                "For Loop Body",
                4,
                6
            ],
            [
                "If Statement Body",
                5,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef olympic_ring(string):\n\t    \"\"\"To celebrate the start of the Rio Olympics (and the return of 'the Last Leg' on C4 tonight) this is an Olympic inspired kata.\n\nGiven a string of random letters, you need to examine each. Some letters naturally have 'rings' in them. 'O' is an obvious example, but 'b', 'p', 'e', 'A', etc are all just as applicable. 'B' even has two!! Please note for this kata you can count lower case 'g' as only one ring.\n\nYour job is to count the 'rings' in each letter and divide the total number by 2. Round the answer down. Once you have your final score:\n\nif score is 1 or less,  return 'Not even a medal!';\nif score is 2, return 'Bronze!';\nif score is 3, return 'Silver!';\nif score is more than 3, return 'Gold!';\n\nDots over i's and any other letters don't count as rings.\n    \"\"\"\n",
        "canonical_solution": "def olympic_ring(string):\n    return (['Not even a medal!'] * 2 + ['Bronze!', 'Silver!', 'Gold!'])[min(4, sum(map(\"abdegopqABBDOPQR\".count, string)) // 2)]",
        "inputs": [
            [
                "\"wHjMudLwtoPGocnJ\""
            ],
            [
                "\"eCEHWEPwwnvzMicyaRjk\""
            ],
            [
                "\"JKniLfLW\""
            ]
        ],
        "outputs": [
            [
                "\"Bronze!\""
            ],
            [
                "\"Bronze!\""
            ],
            [
                "\"Not even a medal!\""
            ]
        ],
        "starter_code": "\ndef olympic_ring(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef digits_product(product):\n\t    \"\"\"# Task\n Given an integer `product`, find the smallest positive integer the product of whose digits is equal to product. If there is no such integer, return -1 instead.\n\n# Example\n\n For `product = 1`, the output should be `11`;\n \n `1 x 1 = 1` (1 is not a valid result, because it has only 1 digit)\n \n For `product = 12`, the output should be `26`;\n \n `2 x 6 = 12`\n \n For `product = 19`, the output should be `-1`.\n \n No valid result found.\n \n For `product = 450`, the output should be `2559`.\n \n `2 x 5 x 5 x 9 = 450`\n \n For `product = 581`, the output should be `-1`.\n \n No valid result found. \n \n Someone says the output should be `783`, because `7 x 83 = 581`.\n \n Please note: `83` is not a **DIGIT**.\n \n# Input/Output\n\n\n - `[input]` integer `product`\n\n    Constraints: `0 ≤ product ≤ 600`.\n\n\n - `[output]` a positive integer\n    \"\"\"\n",
        "canonical_solution": "def digits_product(product):\n    if product < 10:\n        return 10 + product\n    n = ''\n    for d in range(9, 1, -1):\n        while not product % d:\n            n += str(d)\n            product //= d\n    return int(n[::-1]) if product == 1 else -1",
        "inputs": [
            [
                12
            ],
            [
                19
            ],
            [
                450
            ]
        ],
        "outputs": [
            [
                26
            ],
            [
                -1
            ],
            [
                2559
            ]
        ],
        "starter_code": "\ndef digits_product(product):\n",
        "scope": [
            [
                "Function Body",
                1,
                9
            ],
            [
                "If Statement Body",
                2,
                3
            ],
            [
                "For Loop Body",
                5,
                8
            ],
            [
                "While Loop Body",
                6,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef OIfXe():\n    \"\"\"Snuke loves \"paper cutting\": he cuts out characters from a newspaper headline and rearranges them to form another string.\nHe will receive a headline which contains one of the strings S_1,...,S_n tomorrow.\nHe is excited and already thinking of what string he will create.\nSince he does not know the string on the headline yet, he is interested in strings that can be created regardless of which string the headline contains.\nFind the longest string that can be created regardless of which string among S_1,...,S_n the headline contains.\nIf there are multiple such strings, find the lexicographically smallest one among them.\n\n-----Constraints-----\n - 1 \\leq n \\leq 50\n - 1 \\leq |S_i| \\leq 50 for every i = 1, ..., n.\n - S_i consists of lowercase English letters (a - z) for every i = 1, ..., n.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nn\nS_1\n...\nS_n\n\n-----Output-----\nPrint the lexicographically smallest string among the longest strings that satisfy the condition.\nIf the answer is an empty string, print an empty line.\n\n-----Sample Input-----\n3\ncbaa\ndaacc\nacacac\n\n-----Sample Output-----\naac\n\nThe strings that can be created from each of cbaa, daacc and acacac, are aa, aac, aca, caa and so forth.\nAmong them, aac, aca and caa are the longest, and the lexicographically smallest of these three is aac.\n    \"\"\"\n",
        "canonical_solution": "\ndef OIfXe():\n    # ひっくりかえすのかとお保ったら180度反転だった\n    n = int(input())\n    d = []\n    for _ in range(n):\n        s = list(input())\n        d.append(s)\n    \n    d = sorted(d, key=lambda dd: len(dd), reverse=True)\n    base = {}\n    for c in d[0]:\n        if c not in base:\n            base[c] = 1\n        else:\n            base[c] += 1\n    \n    for s in d[1:]:\n        tmp = {}\n        for c in s:\n            if c not in tmp:\n                tmp[c] = 1\n            else:\n                tmp[c] += 1\n        for k, v in base.items():\n            if k in tmp and base[k] >= 1:\n                base[k] = min(base[k], tmp[k])\n            else:\n                base[k] = -1\n    ans = []\n    for k, v in base.items():\n        if v > 0:\n            ans.append(k * v)\n    ans = sorted(ans)\n    ans = \"\".join(ans)\n    print(ans)",
        "inputs": [
            "3\ncbaa\ndaacc\nacacac\n",
            "3\na\naa\nb\n"
        ],
        "outputs": [
            "aac\n",
            "\n"
        ],
        "starter_code": "\ndef OIfXe():\n",
        "scope": [
            [
                "Function Body",
                2,
                36
            ],
            [
                "For Loop Body",
                6,
                8
            ],
            [
                "Lambda Expression",
                10,
                10
            ],
            [
                "For Loop Body",
                12,
                16
            ],
            [
                "If Statement Body",
                13,
                16
            ],
            [
                "For Loop Body",
                18,
                29
            ],
            [
                "For Loop Body",
                20,
                24
            ],
            [
                "If Statement Body",
                21,
                24
            ],
            [
                "For Loop Body",
                25,
                29
            ],
            [
                "If Statement Body",
                26,
                29
            ],
            [
                "For Loop Body",
                31,
                33
            ],
            [
                "If Statement Body",
                32,
                33
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef nerdify(txt):\n\t    \"\"\"Make your strings more nerdy: Replace all 'a'/'A' with 4, 'e'/'E' with 3 and 'l' with 1\ne.g. \"Fundamentals\" --> \"Fund4m3nt41s\"\n\n\n```if:csharp\nDocumentation:\nKata.Nerdify Method (String)\n\nNerdifies a string. Returns a copy of the original string with 'a'/'A' characters replaced with '4', 'e'/'E' characters replaced with '3', and 'l' characters replaced with '1'.\n\nSyntax\n\n\npublic\nstatic\nstring Nerdify(\nstring str\n    )\n  \n\n\n\nParameters\n\nstr\n\nType: System.String\nThe string to be nerdified.\n\nReturn Value\n\nType: System.String\n  The nerdified string.\n\n\nExceptions\n\n\n\nException\nCondition\n\nArgumentNullException\nstr is null.\n\n\n\n```\n    \"\"\"\n",
        "canonical_solution": "def nerdify(txt):\n    return txt.translate(str.maketrans(\"aAeEl\", \"44331\"))",
        "inputs": [
            [
                "\"Fund4m3nt41s\""
            ],
            [
                "\"Seven\""
            ],
            [
                "\"Los Angeles\""
            ]
        ],
        "outputs": [
            [
                "\"Fund4m3nt41s\""
            ],
            [
                "\"S3v3n\""
            ],
            [
                "\"Los 4ng313s\""
            ]
        ],
        "starter_code": "\ndef nerdify(txt):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef increasing_numbers(n):\n\t    \"\"\"An `non decreasing` number is one containing no two consecutive digits (left to right), whose the first is higer than the second. For example, 1235 is an non decreasing number, 1229 is too, but 123429 isn't.\n\nWrite a function that finds the number of non decreasing numbers up to `10**N` (exclusive) where N is the input of your function. For example, if `N=3`, you have to count all non decreasing numbers from 0 to 999.\n\n You'll definitely need something smarter than brute force for large values of N!\n    \"\"\"\n",
        "canonical_solution": "def increasing_numbers(d):\n    s = 1\n    for i in range(1,10): s=s*(i+d)//i\n    return s",
        "inputs": [
            [
                0
            ],
            [
                1
            ],
            [
                2
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                10
            ],
            [
                55
            ]
        ],
        "starter_code": "\ndef increasing_numbers(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "For Loop Body",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef iepvK():\n    \"\"\"You are given two positive integers $a$ and $b$. In one move you can increase $a$ by $1$ (replace $a$ with $a+1$). Your task is to find the minimum number of moves you need to do in order to make $a$ divisible by $b$. It is possible, that you have to make $0$ moves, as $a$ is already divisible by $b$. You have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$).\n\n\n-----Output-----\n\nFor each test case print the answer — the minimum number of moves you need to do in order to make $a$ divisible by $b$.\n\n\n-----Example-----\nInput\n5\n10 4\n13 9\n100 13\n123 456\n92 46\n\nOutput\n2\n5\n4\n333\n0\n    \"\"\"\n",
        "canonical_solution": "\ndef iepvK():\n    q = int(input())\n    for _ in range(q):\n        a, b = list(map(int, input().split()))\n        print((b - a % b) % b)\n    ",
        "inputs": [
            "5\n10 4\n13 9\n100 13\n123 456\n92 46\n",
            "1\n914 78\n",
            "1\n2232 7\n"
        ],
        "outputs": [
            "2\n5\n4\n333\n0\n",
            "22\n",
            "1\n"
        ],
        "starter_code": "\ndef iepvK():\n",
        "scope": [
            [
                "Function Body",
                2,
                6
            ],
            [
                "For Loop Body",
                4,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef aplYt():\n    \"\"\"Petya has an array $a$ consisting of $n$ integers. He wants to remove duplicate (equal) elements.\n\nPetya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 50$) — the number of elements in Petya's array.\n\nThe following line contains a sequence $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 1\\,000$) — the Petya's array.\n\n\n-----Output-----\n\nIn the first line print integer $x$ — the number of elements which will be left in Petya's array after he removed the duplicates.\n\nIn the second line print $x$ integers separated with a space — Petya's array after he removed the duplicates. For each unique element only the rightmost entry should be left.\n\n\n-----Examples-----\nInput\n6\n1 5 5 1 6 1\n\nOutput\n3\n5 6 1 \n\nInput\n5\n2 4 2 4 4\n\nOutput\n2\n2 4 \n\nInput\n5\n6 6 6 6 6\n\nOutput\n1\n6 \n\n\n\n-----Note-----\n\nIn the first example you should remove two integers $1$, which are in the positions $1$ and $4$. Also you should remove the integer $5$, which is in the position $2$.\n\nIn the second example you should remove integer $2$, which is in the position $1$, and two integers $4$, which are in the positions $2$ and $4$.\n\nIn the third example you should remove four integers $6$, which are in the positions $1$, $2$, $3$ and $4$.\n    \"\"\"\n",
        "canonical_solution": "\ndef aplYt():\n    n=int(input())\n    ar=list(map(int,input().split()))\n    s=set()\n    a=[]\n    for x in ar[::-1]:\n        if x not in s:\n            a.append(x)\n        s.add(x)\n    print(len(a))\n    print(*a[::-1])",
        "inputs": [
            "6\n1 5 5 1 6 1\n",
            "5\n2 4 2 4 4\n",
            "5\n6 6 6 6 6\n"
        ],
        "outputs": [
            "3\n5 6 1 \n",
            "2\n2 4 \n",
            "1\n6 \n"
        ],
        "starter_code": "\ndef aplYt():\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "For Loop Body",
                7,
                10
            ],
            [
                "If Statement Body",
                8,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef next_happy_year(year):\n\t    \"\"\"# Scenario \n\n*You're saying good-bye your best friend* , **_See you next happy year_** . \n\n**_Happy Year_** *is the year with only distinct digits* , (e.g) **_2018_**\n\n___\n# Task\n\n**_Given_** a year, **_Find_** **_The next happy year_** or **_The closest year You'll see your best friend_**      ![!alt](https://i.imgur.com/mdX8dJP.png) ![!alt](https://i.imgur.com/mdX8dJP.png)\n\n___\n# Notes\n\n* **_Year_** Of Course always **_Positive_** .\n* **_Have no fear_** , *It is guaranteed that the answer exists* . \n* **_It's not necessary_** *that the year passed to the function is Happy one* .   \n* **_Input Year with in range_** *(1000  ≤  y  ≤  9000)*\n\n____\n# Input >> Output Examples:\n\n```\nnextHappyYear (7712) ==> return (7801)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *7801* . \n___\n\n```\nnextHappyYear (8989) ==> return (9012)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *9012* . \n___\n\n```\nnextHappyYear (1001) ==> return (1023)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *1023* .\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n    \"\"\"\n",
        "canonical_solution": "def next_happy_year(year):\n    year += 1\n    \n    while len(set(str(year))) != 4:\n        year += 1\n    \n    return year",
        "inputs": [
            [
                1001
            ],
            [
                1123
            ],
            [
                2001
            ]
        ],
        "outputs": [
            [
                1023
            ],
            [
                1203
            ],
            [
                2013
            ]
        ],
        "starter_code": "\ndef next_happy_year(year):\n",
        "scope": [
            [
                "Function Body",
                1,
                7
            ],
            [
                "While Loop Body",
                4,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef days_represented(trips):\n\t    \"\"\"How many days are we represented in a foreign country?\n\nMy colleagues make business trips to a foreign country. We must find the number of days our company is represented in a country. Every day that one or more colleagues are present in the country is a day that the company is represented. A single day cannot count for more than one day.\n\nWrite a function that recieves a list of pairs and returns the number of days that the company is represented in the foreign country. The first number of the pair is the number of the day of arrival and the second number of the pair is the day of departure of someone who travels, i.e. 1 january is number 1 and 31 of december is 365.\n\nExample:\n```python\ndays_represented([[10,17],[200,207]])\n```\n\nReturns 16 because there are two trips of 8 days, which add up to 16.\n\nHappy coding and rank this kata if you wish ;-)\n    \"\"\"\n",
        "canonical_solution": "def days_represented(a):\n    return len({i for x, y in a for i in range(x, y + 1)})",
        "inputs": [
            [
                [
                    [
                        10,
                        15
                    ],
                    [
                        25,
                        35
                    ]
                ]
            ],
            [
                [
                    [
                        2,
                        8
                    ],
                    [
                        220,
                        229
                    ],
                    [
                        10,
                        16
                    ]
                ]
            ]
        ],
        "outputs": [
            [
                17
            ],
            [
                24
            ]
        ],
        "starter_code": "\ndef days_represented(trips):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Set Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef vowel_2_index(string):\n\t    \"\"\"Write a function \n\n```python\nvowel_2_index```\n\nthat takes in a string and replaces all the vowels [a,e,i,o,u] with their respective positions within that string. \nE.g: \n\n```python\nvowel_2_index('this is my string') == 'th3s 6s my str15ng'\nvowel_2_index('Codewars is the best site in the world') == 'C2d4w6rs 10s th15 b18st s23t25 27n th32 w35rld'\nvowel_2_index('') == ''\n```\n Your function should be case insensitive to the vowels.\n    \"\"\"\n",
        "canonical_solution": "def vowel_2_index(string):\n    vowels = 'aeiouAEIOU'\n    return ''.join(x if x not in vowels else str(n + 1) for n,x in enumerate(string))",
        "inputs": [
            [
                "\"this is my string\""
            ],
            [
                "\"Codewars is the best site in the world\""
            ],
            [
                "\"Tomorrow is going to be raining\""
            ]
        ],
        "outputs": [
            [
                "\"th3s 6s my str15ng\""
            ],
            [
                "\"C2d4w6rs 10s th15 b18st s23t25 27n th32 w35rld\""
            ],
            [
                "\"T2m4rr7w 10s g1415ng t20 b23 r2627n29ng\""
            ]
        ],
        "starter_code": "\ndef vowel_2_index(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "Generator Expression",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef caeser(message, key):\n\t    \"\"\"You have invented a time-machine which has taken you back to ancient Rome. Caeser is impressed with your programming skills and has appointed you to be the new information security officer.\n\nCaeser has ordered you to write a Caeser cipher to prevent Asterix and Obelix from reading his emails.\n\nA Caeser cipher shifts the letters in a message by the value dictated by the encryption key. Since Caeser's emails are very important, he wants all encryptions to have upper-case output, for example:\n\nIf key = 3\n\"hello\" -> KHOOR\nIf key = 7\n\"hello\" -> OLSSV\n\nInput will consist of the message to be encrypted and the encryption key.\n    \"\"\"\n",
        "canonical_solution": "def caeser(message, key):\n    return ''.join(chr(65 + (ord(c.upper()) + key - 65) % 26) if c.isalpha() else c for c in message)",
        "inputs": [
            [
                "\"This is a message\"",
                0
            ],
            [
                "\"who are you?\"",
                18
            ],
            [
                "\"..5tyu..\"",
                25
            ]
        ],
        "outputs": [
            [
                "\"THIS IS A MESSAGE\""
            ],
            [
                "\"OZG SJW QGM?\""
            ],
            [
                "\"..5SXT..\""
            ]
        ],
        "starter_code": "\ndef caeser(message, key):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef string_to_number(s):\n\t    \"\"\"Note: This kata is inspired by [Convert a Number to a String!](http://www.codewars.com/kata/convert-a-number-to-a-string/). Try that one too.\n\n## Description\n\nWe need a function that can transform a string into a number. What ways of achieving this do you know?\n\nNote: Don't worry, all inputs will be strings, and every string is a perfectly valid representation of an integral number.\n\n## Examples\n\n```python\nstringToNumber(\"1234\") == 1234\nstringToNumber(\"605\" ) == 605\nstringToNumber(\"1405\") == 1405\nstringToNumber(\"-7\"  ) == -7\n```\n    \"\"\"\n",
        "canonical_solution": "def string_to_number(s):\n    return int(s)",
        "inputs": [
            [
                "\"4\""
            ]
        ],
        "outputs": [
            [
                4
            ]
        ],
        "starter_code": "\ndef string_to_number(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef UGtpA():\n    \"\"\"You are given an image A composed of N rows and N columns of pixels, and a template image B composed of M rows and M columns of pixels.\n\nA pixel is the smallest element of an image, and in this problem it is a square of size 1×1.\n\nAlso, the given images are binary images, and the color of each pixel is either white or black.  \nIn the input, every pixel is represented by a character: . corresponds to a white pixel, and # corresponds to a black pixel.\n\nThe image A is given as N strings A_1,...,A_N.\n\nThe j-th character in the string A_i corresponds to the pixel at the i-th row and j-th column of the image A (1≦i,j≦N).\n\nSimilarly, the template image B is given as M strings B_1,...,B_M.\n\nThe j-th character in the string B_i corresponds to the pixel at the i-th row and j-th column of the template image B (1≦i,j≦M).  \nDetermine whether the template image B is contained in the image A when only parallel shifts can be applied to the images.  \n\n-----Constraints-----\n - 1≦M≦N≦50 \n - A_i is a string of length N consisting of # and ..\n - B_i is a string of length M consisting of # and ..\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN M\nA_1\nA_2\n:  \nA_N\nB_1\nB_2\n:  \nB_M\n\n-----Output-----\nPrint Yes if the template image B is contained in the image A. Print No otherwise.\n\n-----Sample Input-----\n3 2\n#.#\n.#.\n#.#\n#.\n.#\n\n-----Sample Output-----\nYes\n\nThe template image B is identical to the upper-left 2 × 2 subimage and the lower-right 2 × 2 subimage of A. Thus, the output should be Yes.\n    \"\"\"\n",
        "canonical_solution": "\ndef UGtpA():\n    n, m = map(int, input().split())\n    a = [\"\" for _ in range(n)]\n    b = [\"\" for _ in range(m)]\n    for i in range(n):\n        a[i] = str(input())\n    for i in range(m):\n        b[i] = str(input())\n    def check(ini_x, ini_y):\n        nonlocal n, m, a, b\n        for x in range(m):\n            for y in range(m):\n                if a[ini_x + x][ini_y + y] != b[x][y]:\n                    return False\n        return True\n    for i in range(n - m + 1):\n        for j in range(n - m + 1):\n            if check(i, j):\n                print(\"Yes\")\n                return\n    print(\"No\")",
        "inputs": [
            "3 2\n#.#\n.#.\n#.#\n#.\n.#\n",
            "4 1\n....\n....\n....\n....\n#\n",
            "1 1\n.\n.\n"
        ],
        "outputs": [
            "Yes\n",
            "No\n",
            "Yes\n"
        ],
        "starter_code": "\ndef UGtpA():\n",
        "scope": [
            [
                "Function Body",
                2,
                22
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "Function Body",
                10,
                16
            ],
            [
                "For Loop Body",
                12,
                15
            ],
            [
                "For Loop Body",
                13,
                15
            ],
            [
                "If Statement Body",
                14,
                15
            ],
            [
                "For Loop Body",
                17,
                21
            ],
            [
                "For Loop Body",
                18,
                21
            ],
            [
                "If Statement Body",
                19,
                21
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef RqTPM():\n    \"\"\"Snuke loves puzzles.\nToday, he is working on a puzzle using S- and c-shaped pieces.\nIn this puzzle, you can combine two c-shaped pieces into one S-shaped piece, as shown in the figure below:\nSnuke decided to create as many Scc groups as possible by putting together one S-shaped piece and two c-shaped pieces.\nFind the maximum number of Scc groups that can be created when Snuke has N S-shaped pieces and M c-shaped pieces.\n\n-----Constraints-----\n - 1 ≤ N,M ≤ 10^{12}\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN M\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n1 6\n\n-----Sample Output-----\n2\n\nTwo Scc groups can be created as follows:\n - Combine two c-shaped pieces into one S-shaped piece\n - Create two Scc groups, each from one S-shaped piece and two c-shaped pieces\n    \"\"\"\n",
        "canonical_solution": "\ndef RqTPM():\n    n, m = [int(x) for x in input().split()]\n    ans = min(n, m // 2)\n    ans += (m - ans * 2) // 4\n    print(ans)",
        "inputs": [
            "1 6\n",
            "12345 678901\n"
        ],
        "outputs": [
            "2\n",
            "175897\n"
        ],
        "starter_code": "\ndef RqTPM():\n",
        "scope": [
            [
                "Function Body",
                2,
                6
            ],
            [
                "List Comprehension",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef rNsnM():\n    \"\"\"Our world is one-dimensional, and ruled by two empires called Empire A and Empire B.\nThe capital of Empire A is located at coordinate X, and that of Empire B is located at coordinate Y.\nOne day, Empire A becomes inclined to put the cities at coordinates x_1, x_2, ..., x_N under its control, and Empire B becomes inclined to put the cities at coordinates y_1, y_2, ..., y_M under its control.\nIf there exists an integer Z that satisfies all of the following three conditions, they will come to an agreement, but otherwise war will break out.\n - X < Z \\leq Y\n - x_1, x_2, ..., x_N < Z\n - y_1, y_2, ..., y_M \\geq Z\nDetermine if war will break out.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N, M \\leq 100\n - -100 \\leq X < Y \\leq 100\n - -100 \\leq x_i, y_i \\leq 100\n - x_1, x_2, ..., x_N \\neq X\n - x_i are all different.\n - y_1, y_2, ..., y_M \\neq Y\n - y_i are all different.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M X Y\nx_1 x_2 ... x_N\ny_1 y_2 ... y_M\n\n-----Output-----\nIf war will break out, print War; otherwise, print No War.\n\n-----Sample Input-----\n3 2 10 20\n8 15 13\n16 22\n\n-----Sample Output-----\nNo War\n\nThe choice Z = 16 satisfies all of the three conditions as follows, thus they will come to an agreement.\n - X = 10 < 16 \\leq 20 = Y\n - 8, 15, 13 < 16\n - 16, 22 \\geq 16\n    \"\"\"\n",
        "canonical_solution": "\ndef rNsnM():\n    def readinput():\n        n,m,x,y=list(map(int,input().split()))\n        xx=list(map(int,input().split()))\n        yy=list(map(int,input().split()))\n        return n,m,x,y,xx,yy\n    \n    def main(n,m,x,y,xx,yy):\n        xx.append(x)\n        yy.append(y)\n        xx.sort()\n        yy.sort()\n        if xx[-1]<yy[0]:\n            return 'No War'\n        else:\n            return 'War'\n    \n    def __starting_point():\n        n,m,x,y,xx,yy=readinput()\n        ans=main(n,m,x,y,xx,yy)\n        print(ans)\n    \n    __starting_point()",
        "inputs": [
            "3 2 10 20\n8 15 13\n16 22\n",
            "4 2 -48 -1\n-20 -35 -91 -23\n-22 66\n",
            "5 3 6 8\n-10 3 1 5 -100\n100 6 14\n"
        ],
        "outputs": [
            "No War\n",
            "War\n",
            "War\n"
        ],
        "starter_code": "\ndef rNsnM():\n",
        "scope": [
            [
                "Function Body",
                2,
                24
            ],
            [
                "Function Body",
                3,
                7
            ],
            [
                "Function Body",
                9,
                17
            ],
            [
                "If Statement Body",
                14,
                17
            ],
            [
                "Function Body",
                19,
                22
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef words_to_sentence(words):\n\t    \"\"\"Write function ```wordsToSentence``` which will create a string from a list of strings, separated by space.\n\nExample:\n\n```[\"hello\", \"world\"] -> \"hello world\"```\n    \"\"\"\n",
        "canonical_solution": "words_to_sentence=' '.join",
        "inputs": [
            [
                [
                    "bacon",
                    "is",
                    "delicious"
                ]
            ]
        ],
        "outputs": [
            [
                "\"bacon is delicious\""
            ]
        ],
        "starter_code": "\ndef words_to_sentence(words):\n",
        "scope": [],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef palindrome_pairs(words):\n\t    \"\"\"Given a list of unique words. Find all pairs of distinct indices (i, j) in the given list so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\n\nExamples:\n\nNon-string inputs should be converted to strings.\n\nReturn an array of arrays containing pairs of distinct indices that form palindromes. Pairs should be returned in the order they appear in the original list.\n    \"\"\"\n",
        "canonical_solution": "def palindrome_pairs(w):\n  return [[i, j] for i in range(len(w)) for j in range(len(w)) if str(w[i])+str(w[j])==(str(w[i])+str(w[j]))[::-1] and i!=j]",
        "inputs": [
            [
                [
                    "bat",
                    "tab",
                    "cat"
                ]
            ],
            [
                [
                    "dog",
                    "cow",
                    "tap",
                    "god",
                    "pat"
                ]
            ],
            [
                [
                    "abcd",
                    "dcba",
                    "lls",
                    "s",
                    "sssll"
                ]
            ]
        ],
        "outputs": [
            [
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ]
                ]
            ],
            [
                [
                    [
                        0,
                        3
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        0
                    ],
                    [
                        4,
                        2
                    ]
                ]
            ],
            [
                [
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        2,
                        4
                    ],
                    [
                        3,
                        2
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef palindrome_pairs(words):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef is_balanced(source, caps):\n\t    \"\"\"### Background\n\nWe **all** know about \"balancing parentheses\" (plus brackets, braces and chevrons) and even balancing characters that are identical.  \n\nRead that last sentence again, I balanced different characters and identical characters twice and you didn't even notice... :)\n\n### Kata\nYour challenge in this kata is to write a piece of code to validate that a supplied string is balanced.\n\nYou must determine if all that is open is then closed, and nothing is closed which is not already open!\n\nYou will be given a string to validate, and a second string, where each pair of characters defines an opening and closing sequence that needs balancing.\n\nYou may assume that the second string always has an even number of characters.\n\n### Example\n```python\n# In this case '(' opens a section, and ')' closes a section\nis_balanced(\"(Sensei says yes!)\", \"()\")       # => True\nis_balanced(\"(Sensei says no!\", \"()\")         # => False\n\n# In this case '(' and '[' open a section, while ')' and ']' close a section\nis_balanced(\"(Sensei [says] yes!)\", \"()[]\")   # => True\nis_balanced(\"(Sensei [says) no!]\", \"()[]\")    # => False\n\n# In this case a single quote (') both opens and closes a section\nis_balanced(\"Sensei says 'yes'!\", \"''\")       # => True\nis_balanced(\"Sensei say's no!\", \"''\")         # => False\n```\n    \"\"\"\n",
        "canonical_solution": "def is_balanced(s, caps):\n    stack = []\n    openers, closers = caps[::2], caps[1::2]\n    for char in s:\n        if char in openers:\n            if char in closers and stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char in closers:\n            if not stack or openers[closers.index(char)] != stack[-1]:\n                return False\n            else:\n                stack.pop()\n    return not stack",
        "inputs": [
            [
                "\"(Sensei says yes!)\"",
                "\"()\""
            ],
            [
                "\"(Sensei says no!\"",
                "\"()\""
            ],
            [
                "\"(Sensei [says] yes!)\"",
                "\"()[]\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                true
            ]
        ],
        "starter_code": "\ndef is_balanced(source, caps):\n",
        "scope": [
            [
                "Function Body",
                1,
                15
            ],
            [
                "For Loop Body",
                4,
                14
            ],
            [
                "If Statement Body",
                5,
                14
            ],
            [
                "If Statement Body",
                6,
                9
            ],
            [
                "If Statement Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def maxPower(self, s: str) -> int:\n            \"\"\"Given a string s, the power of the string is the maximum length of a non-empty substring that contains only one unique character.\nReturn the power of the string.\n \nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\n \nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def maxPower(self, s: str) -> int:\n        n = len(s) \n        count = 0\n        res = s[0] \n        cur_count = 1\n  \n        # Traverse string except  \n        # last character \n        for i in range(n): \n          \n            # If current character  \n            # matches with next \n            if (i < n - 1 and \n                s[i] == s[i + 1]): \n                cur_count += 1\n  \n            # If doesn't match, update result \n            # (if required) and reset count \n            else: \n                if cur_count > count: \n                    count = cur_count \n                    res = s[i] \n                cur_count = 1\n        return count \n       \n        \n        \n",
        "inputs": [
            [
                "\"leetcode\""
            ]
        ],
        "outputs": [
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def maxPower(self, s: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                25
            ],
            [
                "Function Body",
                2,
                25
            ],
            [
                "For Loop Body",
                10,
                24
            ],
            [
                "If Statement Body",
                14,
                24
            ],
            [
                "If Statement Body",
                21,
                23
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef day_plan(hours, tasks, duration):\n\t    \"\"\"*SCHEDULE YOUR DA(RRA)Y*\n        \nThe best way to have a productive day is to plan out your work schedule. Given the following three inputs, please create an an array of time alloted to work, broken up with time alloted with breaks:\n        \nInput 1: Hours - Number of hours available to you to get your work done! \nInput 2: Tasks - How many tasks you have to do througout the day\nInput 3: Duration (minutes)- How long each of your tasks will take to complete\nCriteria to bear in mind:\n- Your schedule should start with work and end with work.\n- It should also be in minutes, rounded to the nearest whole minute. \n- If your work is going to take more time than you have, return \"You're not sleeping tonight!\"\nExample:\n\n```python\nday_plan(8, 5, 30) == [ 30, 82, 30, 82, 30, 82, 30, 82, 30 ]\nday_plan(3, 5, 60) == \"You're not sleeping tonight!\"\n```\n    \"\"\"\n",
        "canonical_solution": "def day_plan(hours, tasks, duration):\n    td, hm, tmo = tasks * duration, hours * 60, tasks - 1\n    if td > hm: return \"You're not sleeping tonight!\"\n    arr = [0] * (tasks + tmo)\n    arr[::2], arr[1::2] = [duration] * tasks, [round((hm - td) / (tmo or 1))] * tmo\n    return arr\n",
        "inputs": [
            [
                8,
                5,
                30
            ],
            [
                3,
                5,
                60
            ],
            [
                2,
                2,
                60
            ]
        ],
        "outputs": [
            [
                [
                    30,
                    82,
                    30,
                    82,
                    30,
                    82,
                    30,
                    82,
                    30
                ]
            ],
            [
                "\"You're not sleeping tonight!\""
            ],
            [
                [
                    60,
                    0,
                    60
                ]
            ]
        ],
        "starter_code": "\ndef day_plan(hours, tasks, duration):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "If Statement Body",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef basereduct(x):\n\t    \"\"\"# Base reduction\n\n## Input\n\nA positive integer:\n```\n0 < n < 1000000000\n```\n\n## Output\n\nThe end result of the base reduction.\n\nIf it cannot be fully reduced (reduced down to a single-digit number), return -1.\n\nAssume that if 150 conversions from base 11 take place in a row, the number cannot be fully reduced.\n\n## Description\n\nBase reduction is a process where a number is inputted, repeatedly converted into another base, and then outputted if it cannot be reduced anymore. If it cannot be fully reduced, return -1.\n\nDuring the base conversions, the number is converted from the lowest base it can be converted from into base 10. For example, 123 would be converted from base 4 to base 10, since base 4 is the lowest base that 123 can be in (123 base 3 is impossible; in base 3, there is no digit 3).\n\nIf the lowest possible base the number can be converted into is 10, convert the number from base 11 to base 10. For example, 53109 would be converted from base 11 to base 10, since base 10 is the lowest base it can be in.\n\nIn the end, you should get a number that cannot be reduced by this process (a single digit number).\n\n## Example\n\nStarting with 5312:\n```\n5312 base 6 = 1196 base 10\n1196 base 11 = 1557 base 10\n1557 base 8 = 879 base 10\n879 base 11 = 1054 base 10\n1054 base 6 = 250 base 10\n250 base 6 = 102 base 10\n102 base 3 = 11 base 10\n11 base 2 = 3 base 10\n```\nThe output would be 3.\n    \"\"\"\n",
        "canonical_solution": "def basereduct(x):\n    for _ in range(150):\n        x = int(str(x), int(max(str(x))) + 1 + ('9' in str(x)))\n        if x < 10: return x\n    return -1",
        "inputs": [
            [
                10
            ],
            [
                5
            ],
            [
                7
            ]
        ],
        "outputs": [
            [
                2
            ],
            [
                5
            ],
            [
                7
            ]
        ],
        "starter_code": "\ndef basereduct(x):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "For Loop Body",
                2,
                4
            ],
            [
                "If Statement Body",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef get_section_id(scroll, sizes):\n\t    \"\"\"Your website is divided vertically in sections, and each can be of different size (height).  \nYou need to establish the section index (starting at `0`) you are at, given the `scrollY` and `sizes` of all sections.  \nSections start with `0`, so if first section is `200` high, it takes `0-199` \"pixels\" and second starts at `200`.\n\n### Example:\n\n`getSectionIdFromScroll( 300, [300,200,400,600,100] )`\n\nwill output number `1` as it's the second section.\n\n`getSectionIdFromScroll( 1600, [300,200,400,600,100] )`\n\nwill output number `-1` as it's past last section.\n\nGiven the `scrollY` integer (always non-negative) and an array of non-negative integers (with at least one element), calculate the index (starting at `0`) or `-1` if `scrollY` falls beyond last section (indication of an error).\n    \"\"\"\n",
        "canonical_solution": "def get_section_id(scroll, sizes):\n    c = 0\n    for idx, s in enumerate(sizes):\n        c += s\n        if scroll < c: return idx\n    return -1",
        "inputs": [
            [
                1,
                [
                    300,
                    200,
                    400,
                    600,
                    100
                ]
            ],
            [
                299,
                [
                    300,
                    200,
                    400,
                    600,
                    100
                ]
            ],
            [
                300,
                [
                    300,
                    200,
                    400,
                    600,
                    100
                ]
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                0
            ],
            [
                1
            ]
        ],
        "starter_code": "\ndef get_section_id(scroll, sizes):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "For Loop Body",
                3,
                5
            ],
            [
                "If Statement Body",
                5,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef matrixfy(st):\n\t    \"\"\"Given a name, turn that name into a perfect square matrix (nested array with the amount of arrays equivalent to the length of each array). \n\nYou will need to add periods (`.`) to the end of the name if necessary, to turn it into a matrix. \n\nIf the name has a length of 0, return `\"name must be at least one letter\"`\n\n## Examples\n\n\"Bill\" ==> [ [\"B\", \"i\"],\n             [\"l\", \"l\"] ]\n\n\"Frank\" ==> [ [\"F\", \"r\", \"a\"],\n              [\"n\", \"k\", \".\"],\n              [\".\", \".\", \".\"] ]\n    \"\"\"\n",
        "canonical_solution": "from math import ceil\n\ndef matrixfy(s):\n    if not s: return \"name must be at least one letter\"\n    x  = ceil(len(s)**.5)\n    it = iter(s.ljust(x*x,'.'))\n    return [ [next(it) for _ in range(x)] for _ in range(x)]",
        "inputs": [
            [
                "\"\""
            ],
            [
                "\"G\""
            ],
            [
                "\"Beyonce\""
            ]
        ],
        "outputs": [
            [
                "\"name must be at least one letter\""
            ],
            [
                [
                    [
                        "G"
                    ]
                ]
            ],
            [
                [
                    [
                        "B",
                        "e",
                        "y"
                    ],
                    [
                        "o",
                        "n",
                        "c"
                    ],
                    [
                        "e",
                        ".",
                        "."
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef matrixfy(st):\n",
        "scope": [
            [
                "Function Body",
                3,
                7
            ],
            [
                "If Statement Body",
                4,
                4
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "List Comprehension",
                7,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef ATCMg():\n    \"\"\"There are S sheep and W wolves.\nIf the number of wolves is greater than or equal to that of sheep, the wolves will attack the sheep.\nIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\n-----Constraints-----\n - 1 \\leq S \\leq 100\n - 1 \\leq W \\leq 100\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS W\n\n-----Output-----\nIf the wolves will attack the sheep, print unsafe; otherwise, print safe.\n\n-----Sample Input-----\n4 5\n\n-----Sample Output-----\nunsafe\n\nThere are four sheep and five wolves. The number of wolves is not less than that of sheep, so they will attack them.\n    \"\"\"\n",
        "canonical_solution": "\ndef ATCMg():\n    S,W=list(map(int,input().split()))\n    if W<S:\n        print('safe')\n    else:\n        print('unsafe')\n    ",
        "inputs": [
            "4 5\n",
            "100 2\n",
            "10 10\n"
        ],
        "outputs": [
            "unsafe\n",
            "safe\n",
            "unsafe\n"
        ],
        "starter_code": "\ndef ATCMg():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "If Statement Body",
                4,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef rapeN():\n    \"\"\"There are N people, conveniently numbered 1 through N.\nThey were standing in a row yesterday, but now they are unsure of the order in which they were standing.\nHowever, each person remembered the following fact: the absolute difference of the number of the people who were standing to the left of that person, and the number of the people who were standing to the right of that person.\nAccording to their reports, the difference above for person i is A_i.\nBased on these reports, find the number of the possible orders in which they were standing.\nSince it can be extremely large, print the answer modulo 10^9+7.\nNote that the reports may be incorrect and thus there may be no consistent order.\nIn such a case, print 0.\n\n-----Constraints-----\n - 1≦N≦10^5\n - 0≦A_i≦N-1\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nA_1 A_2 ... A_N\n\n-----Output-----\nPrint the number of the possible orders in which they were standing, modulo 10^9+7.\n\n-----Sample Input-----\n5\n2 4 4 0 2\n\n-----Sample Output-----\n4\n\nThere are four possible orders, as follows:\n - 2,1,4,5,3\n - 2,5,4,1,3\n - 3,1,4,5,2\n - 3,5,4,1,2\n    \"\"\"\n",
        "canonical_solution": "\ndef rapeN():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    a.sort()\n    mod = 10 ** 9 + 7\n    \n    def p(p):\n      ans = 1\n      for i in range(p):\n        ans *= 2\n        ans %= mod\n      return ans\n    \n    if n % 2 == 1:\n      res = True\n      for i in range(n):\n        if a[i] != ((i + 1) // 2) * 2:\n          res = False\n      if res:\n        print(p(n // 2))\n      else:\n        print(0)\n        \n    else:\n      res = True\n      for i in range(n):\n        if a[i] != (i // 2) * 2 + 1:\n          res = False\n      if res:\n        print(p(n // 2))\n      else:\n        print(0)",
        "inputs": [
            "5\n2 4 4 0 2\n",
            "7\n6 4 0 2 4 0 2\n",
            "8\n7 5 1 1 7 3 5 3\n"
        ],
        "outputs": [
            "4\n",
            "0\n",
            "16\n"
        ],
        "starter_code": "\ndef rapeN():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "Function Body",
                8,
                13
            ],
            [
                "For Loop Body",
                10,
                12
            ],
            [
                "If Statement Body",
                15,
                33
            ],
            [
                "For Loop Body",
                17,
                19
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "If Statement Body",
                20,
                23
            ],
            [
                "For Loop Body",
                27,
                29
            ],
            [
                "If Statement Body",
                28,
                29
            ],
            [
                "If Statement Body",
                30,
                33
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef get_drink_by_profession(param):\n\t    \"\"\"Write a function `getDrinkByProfession`/`get_drink_by_profession()` that receives as input parameter a string, and produces outputs according to the following table:\n\n\n\n\nInput\nOutput\n\n\n\"Jabroni\"\n\"Patron Tequila\"\n\n\n\"School Counselor\"\n\"Anything with Alcohol\"\n\n\n \"Programmer\"\n \"Hipster Craft Beer\"\n\n\n \"Bike Gang Member\"\n\"Moonshine\" \n\n\n \"Politician\"\n\"Your tax dollars\" \n\n\n \"Rapper\"\n\"Cristal\" \n\n\n *anything else* \n\"Beer\" \n\n\n\n\n\nNote: *anything else* is the default case: if the input to the function is not any of the values in the table, then the return value should be \"Beer.\"\n\nMake sure you cover the cases where certain words do not show up with correct capitalization. For example, getDrinkByProfession(\"pOLitiCIaN\") should still return \"Your tax dollars\".\n    \"\"\"\n",
        "canonical_solution": "d = {\n    \"jabroni\": \"Patron Tequila\",\n    \"school counselor\": \"Anything with Alcohol\",\n    \"programmer\": \"Hipster Craft Beer\",\n    \"bike gang member\": \"Moonshine\",\n    \"politician\": \"Your tax dollars\",\n    \"rapper\": \"Cristal\"\n}\n\ndef get_drink_by_profession(s):\n    return d.get(s.lower(), \"Beer\")",
        "inputs": [
            [
                "\"jabrOni\""
            ],
            [
                "\"scHOOl counselor\""
            ],
            [
                "\"prOgramMer\""
            ]
        ],
        "outputs": [
            [
                "\"Patron Tequila\""
            ],
            [
                "\"Anything with Alcohol\""
            ],
            [
                "\"Hipster Craft Beer\""
            ]
        ],
        "starter_code": "\ndef get_drink_by_profession(param):\n",
        "scope": [
            [
                "Function Body",
                10,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef make_string(s):\n\t    \"\"\"In this exercise, a string is passed to a method and a new string has to be returned with the first character of each word in the string.\n\nFor example:\n\n```\n\"This Is A Test\" ==> \"TIAT\"\n```\n    \"\"\"\n",
        "canonical_solution": "def make_string(s):\n    return ''.join(a[0] for a in s.split())\n",
        "inputs": [
            [
                "\"sees eyes xray yoat\""
            ],
            [
                "\"brown eyes are nice\""
            ],
            [
                "\"cars are very nice\""
            ]
        ],
        "outputs": [
            [
                "\"sexy\""
            ],
            [
                "\"bean\""
            ],
            [
                "\"cavn\""
            ]
        ],
        "starter_code": "\ndef make_string(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef odd_not_prime(n):\n\t    \"\"\"For \"x\", determine how many positive integers less than or equal to \"x\" are odd but not prime. Assume \"x\" is an integer between 1 and 10000.\n\nExample: 5 has three odd numbers (1,3,5) and only the number 1 is not prime, so the answer is 1\n\nExample: 10 has five odd numbers (1,3,5,7,9) and only 1 and 9 are not prime, so the answer is 2\n    \"\"\"\n",
        "canonical_solution": "def not_prime(x):\n    if x == 1: return True\n    for y in range(2, int(x ** 0.5) + 1):\n        if x % y == 0:\n            return True\n    return False\ndef odd_not_prime(n):\n    return sum(not_prime(x) for x in range(1, n + 1, 2))",
        "inputs": [
            [
                5
            ],
            [
                10
            ],
            [
                99
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                2
            ],
            [
                26
            ]
        ],
        "starter_code": "\ndef odd_not_prime(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "If Statement Body",
                2,
                2
            ],
            [
                "For Loop Body",
                3,
                5
            ],
            [
                "If Statement Body",
                4,
                5
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Generator Expression",
                8,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef array_manip(array):\n\t    \"\"\"Given an array of positive integers, replace every element with the least greater element to its right.\n If there is no greater element to its right, replace it with -1. For instance, given the array \n \n `[8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28]`,\n \n the desired output is \n \n `[18, 63, 80, 25, 32, 43, 80, 93, 80, 25, 93, -1, 28, -1, -1]`.\n\nYour task is to create a function \"arrayManip()\" that takes in an array as its argument, manipulates the array as described above, then return the resulting array.\n\nNote: Return a new array, rather than modifying the passed array.\n    \"\"\"\n",
        "canonical_solution": "def array_manip(array):\n    return [min([a for a in array[i+1:] if a > array[i]], default=-1) for i in range(len(array))]",
        "inputs": [
            [
                [
                    8,
                    58,
                    71,
                    18,
                    31,
                    32,
                    63,
                    92,
                    43,
                    3,
                    91,
                    93,
                    25,
                    80,
                    28
                ]
            ],
            [
                [
                    2,
                    4,
                    18,
                    16,
                    7,
                    3,
                    9,
                    13,
                    18,
                    10
                ]
            ]
        ],
        "outputs": [
            [
                [
                    18,
                    63,
                    80,
                    25,
                    32,
                    43,
                    80,
                    93,
                    80,
                    25,
                    93,
                    -1,
                    28,
                    -1,
                    -1
                ]
            ],
            [
                [
                    3,
                    7,
                    -1,
                    18,
                    9,
                    9,
                    10,
                    18,
                    -1,
                    -1
                ]
            ]
        ],
        "starter_code": "\ndef array_manip(array):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef consecutive(arr):\n\t    \"\"\"Create the function ```consecutive(arr)``` that takes an array of integers and return the minimum number of integers needed to make the contents of ```arr``` consecutive from the lowest number to the highest number.\nFor example:  If ```arr``` contains [4, 8, 6] then the output should be 2 because two numbers need to be added to the array (5 and 7) to make it a consecutive array of numbers from 4 to 8. Numbers in ```arr``` will be unique.\n    \"\"\"\n",
        "canonical_solution": "def consecutive(arr):\n    return max(arr) - min(arr) + 1 - len(arr) if arr else 0",
        "inputs": [
            [
                [
                    4,
                    8,
                    6
                ]
            ],
            [
                [
                    1,
                    2,
                    3,
                    4
                ]
            ],
            [
                []
            ]
        ],
        "outputs": [
            [
                2
            ],
            [
                0
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef consecutive(arr):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef even_chars(st):\n\t    \"\"\"Write a function that returns a sequence (index begins with 1) of all the even characters from a string. If the string is smaller than two characters or longer than 100 characters, the function should return \"invalid string\". \n\nFor example:\n`````\n\"abcdefghijklm\" --> [\"b\", \"d\", \"f\", \"h\", \"j\", \"l\"]\n\"a\"             --> \"invalid string\"\n`````\n    \"\"\"\n",
        "canonical_solution": "def even_chars(st):\n    if len(st) < 2 or len(st)> 100:\n        return 'invalid string'\n    else:\n        return [st[i] for i in range(1, len(st), 2)]\n",
        "inputs": [
            [
                "\"a\""
            ],
            [
                "\"abcdefghijklm\""
            ],
            [
                "\"aBc_e9g*i-k$m\""
            ]
        ],
        "outputs": [
            [
                "\"invalid string\""
            ],
            [
                [
                    "b",
                    "d",
                    "f",
                    "h",
                    "j",
                    "l"
                ]
            ],
            [
                [
                    "B",
                    "_",
                    "9",
                    "*",
                    "-",
                    "$"
                ]
            ]
        ],
        "starter_code": "\ndef even_chars(st):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "If Statement Body",
                2,
                5
            ],
            [
                "List Comprehension",
                5,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n            \"\"\"Students are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.\n \nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\n \nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        max_val = max(heights)\n        \n        freq = [0] * (max_val + 1)\n        for num in heights:\n            freq[num] += 1\n        for num in range(1,len(freq)):\n            freq[num] += freq[num-1]\n        places = [0] * len(heights)\n        for num in heights:\n            places[freq[num] - 1] = num\n            freq[num] -= 1\n        return sum(a != b for a , b in zip(places,heights))",
        "inputs": [
            [
                [
                    1,
                    1,
                    4,
                    2,
                    1,
                    3
                ]
            ]
        ],
        "outputs": [
            [
                3
            ]
        ],
        "starter_code": "\nclass Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                14
            ],
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "For Loop Body",
                11,
                13
            ],
            [
                "Generator Expression",
                14,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef grille(message, code):\n\t    \"\"\"# Introduction \n\nA grille cipher was a technique for encrypting a plaintext by writing it onto a sheet of paper through a pierced sheet (of paper or cardboard or similar). The earliest known description is due to the polymath Girolamo Cardano in 1550. His proposal was for a rectangular stencil allowing single letters, syllables, or words to be written, then later read, through its various apertures. The written fragments of the plaintext could be further disguised by filling the gaps between the fragments with anodyne words or letters. This variant is also an example of steganography, as are many of the grille ciphers. \nWikipedia Link \n\n![Tangiers1](https://upload.wikimedia.org/wikipedia/commons/8/8a/Tangiers1.png)\n![Tangiers2](https://upload.wikimedia.org/wikipedia/commons/b/b9/Tangiers2.png)\n\n# Task\n\nWrite a function that accepts two inputs: `message` and `code` and returns hidden message decrypted from `message` using the `code`.   \nThe `code` is a nonnegative integer and it decrypts in binary the `message`.\n    \"\"\"\n",
        "canonical_solution": "def grille(msg, code):\n    return ''.join(msg[-1-i] for i,c in enumerate(bin(code)[::-1]) if c == '1' and i < len(msg))[::-1]",
        "inputs": [
            [
                "\"abcdef\"",
                5
            ],
            [
                "\"\"",
                5
            ],
            [
                "\"abcd\"",
                1
            ]
        ],
        "outputs": [
            [
                "\"df\""
            ],
            [
                "\"\""
            ],
            [
                "\"d\""
            ]
        ],
        "starter_code": "\ndef grille(message, code):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef first_n_smallest(arr, n):\n\t    \"\"\"Your task is to write a function that does just what the title suggests (so, fair warning, be aware that you are not getting out of it just throwing a lame bas sorting method there) with an array/list/vector of integers and the expected number `n` of smallest elements to return.\n\nAlso:\n\n* the number of elements to be returned cannot be higher than the array/list/vector length;\n* elements can be duplicated;\n* in case of duplicates, just return them according to the original order (see third example for more clarity).\n\nSame examples and more in the test cases:\n\n```python\nfirst_n_smallest([1,2,3,4,5],3) == [1,2,3]\nfirst_n_smallest([5,4,3,2,1],3) == [3,2,1]\nfirst_n_smallest([1,2,3,4,1],3) == [1,2,1]\nfirst_n_smallest([1,2,3,-4,0],3) == [1,-4,0]\nfirst_n_smallest([1,2,3,4,5],0) == []\n```\n\n[Performance version by FArekkusu](https://www.codewars.com/kata/5aeed69804a92621a7000077) also available.\n    \"\"\"\n",
        "canonical_solution": "def first_n_smallest(arr, n):\n    lst = sorted(enumerate(arr), key=lambda it: it[1])[:n]\n    lst.sort(key=lambda it:it[0])\n    return [v for _,v in lst]",
        "inputs": [
            [
                [
                    1,
                    2,
                    3,
                    4,
                    5
                ],
                3
            ],
            [
                [
                    5,
                    4,
                    3,
                    2,
                    1
                ],
                3
            ],
            [
                [
                    1,
                    2,
                    3,
                    1,
                    2
                ],
                3
            ]
        ],
        "outputs": [
            [
                [
                    1,
                    2,
                    3
                ]
            ],
            [
                [
                    3,
                    2,
                    1
                ]
            ],
            [
                [
                    1,
                    2,
                    1
                ]
            ]
        ],
        "starter_code": "\ndef first_n_smallest(arr, n):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "Lambda Expression",
                2,
                2
            ],
            [
                "Lambda Expression",
                3,
                3
            ],
            [
                "List Comprehension",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef shape_area(n):\n\t    \"\"\"# Task\n Below we will define what and n-interesting polygon is and your task is to find its area for a given n.\n\n A 1-interesting polygon is just a square with a side of length 1. An n-interesting polygon is obtained by taking the n - 1-interesting polygon and appending 1-interesting polygons to its rim side by side. You can see the 1-, 2- and 3-interesting polygons in the picture below.\n\n ![](https://files.gitter.im/myjinxin2015/Gwsw/blob)\n\n# Example\n\n For `n = 1`, the output should be `1`;\n \n For `n = 2`, the output should be `5`;\n \n For `n = 3`, the output should be `13`.\n\n# Input/Output\n\n\n - `[input]` integer `n`\n\n    Constraints: `1 ≤ n < 10000.`\n    \n\n - `[output]` an integer\n\n   The area of the n-interesting polygon.\n    \"\"\"\n",
        "canonical_solution": "def shape_area(n):\n    return n**2 + (n - 1) ** 2",
        "inputs": [
            [
                2
            ],
            [
                3
            ],
            [
                1
            ]
        ],
        "outputs": [
            [
                5
            ],
            [
                13
            ],
            [
                1
            ]
        ],
        "starter_code": "\ndef shape_area(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef fNRAo():\n    \"\"\"It is only six months until Christmas, and AtCoDeer the reindeer is now planning his travel to deliver gifts.\n\nThere are N houses along TopCoDeer street. The i-th house is located at coordinate a_i. He has decided to deliver gifts to all these houses.\n\nFind the minimum distance to be traveled when AtCoDeer can start and end his travel at any positions.  \n\n-----Constraints-----\n - 1 ≤ N ≤ 100\n - 0 ≤ a_i ≤ 1000\n - a_i is an integer.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\n\n-----Output-----\nPrint the minimum distance to be traveled.  \n\n-----Sample Input-----\n4\n2 3 7 9\n\n-----Sample Output-----\n7\n\nThe travel distance of 7 can be achieved by starting at coordinate 9 and traveling straight to coordinate 2.\n\nIt is not possible to do with a travel distance of less than 7, and thus 7 is the minimum distance to be traveled.\n    \"\"\"\n",
        "canonical_solution": "\ndef fNRAo():\n    N=int(input())\n    A=list(map(int, input().split()))\n    \n    print(max(A)-min(A))",
        "inputs": [
            "4\n2 3 7 9\n",
            "8\n3 1 4 1 5 9 2 6\n"
        ],
        "outputs": [
            "7\n",
            "8\n"
        ],
        "starter_code": "\ndef fNRAo():\n",
        "scope": [
            [
                "Function Body",
                2,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef jYTVP():\n    \"\"\"The development of algae in a pond is as follows.\nLet the total weight of the algae at the beginning of the year i be x_i gram. For i≥2000, the following formula holds:\n - x_{i+1} = rx_i - D\nYou are given r, D and x_{2000}. Calculate x_{2001}, ..., x_{2010} and print them in order.\n\n-----Constraints-----\n - 2 ≤ r ≤ 5\n - 1 ≤ D ≤ 100\n - D < x_{2000} ≤ 200\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nr D x_{2000}\n\n-----Output-----\nPrint 10 lines. The i-th line (1 ≤ i ≤ 10) should contain x_{2000+i} as an integer.\n\n-----Sample Input-----\n2 10 20\n\n-----Sample Output-----\n30\n50\n90\n170\n330\n650\n1290\n2570\n5130\n10250\n\nFor example, x_{2001} = rx_{2000} - D = 2 \\times 20 - 10 = 30 and x_{2002} = rx_{2001} - D = 2 \\times 30 - 10 = 50.\n    \"\"\"\n",
        "canonical_solution": "\ndef jYTVP():\n    r, D, x = map(int, input().split())\n    \n    for i in range(10):\n        x = r * x - D\n        print(x)",
        "inputs": [
            "2 10 20\n",
            "4 40 60\n",
            "2 1 2\n"
        ],
        "outputs": [
            "30\n50\n90\n170\n330\n650\n1290\n2570\n5130\n10250\n",
            "200\n760\n3000\n11960\n47800\n191160\n764600\n3058360\n12233400\n48933560\n",
            "3\n5\n9\n17\n33\n65\n129\n257\n513\n1025\n"
        ],
        "starter_code": "\ndef jYTVP():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "For Loop Body",
                5,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef past(h, m, s):\n\t    \"\"\"Clock shows 'h' hours, 'm' minutes and 's' seconds after midnight.\n\nYour task is to make 'Past' function which returns time converted to milliseconds.\n\n## Example:\n\n```python\npast(0, 1, 1) == 61000\n```\n\nInput constraints: `0 <= h <= 23`, `0 <= m <= 59`, `0 <= s <= 59`\n    \"\"\"\n",
        "canonical_solution": "def past(h, m, s):\n    return (3600*h + 60*m + s) * 1000",
        "inputs": [
            [
                0,
                1,
                1
            ],
            [
                1,
                1,
                1
            ],
            [
                0,
                0,
                0
            ]
        ],
        "outputs": [
            [
                61000
            ],
            [
                3661000
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef past(h, m, s):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef operation(a,b):\n\t    \"\"\"You are given two positive integers ```a``` and ```b```.\n\nYou can perform the following operations on ```a``` so as to obtain ```b``` :\n```\n(a-1)/2   (if (a-1) is divisible by 2)\na/2       (if a is divisible by 2)\na*2\n```\n```b``` will always be a power of 2.\n\nYou are to write a function ```operation(a,b)``` that efficiently returns the minimum number of operations required to transform ```a``` into ```b```.\n\nFor example :\n```\noperation(2,8) -> 2\n2*2 = 4\n4*2 = 8\n\noperation(9,2) -> 2\n(9-1)/2 = 4\n4/2 = 2\n\noperation(1024,1024) -> 0\n```\n    \"\"\"\n",
        "canonical_solution": "from math import log2\n\ndef operation(a,b, n = 0):\n    while log2(a) % 1:\n        n += 1\n        a //= 2\n    return n + abs(log2(a/b))",
        "inputs": [
            [
                1,
                1
            ],
            [
                2,
                4
            ],
            [
                3,
                8
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                1
            ],
            [
                4
            ]
        ],
        "starter_code": "\ndef operation(a,b):\n",
        "scope": [
            [
                "Function Body",
                3,
                7
            ],
            [
                "While Loop Body",
                4,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef tqSdx():\n    \"\"\"Based on some criterion, Snuke divided the integers from 1 through 12 into three groups as shown in the figure below.\nGiven two integers x and y (1 ≤ x < y ≤ 12), determine whether they belong to the same group.\n\n-----Constraints-----\n - x and y are integers.\n - 1 ≤ x < y ≤ 12\n\n-----Input-----\nInput is given from Standard Input in the following format:\nx y\n\n-----Output-----\nIf x and y belong to the same group, print Yes; otherwise, print No.\n\n-----Sample Input-----\n1 3\n\n-----Sample Output-----\nYes\n\n    \"\"\"\n",
        "canonical_solution": "\ndef tqSdx():\n    n1 = [1, 3, 5, 7, 8, 10, 12]\n    n2 = [4, 6, 9, 11]\n    \n    a, b = list(map(int, input().split()))\n    print((\"Yes\" if a in n1 and b in n1 or a in n2 and b in n2 else \"No\"))\n    ",
        "inputs": [
            "1 3\n",
            "2 4\n"
        ],
        "outputs": [
            "Yes\n",
            "No\n"
        ],
        "starter_code": "\ndef tqSdx():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef buy_newspaper(s1,s2):\n\t    \"\"\"# Task\nA newspaper is published in Walrusland. Its heading is `s1` , it consists of lowercase Latin letters. \n\nFangy the little walrus wants to buy several such newspapers, cut out their headings, glue them one to another in order to get one big string. \n\nAfter that walrus erase several letters from this string in order to get a new word `s2`. \n\nIt is considered that when Fangy erases some letter, there's no whitespace formed instead of the letter. That is, the string remains unbroken and it still only consists of lowercase Latin letters.\n\nFor example, the heading is `\"abc\"`. If we take two such headings and glue them one to the other one, we get `\"abcabc\"`. If we erase the 1st letter(\"a\") and 5th letter(\"b\"), we get a word `\"bcac\"`.\n\nGiven two string `s1` and `s2`, return the least number of newspaper headings `s1`, which Fangy will need to receive the word `s2`. If it is impossible to get the word `s2` in the above-described manner, return `-1`.\n\n# Example\n\nFor `s1=\"abc\", s2=\"bcac\"`, the output should be `2`.\n\n```\n\"abcabc\" --> \"bcac\"\n x   x\n```\n\nFor `s1=\"abc\", s2=\"xyz\"`, the output should be `-1`.\n\nIt's impossible to get the word `s2`.\n    \"\"\"\n",
        "canonical_solution": "import re\n\n\ndef buy_newspaper(s1, s2):\n    p = re.sub(r\"(.)\", r\"\\1?\", s1)\n    return -1 if set(s2) - set(s1) else len(re.findall(p, s2)) - 1",
        "inputs": [
            [
                "\"abc\"",
                "\"bcac\""
            ],
            [
                "\"abc\"",
                "\"xyz\""
            ],
            [
                "\"abc\"",
                "\"abcabc\""
            ]
        ],
        "outputs": [
            [
                2
            ],
            [
                -1
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef buy_newspaper(s1,s2):\n",
        "scope": [
            [
                "Function Body",
                4,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef sabb(s, value, happiness):\n\t    \"\"\"Learning to code around your full time job is taking over your life. You realise that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.\n\nProblem is, many of them cost a fortune, and those that don't still involve a significant amount of time off work - who will pay your mortgage?!\n\nTo offset this risk, you decide that rather than leaving work totally, you will request a sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.\n\nYou need to approach your boss. Her decision will be based on three parameters:\n\nval=your value to the organisation\nhappiness=her happiness level at the time of asking and finally\nThe numbers of letters from 'sabbatical' that are present in string `s`.\n\nNote that if `s` contains three instances of the letter 'l', that still scores three points, even though there is only one in the word sabbatical.\n\nIf the sum of the three parameters (as described above) is > 22, return 'Sabbatical! Boom!', else return 'Back to your desk, boy.'.\n\n~~~if:c\nNOTE: For the C translation you should return a string literal.\n~~~\n    \"\"\"\n",
        "canonical_solution": "def sabb(stg, value, happiness):\n    sabbatical = (value + happiness + sum(1 for c in stg if c in \"sabbatical\")) > 22\n    return \"Sabbatical! Boom!\" if sabbatical else \"Back to your desk, boy.\"",
        "inputs": [
            [
                "\"Can I have a sabbatical?\"",
                5,
                5
            ],
            [
                "\"Why are you shouting?\"",
                7,
                2
            ],
            [
                "\"What do you mean I cant learn to code??\"",
                8,
                9
            ]
        ],
        "outputs": [
            [
                "\"Sabbatical! Boom!\""
            ],
            [
                "\"Back to your desk, boy.\""
            ],
            [
                "\"Sabbatical! Boom!\""
            ]
        ],
        "starter_code": "\ndef sabb(s, value, happiness):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef validate_time(time):\n\t    \"\"\"Write a regex to validate a 24 hours time string.\nSee examples to figure out what you should check for:\n\nAccepted:\n01:00 - 1:00  \n\nNot accepted:\n\n24:00\n\nYou should check for correct length and no spaces.\n    \"\"\"\n",
        "canonical_solution": "import re\n\n_24H = re.compile(r'^([01]?\\d|2[0-3]):[0-5]\\d$')\n\nvalidate_time = lambda time: bool(_24H.match(time))\n",
        "inputs": [
            [
                "\"1:00\""
            ],
            [
                "\"13:1\""
            ],
            [
                "\"12:60\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef validate_time(time):\n",
        "scope": [
            [
                "Lambda Expression",
                5,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef work_needed(projectMinutes, freeLancers):\n\t    \"\"\"You are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!\n\nTo make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project. \n\nGiving the amount of time in `minutes` needed to complete the project and an array of pair values representing other freelancers' time in `[Hours, Minutes]` format ie. `[[2, 33], [3, 44]]` calculate how much time **you** will need to contribute to the project (if at all) and return a string depending on the case.\n\n\n* If we need to contribute time to the project then return `\"I need to work x hour(s) and y minute(s)\"`\n* If we don't have to contribute any time to the project then return `\"Easy Money!\"`\n    \"\"\"\n",
        "canonical_solution": "def work_needed(project_minutes, freelancers):\n    available_minutes = sum(hours * 60 + minutes for hours, minutes in freelancers)\n    workload_minutes = project_minutes - available_minutes\n    if workload_minutes <= 0:\n        return 'Easy Money!'\n    else:\n        hours, minutes = divmod(workload_minutes, 60)\n        return 'I need to work {} hour(s) and {} minute(s)'.format(hours, minutes)",
        "inputs": [
            [
                60,
                [
                    [
                        1,
                        0
                    ]
                ]
            ],
            [
                60,
                [
                    [
                        0,
                        0
                    ]
                ]
            ]
        ],
        "outputs": [
            [
                "\"Easy Money!\""
            ],
            [
                "\"I need to work 1 hour(s) and 0 minute(s)\""
            ]
        ],
        "starter_code": "\ndef work_needed(projectMinutes, freeLancers):\n",
        "scope": [
            [
                "Function Body",
                1,
                8
            ],
            [
                "Generator Expression",
                2,
                2
            ],
            [
                "If Statement Body",
                4,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef AmQIP():\n    \"\"\"AtCoDeer the deer recently bought three paint cans.\nThe color of the one he bought two days ago is a, the color of the one he bought yesterday is b, and the color of the one he bought today is c.\nHere, the color of each paint can is represented by an integer between 1 and 100, inclusive.\nSince he is forgetful, he might have bought more than one paint can in the same color.\nCount the number of different kinds of colors of these paint cans and tell him.\n\n-----Constraints-----\n - 1≦a,b,c≦100\n\n-----Input-----\nThe input is given from Standard Input in the following format:\na b c\n\n-----Output-----\nPrint the number of different kinds of colors of the paint cans.\n\n-----Sample Input-----\n3 1 4\n\n-----Sample Output-----\n3\n\nThree different colors: 1, 3, and 4.\n    \"\"\"\n",
        "canonical_solution": "\ndef AmQIP():\n    a=list(map(int,input().split()))\n    print(len(set(a)))",
        "inputs": [
            "3 1 4\n",
            "3 3 33\n"
        ],
        "outputs": [
            "3\n",
            "2\n"
        ],
        "starter_code": "\ndef AmQIP():\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef cup_volume(d1, d2, height):\n\t    \"\"\"Your job is to return the volume of a cup when given the diameter of the top, the diameter of the bottom and the height.\n\nYou know that there is a steady gradient from the top to the bottom.\n\nYou want to return the volume rounded to 2 decimal places.\n\nExmples:\n```python\ncup_volume(1, 1, 1)==0.79\n\ncup_volume(10, 8, 10)==638.79\n\ncup_volume(1000, 1000, 1000)==785398163.4\n\ncup_volume(13.123, 123.12, 1)==4436.57\n\ncup_volume(5, 12, 31)==1858.51\n```\n\nYou will only be passed positive numbers.\n    \"\"\"\n",
        "canonical_solution": "from math import pi\n\ndef cup_volume(d1, d2, h):\n    return round(h / 12.0 * pi * (d1**2 + d1*d2 + d2**2), 2)",
        "inputs": [
            [
                1,
                1,
                1
            ],
            [
                10,
                8,
                10
            ],
            [
                1000,
                1000,
                1000
            ]
        ],
        "outputs": [
            [
                0.79
            ],
            [
                638.79
            ],
            [
                785398163.4
            ]
        ],
        "starter_code": "\ndef cup_volume(d1, d2, height):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef parade_time(groups, location, speed, pref):\n\t    \"\"\"# Let's watch a parade!\n## Brief\nYou're going to watch a parade, but you only care about one of the groups marching. The parade passes through the street where your house is. Your house is at number `location` of the street. Write a function `parade_time` that will tell you the times when you need to appear to see all appearences of that group.\n\n## Specifications\nYou'll be given:\n\n* A `list` of `string`s containing `groups` in the parade, in order of appearance. A group may appear multiple times. You want to see all the parts of your favorite group.\n* An positive `integer` with the `location` on the parade route where you'll be watching.\n* An positive `integer` with the `speed` of the parade\n* A `string` with the `pref`ferred group you'd like to see\n\nYou need to return the time(s) you need to be at the parade to see your favorite group as a `list` of `integer`s.\n\nIt's possible the group won't be at your `location` at an exact `time`. In that case, just be sure to get there right before it passes (i.e. the largest integer `time` before the float passes the `position`).\n\n## Example\n```python\ngroups = ['A','B','C','D','E','F']\nlocation = 3\nspeed = 2\npref = 'C'\n                  v\nLocations: |0|1|2|3|4|5|6|7|8|9|...\nF E D C B A      | |               time = 0\n> > F E D C B A  | |               time = 1\n    > > F E D C B|A|               time = 2\n        > > F E D|C|B A            time = 3\n                  ^\nparade_time(['A','B','C','D','E','F'], 3, 2,'C']) == [3]\n```\n    \"\"\"\n",
        "canonical_solution": "def parade_time(groups, location, speed, pref):\n    return [c // speed for c, p in enumerate(groups, 1 + location) if p == pref]",
        "inputs": [
            [
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ],
                3,
                2,
                "\"c\""
            ],
            [
                [
                    "c",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ],
                3,
                2,
                "\"c\""
            ],
            [
                [
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ],
                3,
                2,
                "\"g\""
            ]
        ],
        "outputs": [
            [
                [
                    3
                ]
            ],
            [
                [
                    2,
                    3
                ]
            ],
            [
                []
            ]
        ],
        "starter_code": "\ndef parade_time(groups, location, speed, pref):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef inverse_slice(items, a, b):\n\t    \"\"\"You're familiar with [list slicing](https://docs.python.org/3/library/functions.html#slice) in Python and know, for example, that:\n\n```python\n>>> ages = [12, 14, 63, 72, 55, 24]\n>>> ages[2:4]\n[63, 72]\n>>> ages[2:]\n[63, 72, 55, 24]\n>>> ages[:3]\n[12, 14, 63]\n```\n\nwrite a function `inverse_slice()` that takes three arguments: a list `items`, an integer `a` and an integer `b`. The function should return a new list with the slice specified by `items[a:b]` _excluded_. For example:\n\n```python\n>>>inverse_slice([12, 14, 63, 72, 55, 24], 2, 4)\n[12, 14, 55, 24]\n```\n\nThe input will always be a valid list, `a` and `b` will always be different integers equal to or greater than zero, but they _may_ be zero or be larger than the length of the list.\n    \"\"\"\n",
        "canonical_solution": "def inverse_slice(items, a, b):\n    return items[:a] + items[b:]",
        "inputs": [
            [
                [
                    12,
                    14,
                    63,
                    72,
                    55,
                    24
                ],
                2,
                4
            ],
            [
                [
                    12,
                    14,
                    63,
                    72,
                    55,
                    24
                ],
                0,
                3
            ],
            [
                [
                    "Intuition",
                    "is",
                    "a",
                    "poor",
                    "guide",
                    "when",
                    "facing",
                    "probabilistic",
                    "evidence"
                ],
                5,
                13
            ]
        ],
        "outputs": [
            [
                [
                    12,
                    14,
                    55,
                    24
                ]
            ],
            [
                [
                    72,
                    55,
                    24
                ]
            ],
            [
                [
                    "Intuition",
                    "is",
                    "a",
                    "poor",
                    "guide"
                ]
            ]
        ],
        "starter_code": "\ndef inverse_slice(items, a, b):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef to_underscore(string):\n\t    \"\"\"Complete the function/method so that it takes CamelCase string and returns the string in snake_case notation. Lowercase characters can be numbers. If method gets number, it should return string.\n\nExamples:\n\n``` javascript\n//  returns test_controller\ntoUnderscore('TestController');\n\n// returns movies_and_books\ntoUnderscore('MoviesAndBooks');\n\n// returns app7_test\ntoUnderscore('App7Test');\n\n// returns \"1\"\ntoUnderscore(1);\n```\n\n``` coffeescript  \n#  returns test_controller\ntoUnderscore 'TestController'\n\n# returns movies_and_books\ntoUnderscore 'MoviesAndBooks'\n\n# returns app7_test\ntoUnderscore 'App7Test'\n\n# returns \"1\"\ntoUnderscore 1\n```\n    \"\"\"\n",
        "canonical_solution": "import re\n\ndef to_underscore(string):\n    return re.sub(r'(.)([A-Z])', r'\\1_\\2', str(string)).lower()    \n",
        "inputs": [
            [
                "\"TestController\""
            ],
            [
                "\"ThisIsBeautifulDay\""
            ],
            [
                "\"Am7Days\""
            ]
        ],
        "outputs": [
            [
                "\"test_controller\""
            ],
            [
                "\"this_is_beautiful_day\""
            ],
            [
                "\"am7_days\""
            ]
        ],
        "starter_code": "\ndef to_underscore(string):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef bouncing_ball(initial, proportion):\n\t    \"\"\"You drop a ball from a given height. After each bounce, the ball returns to some fixed proportion of its previous height. If the ball bounces to height 1 or less, we consider it to have stopped bouncing. Return the number of bounces it takes for the ball to stop moving.\n\n```\nbouncingBall(initialHeight, bouncingProportion)\n\nboucingBall(4, 0.5)\nAfter first bounce, ball bounces to height 2\nAfter second bounce, ball bounces to height 1\nTherefore answer is 2 bounces\n\nboucingBall(30, 0.3)\nAfter first bounce, ball bounces to height 9\nAfter second bounce, ball bounces to height 2.7\nAfter third bounce, ball bounces to height 0.81\nTherefore answer is 3 bounces\n\n\n```\n\nInitial height is an integer in range [2,1000]\n\nBouncing Proportion is a decimal in range [0, 1)\n    \"\"\"\n",
        "canonical_solution": "import math\n\ndef bouncing_ball(initial, proportion):\n    return math.ceil(math.log(initial, 1/proportion))",
        "inputs": [
            [
                2,
                0.5
            ],
            [
                4,
                0.5
            ],
            [
                10,
                0.1
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                2
            ],
            [
                1
            ]
        ],
        "starter_code": "\ndef bouncing_ball(initial, proportion):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef sequence_sum(b, e, s):\n\t    \"\"\"As the title suggests, this is the hard-core version of  another neat kata.\n\nThe task is simple to explain: simply sum all the numbers from the first parameter being the beginning to the second parameter being the upper limit (possibly included), going in steps expressed by the third parameter:\n\n```python\nsequence_sum(2, 2, 2) # 2\nsequence_sum(2, 6, 2) # 12 (= 2 + 4 + 6)\nsequence_sum(1, 5, 1) # (= 1 + 2 + 3 + 4 + 5)\nsequence_sum(1, 5, 3) # 5 (= 1 + 4)\n```\n\nIf it is an impossible sequence (with the beginning being larger the end and a positive step or the other way around), just return `0`. See the provided test cases for further examples :)\n\n**Note:** differing from the other base kata, much larger ranges are going to be tested, so you should hope to get your algo optimized and to avoid brute-forcing your way through the solution.\n    \"\"\"\n",
        "canonical_solution": "# from math import copysign\ndef sequence_sum(a, b, step):\n    n = (b-a)//step\n    return 0 if n<0 else (n+1)*(n*step+a+a)//2",
        "inputs": [
            [
                2,
                6,
                2
            ],
            [
                1,
                5,
                1
            ],
            [
                1,
                5,
                3
            ]
        ],
        "outputs": [
            [
                12
            ],
            [
                15
            ],
            [
                5
            ]
        ],
        "starter_code": "\ndef sequence_sum(b, e, s):\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef solution(n):\n\t    \"\"\"Round any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```\n    \"\"\"\n",
        "canonical_solution": "import math\ndef solution(n):\n    d=0\n    if n - 0.25< math.floor(n):\n        d=math.floor(n)\n    elif n - 0.75< math.floor(n):\n        d=math.floor(n)+0.5\n    else:\n        d=math.ceil(n)\n    return d",
        "inputs": [
            [
                4.2
            ],
            [
                4.25
            ],
            [
                4.4
            ]
        ],
        "outputs": [
            [
                4
            ],
            [
                4.5
            ],
            [
                4.5
            ]
        ],
        "starter_code": "\ndef solution(n):\n",
        "scope": [
            [
                "Function Body",
                2,
                10
            ],
            [
                "If Statement Body",
                4,
                9
            ],
            [
                "If Statement Body",
                6,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef string_chunk(string, n=0):\n\t    \"\"\"You should write a function that takes a string and a positive integer `n`, splits the string into parts of length `n` and returns them in an array. It is ok for the last element to have less than `n` characters.\n\nIf `n` is not a valid size (`> 0`) (or is absent), you should return an empty array.\n\nIf `n` is greater than the length of the string, you should return an array with the only element being the same string.\n\nExamples:\n\n```python\nstring_chunk('codewars', 2) # ['co', 'de', 'wa', 'rs']\nstring_chunk('thiskataeasy', 4) # ['this', 'kata', 'easy']\nstring_chunk('hello world', 3) # ['hel', 'lo ', 'wor', 'ld']\nstring_chunk('sunny day', 0) # []\n```\n    \"\"\"\n",
        "canonical_solution": "def string_chunk(string, n=0):\n    return [string[i:i+n] for i in range(0,len(string), n)] if isinstance(n, int) and n > 0 else []\n",
        "inputs": [
            [
                "\"codewars\"",
                2
            ]
        ],
        "outputs": [
            [
                [
                    "co",
                    "de",
                    "wa",
                    "rs"
                ]
            ]
        ],
        "starter_code": "\ndef string_chunk(string, n=0):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef delete_nth(order,max_e):\n\t    \"\"\"## Enough is enough!\n\nAlice and Bob were on a holiday. Both of them took many pictures of the places they've been, and now they want to show Charlie their entire collection. However, Charlie doesn't like these sessions, since the motive usually repeats. He isn't fond of seeing the Eiffel tower 40 times. He tells them that he will only sit during the session if they show the same motive at most N times. Luckily, Alice and Bob are able to encode the motive as a number. Can you help them to remove numbers such that their list contains each number only up to N times, without changing the order?\n\n## Task\n\nGiven a list lst and a number N, create a new list that contains each number of lst at most N times without reordering. For example if N = 2, and the input is [1,2,3,1,2,1,2,3], you take [1,2,3,1,2], drop the next [1,2] since this would lead to 1 and 2 being in the result 3 times, and then take 3, which leads to [1,2,3,1,2,3].\n\n~~~if:nasm\n## NASM notes\n\nWrite the output numbers into the `out` parameter, and return its length.\n\nThe input array will contain only integers between 1 and 50 inclusive. Use it to your advantage.\n~~~\n\n~~~if:c\nFor C:\n* Assign the return array length to the pointer parameter `*szout`.\n* Do not mutate the input array.\n~~~\n\n## Example\n```python\n  delete_nth ([1,1,1,1],2) # return [1,1]\n  \n  delete_nth ([20,37,20,21],1) # return [20,37,21]\n```\n    \"\"\"\n",
        "canonical_solution": "def delete_nth(order,max_e):\n    ans = []\n    for o in order:\n        if ans.count(o) < max_e: ans.append(o)\n    return ans\n",
        "inputs": [
            [
                [
                    20,
                    37,
                    20,
                    21
                ],
                1
            ],
            [
                [
                    1,
                    1,
                    3,
                    3,
                    7,
                    2,
                    2,
                    2,
                    2
                ],
                3
            ],
            [
                [
                    1,
                    2,
                    3,
                    1,
                    1,
                    2,
                    1,
                    2,
                    3,
                    3,
                    2,
                    4,
                    5,
                    3,
                    1
                ],
                3
            ]
        ],
        "outputs": [
            [
                [
                    20,
                    37,
                    21
                ]
            ],
            [
                [
                    1,
                    1,
                    3,
                    3,
                    7,
                    2,
                    2,
                    2
                ]
            ],
            [
                [
                    1,
                    2,
                    3,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    5
                ]
            ]
        ],
        "starter_code": "\ndef delete_nth(order,max_e):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "For Loop Body",
                3,
                4
            ],
            [
                "If Statement Body",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef repeat_str(repeat, string):\n\t    \"\"\"```if-not:racket\nWrite a function called `repeat_str` which repeats the given string `src` exactly `count` times.\n```\n```if:racket\nWrite a function called `repeat-string` which repeats the given string `str` exactly `count` times.\n```\n    \"\"\"\n",
        "canonical_solution": "def repeat_str(repeat, string):\n    return repeat * string",
        "inputs": [
            [
                4,
                "\"a\""
            ],
            [
                3,
                "\"hello \""
            ],
            [
                2,
                "\"abc\""
            ]
        ],
        "outputs": [
            [
                "\"aaaa\""
            ],
            [
                "\"hello hello hello \""
            ],
            [
                "\"abcabc\""
            ]
        ],
        "starter_code": "\ndef repeat_str(repeat, string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef fix_progression(arr):\n\t    \"\"\"# Task\n You are given an array of integers. Your task is to determine the minimum number of its elements that need to be changed so that elements of the array will form an arithmetic progression. Note that if you swap two elements, you're changing both of them, for the purpose of this kata.\n\n Here an arithmetic progression is defined as a sequence of integers such that the difference between consecutive terms is constant. For example, `6 4 2 0 -2` and `3 3 3 3 3` are arithmetic progressions, but `0 0.5 1 1.5` and `1 -1 1 -1 1` are not.\n\n# Examples\n\n  For `arr = [1, 3, 0, 7, 9]` the answer is `1` \n  \n  Because only one element has to be changed in order to create an arithmetic progression.\n    \n  For `arr = [1, 10, 2, 12, 3, 14, 4, 16, 5]` the answer is `5` \n \n  The array will be changed into `[9, 10, 11, 12, 13, 14, 15, 16, 17]`.\n\n# Input/Output\n\n\n - `[input]` integer array `arr`\n\n  An array of N integers.\n  \n  `2 ≤ arr.length ≤ 100`\n  \n  `-1000 ≤ arr[i] ≤ 1000`\n\n  Note for Java users: you'll have a batch of 100 bigger random arrays, with lengths as `150 ≤ arr.length ≤ 300`.\n  \n\n - `[output]` an integer\n\n  The minimum number of elements to change.\n    \"\"\"\n",
        "canonical_solution": "from collections import defaultdict\n\ndef fix_progression(arr):\n    res = 0\n    for i in range(len(arr)):\n        D = defaultdict(int)\n        for j in range(i):\n            q, r = divmod(arr[i]-arr[j], i-j)\n            if not r:\n                D[q] += 1\n                res = max(res, D[q])\n    return len(arr)-res-1",
        "inputs": [
            [
                [
                    1,
                    2,
                    3
                ]
            ],
            [
                [
                    1,
                    3,
                    0,
                    7,
                    9
                ]
            ],
            [
                [
                    1,
                    10,
                    2,
                    12,
                    3,
                    14,
                    4,
                    16,
                    5
                ]
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                1
            ],
            [
                5
            ]
        ],
        "starter_code": "\ndef fix_progression(arr):\n",
        "scope": [
            [
                "Function Body",
                3,
                12
            ],
            [
                "For Loop Body",
                5,
                11
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "If Statement Body",
                9,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef psion_power_points(level,score):\n\t    \"\"\"Following from the previous kata and taking into account how cool psionic powers are compare to the Vance spell system (really, the idea of slots to dumb down the game sucks, not to mention that D&D became a smash hit among geeks, so...), your task in this kata is to create a function that returns how many power points you get as a psion [because psions are the coolest, they allow for a lot of indepth tactic playing and adjusting for psychic warriors or wilders or other non-core classes would be just an obnoxious core].\n\nConsider both [the psion power points/days table](http://www.dandwiki.com/wiki/SRD:Psion#Making_a_Psion) and [bonus power points](http://www.d20pfsrd.com/psionics-unleashed/classes/#Table_Ability_Modifiers_and_Bonus_Power_Points) to figure out the correct reply, returned as an integer; the usual interpretation is that bonus power points stop increasing after level 20, but for the scope of this kata, we will pretend they keep increasing as they did before.\n\nTo compute the total, you will be provided, both as non-negative integers:\n\n* class level (assume they are all psion levels and remember the base power points/day halts after level 20)\n* manifesting attribute score (Intelligence, to be more precise) to determine the total, provided the score is high enough for the character to manifest at least one power.\n\nSome examples:\n\n```python\npsion_power_points(1,0) == 0\npsion_power_points(1,10) == 0\npsion_power_points(1,11) == 2\npsion_power_points(1,20) == 4\npsion_power_points(21,30) == 448\n```\n\n*Note: I didn't explain things in detail and just pointed out to the table on purpose, as my goal is also to train the pattern recognition skills of whoever is going to take this challenges, so do not complain about a summary description. Thanks :)*\n\nIn the same series:\n\n* [D&D Character generator #1: attribute modifiers and spells](https://www.codewars.com/kata/d-and-d-character-generator-number-1-attribute-modifiers-and-spells/)\n* [D&D Character generator #2: psion power points](https://www.codewars.com/kata/d-and-d-character-generator-number-2-psion-power-points/)\n* [D&D Character generator #3: carrying capacity](https://www.codewars.com/kata/d-and-d-character-generator-number-3-carrying-capacity/)\n    \"\"\"\n",
        "canonical_solution": "psion_power_points=lambda l,s: [0,2,6,11,17,25,35,46,58,72,88,106,126,147,170,195,221,250,280,311,343][min(l,20)]+(s-10)//2*l//2 if l and s>10 else 0",
        "inputs": [
            [
                1,
                0
            ],
            [
                1,
                10
            ],
            [
                1,
                11
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                0
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef psion_power_points(level,score):\n",
        "scope": [
            [
                "Lambda Expression",
                1,
                1
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef SuhfV():\n    \"\"\"Snuke is buying a bicycle.\nThe bicycle of his choice does not come with a bell, so he has to buy one separately.\nHe has very high awareness of safety, and decides to buy two bells, one for each hand.\nThe store sells three kinds of bells for the price of a, b and c yen (the currency of Japan), respectively.\nFind the minimum total price of two different bells.\n\n-----Constraints-----\n - 1 \\leq a,b,c \\leq 10000\n - a, b and c are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\na b c\n\n-----Output-----\nPrint the minimum total price of two different bells.\n\n-----Sample Input-----\n700 600 780\n\n-----Sample Output-----\n1300\n\n - Buying a 700-yen bell and a 600-yen bell costs 1300 yen.\n - Buying a 700-yen bell and a 780-yen bell costs 1480 yen.\n - Buying a 600-yen bell and a 780-yen bell costs 1380 yen.\nThe minimum among these is 1300 yen.\n    \"\"\"\n",
        "canonical_solution": "\ndef SuhfV():\n    # A - ringring\n    # https://atcoder.jp/contests/abc066/tasks/abc066_a\n    \n    a = list(map(int, input().split()))\n    \n    a.sort()\n    print((a[0] + a[1]))\n    ",
        "inputs": [
            "700 600 780\n",
            "10000 10000 10000\n"
        ],
        "outputs": [
            "1300\n",
            "20000\n"
        ],
        "starter_code": "\ndef SuhfV():\n",
        "scope": [
            [
                "Function Body",
                2,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n            \"\"\"Given an array of integers nums, you start with an initial positive value startValue.\nIn each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).\nReturn the minimum positive value of startValue such that the step by step sum is never less than 1.\n \nExample 1:\nInput: nums = [-3,2,-3,4,2]\nOutput: 5\nExplanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.\n                step by step sum\n                startValue = 4 | startValue = 5 | nums\n                  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n                  (1 +2 ) = 3  | (2 +2 ) = 4    |   2\n                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n                  (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n                  (4 +2 ) = 6  | (5 +2 ) = 7    |   2\n\nExample 2:\nInput: nums = [1,2]\nOutput: 1\nExplanation: Minimum start value should be positive. \n\nExample 3:\nInput: nums = [1,-2,-3]\nOutput: 5\n\n \nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n        res = 1\n        for ind,n in enumerate(nums):\n            temp = 1-sum(nums[:ind+1])\n            if(temp > res):\n                res = temp\n        return res",
        "inputs": [
            [
                [
                    -3,
                    2,
                    -3,
                    4,
                    2
                ]
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def minStartValue(self, nums: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                8
            ],
            [
                "Function Body",
                2,
                8
            ],
            [
                "For Loop Body",
                4,
                7
            ],
            [
                "If Statement Body",
                6,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef HQ9(code):\n\t    \"\"\"You task is to implement an simple interpreter for the notorious esoteric language [HQ9+](https://esolangs.org/wiki/HQ9+) that will work for a single character input:\n\n- If the input is `'H'`, return `'Hello World!'`\n- If the input is `'Q'`, return the input\n- If the input is `'9'`, return the full lyrics of [99 Bottles of Beer](http://www.99-bottles-of-beer.net/lyrics.html). It should be formatted like this:\n\n```if:rust\n__Note__: In Rust, return `Some` containing the appropriate value.\n```\n\n```\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n97 bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n...\n...\n...\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n```\n\n- For everything else, don't return anything (return `null` in C#, `None` in Rust).\n\n(`+` has no visible effects so we can safely ignore it.)\n    \"\"\"\n",
        "canonical_solution": "LINES = \"{0} of beer on the wall, {0} of beer.\\nTake one down and pass it around, {1} of beer on the wall.\"\nSONG = '\\n'.join( LINES.format(\"{} bottles\".format(n), \"{} bottle\".format(n-1)+\"s\"*(n!=2)) for n in range(99,1,-1) )\nSONG += \"\"\"\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\"\"\"\n\ndef HQ9(code):\n    return {'H': 'Hello World!', 'Q': 'Q', '9': SONG}.get(code, None)",
        "inputs": [
            [
                "\"X\""
            ],
            [
                "\"H\""
            ],
            [
                "\"Q\""
            ]
        ],
        "outputs": [
            [
                null
            ],
            [
                "\"Hello World!\""
            ],
            [
                "\"Q\""
            ]
        ],
        "starter_code": "\ndef HQ9(code):\n",
        "scope": [
            [
                "Generator Expression",
                2,
                2
            ],
            [
                "Function Body",
                9,
                10
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef PzToO():\n    \"\"\"You are given two huge binary integer numbers $a$ and $b$ of lengths $n$ and $m$ respectively. You will repeat the following process: if $b > 0$, then add to the answer the value $a~ \\&~ b$ and divide $b$ by $2$ rounding down (i.e. remove the last digit of $b$), and repeat the process again, otherwise stop the process.\n\nThe value $a~ \\&~ b$ means bitwise AND of $a$ and $b$. Your task is to calculate the answer modulo $998244353$.\n\nNote that you should add the value $a~ \\&~ b$ to the answer in decimal notation, not in binary. So your task is to calculate the answer in decimal notation. For example, if $a = 1010_2~ (10_{10})$ and $b = 1000_2~ (8_{10})$, then the value $a~ \\&~ b$ will be equal to $8$, not to $1000$.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$) — the length of $a$ and the length of $b$ correspondingly.\n\nThe second line of the input contains one huge integer $a$. It is guaranteed that this number consists of exactly $n$ zeroes and ones and the first digit is always $1$.\n\nThe third line of the input contains one huge integer $b$. It is guaranteed that this number consists of exactly $m$ zeroes and ones and the first digit is always $1$.\n\n\n-----Output-----\n\nPrint the answer to this problem in decimal notation modulo $998244353$.\n\n\n-----Examples-----\nInput\n4 4\n1010\n1101\n\nOutput\n12\n\nInput\n4 5\n1001\n10101\n\nOutput\n11\n\n\n\n-----Note-----\n\nThe algorithm for the first example:   add to the answer $1010_2~ \\&~ 1101_2 = 1000_2 = 8_{10}$ and set $b := 110$;  add to the answer $1010_2~ \\&~ 110_2 = 10_2 = 2_{10}$ and set $b := 11$;  add to the answer $1010_2~ \\&~ 11_2 = 10_2 = 2_{10}$ and set $b := 1$;  add to the answer $1010_2~ \\&~ 1_2 = 0_2 = 0_{10}$ and set $b := 0$. \n\nSo the answer is $8 + 2 + 2 + 0 = 12$.\n\nThe algorithm for the second example:   add to the answer $1001_2~ \\&~ 10101_2 = 1_2 = 1_{10}$ and set $b := 1010$;  add to the answer $1001_2~ \\&~ 1010_2 = 1000_2 = 8_{10}$ and set $b := 101$;  add to the answer $1001_2~ \\&~ 101_2 = 1_2 = 1_{10}$ and set $b := 10$;  add to the answer $1001_2~ \\&~ 10_2 = 0_2 = 0_{10}$ and set $b := 1$;  add to the answer $1001_2~ \\&~ 1_2 = 1_2 = 1_{10}$ and set $b := 0$. \n\nSo the answer is $1 + 8 + 1 + 0 + 1 = 11$.\n    \"\"\"\n",
        "canonical_solution": "\ndef PzToO():\n    def mi():\n    \treturn list(map(int, input().split()))\n    \n    '''\n    4 4\n    1010\n    1101\n    '''\n    n,m = mi()\n    a = list(input())\n    b = list(input())\n    \n    pb = [0]*m\n    \n    if b[0]=='1':\n    \tpb[0] = 1\n    for i in range(1,m):\n    \tif b[i]=='1':\n    \t\tpb[i] = 1\n    \tpb[i]+=pb[i-1]\n    \n    ans = 0\n    if m>=n:\n    \tfor i in range(n):\n    \t\tif a[i]=='1':\n    \t\t\tans+=(pb[m-n+i]*pow(2,n-i-1,998244353))%998244353\n    \t\t\tans%=998244353\n    \tprint(ans%998244353)\n    else:\n    \tfor i in range(n-m,n):\n    \t\tif a[i]=='1':\n    \t\t\tans+=(pb[i-(n-m)]*pow(2,n-1-i,998244353))%998244353\n    \t\t\tans%=998244353\n    \tprint(ans%998244353)\n    ",
        "inputs": [
            "4 4\n1010\n1101\n",
            "4 5\n1001\n10101\n",
            "5 5\n11111\n11111\n"
        ],
        "outputs": [
            "12\n",
            "11\n",
            "57\n"
        ],
        "starter_code": "\ndef PzToO():\n",
        "scope": [
            [
                "Function Body",
                2,
                36
            ],
            [
                "Function Body",
                3,
                4
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "For Loop Body",
                19,
                22
            ],
            [
                "If Statement Body",
                20,
                21
            ],
            [
                "If Statement Body",
                25,
                36
            ],
            [
                "For Loop Body",
                26,
                29
            ],
            [
                "If Statement Body",
                27,
                29
            ],
            [
                "For Loop Body",
                32,
                35
            ],
            [
                "If Statement Body",
                33,
                35
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef missing(s):\n\t    \"\"\"In this Kata, you will be given a string of numbers in sequence and your task will be to return the missing number. If there is no number\nmissing or there is an error in the sequence, return `-1`.\n\nFor example:\n```Haskell\nmissing(\"123567\") = 4 \nmissing(\"899091939495\") = 92\nmissing(\"9899101102\") = 100\nmissing(\"599600601602\") = -1 -- no number missing\nmissing(\"8990919395\") = -1 -- error in sequence. Both 92 and 94 missing.\n```\nThe sequence will always be in ascending order.\n\nMore examples in the test cases. \n\nGood luck!\n    \"\"\"\n",
        "canonical_solution": "def missing(seq):\n    for digits in range(1, len(seq) // 2 + 1):\n        my_seq = last = seq[:digits]\n        n = int(my_seq)\n        missing = None\n        \n        while len(my_seq) < len(seq):\n            n += 1\n            my_seq += str(n)\n            \n            if not seq.startswith(my_seq):\n                if missing == None:\n                    missing = n\n                    my_seq = last\n                else:\n                    break\n            else:\n                last = my_seq\n        \n        if my_seq == seq and missing:\n            return missing\n    \n    return -1",
        "inputs": [
            [
                "\"123567\""
            ],
            [
                "\"899091939495\""
            ],
            [
                "\"9899101102\""
            ]
        ],
        "outputs": [
            [
                4
            ],
            [
                92
            ],
            [
                100
            ]
        ],
        "starter_code": "\ndef missing(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                23
            ],
            [
                "For Loop Body",
                2,
                21
            ],
            [
                "While Loop Body",
                7,
                18
            ],
            [
                "If Statement Body",
                11,
                18
            ],
            [
                "If Statement Body",
                12,
                16
            ],
            [
                "If Statement Body",
                20,
                21
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef AtHio():\n    \"\"\"There are N mountains ranging from east to west, and an ocean to the west.\nAt the top of each mountain, there is an inn. You have decided to choose where to stay from these inns.\nThe height of the i-th mountain from the west is H_i.\nYou can certainly see the ocean from the inn at the top of the westmost mountain.\nFor the inn at the top of the i-th mountain from the west (i = 2, 3, ..., N), you can see the ocean if and only if H_1 \\leq H_i, H_2 \\leq H_i, ..., and H_{i-1} \\leq H_i.\nFrom how many of these N inns can you see the ocean?\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 20\n - 1 \\leq H_i \\leq 100\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nH_1 H_2 ... H_N\n\n-----Output-----\nPrint the number of inns from which you can see the ocean.\n\n-----Sample Input-----\n4\n6 5 6 8\n\n-----Sample Output-----\n3\n\nYou can see the ocean from the first, third and fourth inns from the west.\n    \"\"\"\n",
        "canonical_solution": "\ndef AtHio():\n    N = int(input())\n    H = list(map(int,input().split()))\n    \n    top = H[0]\n    cnt = 1\n    \n    for i in range(1,N):\n      if top <= H[i]:\n        cnt += 1\n        top = H[i]\n    \n    print(cnt)",
        "inputs": [
            "4\n6 5 6 8\n",
            "5\n4 5 3 5 4\n",
            "5\n9 5 6 8 4\n"
        ],
        "outputs": [
            "3\n",
            "3\n",
            "1\n"
        ],
        "starter_code": "\ndef AtHio():\n",
        "scope": [
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                9,
                12
            ],
            [
                "If Statement Body",
                10,
                12
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef array_diff(a, b):\n\t    \"\"\"Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.\n\nIt should remove all values from list `a`, which are present in list `b`.\n\n```python\narray_diff([1,2],[1]) == [2]\n```\n\nIf a value is present in `b`, all of its occurrences must be removed from the other:\n\n```python\narray_diff([1,2,2,2,3],[2]) == [1,3]\n```\n~~~ if:c\nNOTE: In C, assign return array length to pointer *z\n~~~\n    \"\"\"\n",
        "canonical_solution": "def array_diff(a, b):\n    return [x for x in a if x not in b]",
        "inputs": [
            [
                [
                    1,
                    2
                ],
                [
                    1
                ]
            ],
            [
                [
                    1,
                    2,
                    2
                ],
                [
                    1
                ]
            ],
            [
                [
                    1,
                    2,
                    2
                ],
                [
                    2
                ]
            ]
        ],
        "outputs": [
            [
                [
                    2
                ]
            ],
            [
                [
                    2,
                    2
                ]
            ],
            [
                [
                    1
                ]
            ]
        ],
        "starter_code": "\ndef array_diff(a, b):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef calc(a):\n\t    \"\"\"**Steps**\n1. Square the numbers that are greater than zero.\n2. Multiply by 3 every third number.\n3. Multiply by -1 every fifth number.\n4. Return the sum of the sequence.\n\n**Example**   \n`{ -2, -1, 0, 1, 2 }` returns `-6`\n```\n1. { -2, -1, 0, 1 * 1, 2 * 2 }\n2. { -2, -1, 0 * 3, 1, 4 }\n3. { -2, -1, 0, 1, -1 * 4 }\n4. -6\n```\n\nP.S.: The sequence consists only of integers. And try not to use \"for\", \"while\" or \"loop\" statements.\n    \"\"\"\n",
        "canonical_solution": "def calc(a):\n    return sum( x**(1 + (x>=0)) * (1 + 2*(not i%3)) * (-1)**(not i%5) for i,x in enumerate(a,1))",
        "inputs": [
            [
                [
                    0,
                    2,
                    1,
                    -6,
                    -3,
                    3
                ]
            ],
            [
                [
                    0
                ]
            ],
            [
                [
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ]
        ],
        "outputs": [
            [
                31
            ],
            [
                0
            ],
            [
                5
            ]
        ],
        "starter_code": "\ndef calc(a):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef mult_primefactor_sum(a, b):\n\t    \"\"\"Every number may be factored in prime factors.\n\nFor example, the number 18 may be factored by its prime factors ``` 2 ``` and ```3```\n```\n18 = 2 . 3 . 3 = 2 . 3²\n```\nThe sum of the prime factors of 18 is  ```2 + 3 + 3 = 8```\n\nBut some numbers like 70 are divisible by the sum of its prime factors:\n```\n70 = 2 . 5 . 7 # sum of prime factors = 2 + 5 + 7 = 14\nand 70 is a multiple of 14\n```\nOf course that primes would fulfill this property, but is obvious, because the prime decomposition of a number, is the number itself and every number is divisible by iself. That is why we will discard every prime number in the results\n\nWe are interested in collect the integer positive numbers (non primes) that have this property in a certain range ```[a, b]``` (inclusive).\n\nMake the function ```mult_primefactor_sum()```, that receives the values ```a```, ```b``` as limits of the range ```[a, b]``` and ```a < b``` and outputs the sorted list of these numbers.\n\nLet's see some cases:\n```python\nmult_primefactor_sum(10, 100) == [16, 27, 30, 60, 70, 72, 84] \n\nmult_primefactor_sum(1, 60) == [1, 4, 16, 27, 30, 60]\n```\n    \"\"\"\n",
        "canonical_solution": "def mult_primefactor_sum(a, b): \n    s=[]\n    for i in range(a,b+1):\n       r=factorize_add(i)\n       if r!=i and i%r==0: s.append(i)\n    return s\n    \ndef factorize_add(num):\n    if num<4: return num\n    d=2; p=0\n    while d<num**.5+1:\n        while not num%d: p+=d; num/=d\n        d+=1 if d==2 else 2\n    return p if num==1 else p+num",
        "inputs": [
            [
                10,
                100
            ],
            [
                80,
                150
            ],
            [
                90,
                200
            ]
        ],
        "outputs": [
            [
                [
                    16,
                    27,
                    30,
                    60,
                    70,
                    72,
                    84
                ]
            ],
            [
                [
                    84,
                    105,
                    150
                ]
            ],
            [
                [
                    105,
                    150,
                    180
                ]
            ]
        ],
        "starter_code": "\ndef mult_primefactor_sum(a, b):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "For Loop Body",
                3,
                5
            ],
            [
                "If Statement Body",
                5,
                5
            ],
            [
                "Function Body",
                8,
                14
            ],
            [
                "If Statement Body",
                9,
                9
            ],
            [
                "While Loop Body",
                11,
                13
            ],
            [
                "While Loop Body",
                12,
                12
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef near_flatten(nested):\n\t    \"\"\"You are given an array that of arbitrary depth that needs to be nearly flattened into a 2 dimensional array. The given array's depth is also non-uniform, so some parts may be deeper than others.\n\nAll of lowest level arrays (most deeply nested) will contain only integers and none of the higher level arrays will contain anything but other arrays. All arrays given will be at least 2 dimensional. All lowest level arrays will contain at least one element.\n\nYour solution should be an array containing all of the lowest level arrays and only these. The sub-arrays should be ordered by the smallest element within each, so `[1,2]` should preceed `[3,4,5]`. Note: integers will not be repeated.\n\nFor example:\n\nIf you receive `[[[1,2,3],[4,5]],[6,7]]`, your answer should be `[[1,2,3],[4,5],[6,7]]`.\n    \"\"\"\n",
        "canonical_solution": "def near_flatten(a):\n    r = []\n    for x in a:\n        if isinstance(x[0], int): r.append(x)\n        else: r.extend(near_flatten(x))\n    return sorted(r)",
        "inputs": [
            [
                [
                    [
                        1
                    ]
                ]
            ],
            [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ]
            ],
            [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        [
                            4,
                            5
                        ],
                        [
                            [
                                6
                            ],
                            [
                                7,
                                8
                            ]
                        ]
                    ]
                ]
            ]
        ],
        "outputs": [
            [
                [
                    [
                        1
                    ]
                ]
            ],
            [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5,
                        6
                    ]
                ]
            ],
            [
                [
                    [
                        1,
                        2,
                        3
                    ],
                    [
                        4,
                        5
                    ],
                    [
                        6
                    ],
                    [
                        7,
                        8
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef near_flatten(nested):\n",
        "scope": [
            [
                "Function Body",
                1,
                6
            ],
            [
                "For Loop Body",
                3,
                5
            ],
            [
                "If Statement Body",
                4,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef build_palindrome(s):\n\t    \"\"\"# Task\n Given a string `str`, find the shortest possible string which can be achieved by adding characters to the end of initial string to make it a palindrome.\n\n# Example\n\n For `str = \"abcdc\"`, the output should be `\"abcdcba\"`.\n\n# Input/Output\n\n\n - `[input]` string `str`\n\n    A string consisting of lowercase latin letters.\n\n    Constraints: `3 ≤ str.length ≤ 10`.\n\n\n - `[output]` a string\n    \"\"\"\n",
        "canonical_solution": "def build_palindrome(strng):\n    n = 0\n    while strng[n:] != strng[n:][::-1]: n += 1\n    return strng + strng[:n][::-1]",
        "inputs": [
            [
                "\"abcdc\""
            ],
            [
                "\"ababab\""
            ]
        ],
        "outputs": [
            [
                "\"abcdcba\""
            ],
            [
                "\"abababa\""
            ]
        ],
        "starter_code": "\ndef build_palindrome(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "While Loop Body",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef DVFdZ():\n    \"\"\"A number is ternary if it contains only digits $0$, $1$ and $2$. For example, the following numbers are ternary: $1022$, $11$, $21$, $2002$.\n\nYou are given a long ternary number $x$. The first (leftmost) digit of $x$ is guaranteed to be $2$, the other digits of $x$ can be $0$, $1$ or $2$.\n\nLet's define the ternary XOR operation $\\odot$ of two ternary numbers $a$ and $b$ (both of length $n$) as a number $c = a \\odot b$ of length $n$, where $c_i = (a_i + b_i) \\% 3$ (where $\\%$ is modulo operation). In other words, add the corresponding digits and take the remainders of the sums when divided by $3$. For example, $10222 \\odot 11021 = 21210$.\n\nYour task is to find such ternary numbers $a$ and $b$ both of length $n$ and both without leading zeros that $a \\odot b = x$ and $max(a, b)$ is the minimum possible.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow. The first line of the test case contains one integer $n$ ($1 \\le n \\le 5 \\cdot 10^4$) — the length of $x$. The second line of the test case contains ternary number $x$ consisting of $n$ digits $0, 1$ or $2$. It is guaranteed that the first digit of $x$ is $2$. It is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^4$ ($\\sum n \\le 5 \\cdot 10^4$).\n\n\n-----Output-----\n\nFor each test case, print the answer — two ternary integers $a$ and $b$ both of length $n$ and both without leading zeros such that $a \\odot b = x$ and $max(a, b)$ is the minimum possible. If there are several answers, you can print any.\n\n\n-----Example-----\nInput\n4\n5\n22222\n5\n21211\n1\n2\n9\n220222021\n\nOutput\n11111\n11111\n11000\n10211\n1\n1\n110111011\n110111010\n    \"\"\"\n",
        "canonical_solution": "\ndef DVFdZ():\n    for _ in range(int(input())):\n        n=int(input())\n        s=input()\n        a=\"\"\n        b=\"\"\n        flag=1\n        for i in s:\n            if flag:\n                if i==\"2\":\n                    a+=\"1\"\n                    b+=\"1\"\n                elif i==\"1\":\n                    a+=\"1\"\n                    b+=\"0\"\n                    flag=0\n                else:\n                    a+=\"0\"\n                    b+=\"0\"\n            else:\n                if i==\"2\":\n                    a+=\"0\"\n                    b+=\"2\"\n                elif i==\"1\":\n                    a+=\"0\"\n                    b+=\"1\"\n                    flag=0\n                else:\n                    a+=\"0\"\n                    b+=\"0\"\n        print(a)\n        print(b)",
        "inputs": [
            "4\n5\n22222\n5\n21211\n1\n2\n9\n220222021\n"
        ],
        "outputs": [
            "11111\n11111\n11000\n10211\n1\n1\n110111011\n110111010\n"
        ],
        "starter_code": "\ndef DVFdZ():\n",
        "scope": [
            [
                "Function Body",
                2,
                33
            ],
            [
                "For Loop Body",
                3,
                33
            ],
            [
                "For Loop Body",
                9,
                31
            ],
            [
                "If Statement Body",
                10,
                31
            ],
            [
                "If Statement Body",
                11,
                20
            ],
            [
                "If Statement Body",
                14,
                20
            ],
            [
                "If Statement Body",
                22,
                31
            ],
            [
                "If Statement Body",
                25,
                31
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef KbLVP():\n    \"\"\"Given is a sequence of integers A_1, A_2, ..., A_N.\nIf its elements are pairwise distinct, print YES; otherwise, print NO.\n\n-----Constraints-----\n - 2 ≤ N ≤ 200000\n - 1 ≤ A_i ≤ 10^9\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_1 ... A_N\n\n-----Output-----\nIf the elements of the sequence are pairwise distinct, print YES; otherwise, print NO.\n\n-----Sample Input-----\n5\n2 6 1 4 5\n\n-----Sample Output-----\nYES\n\nThe elements are pairwise distinct.\n    \"\"\"\n",
        "canonical_solution": "import sys\nimport math\nimport collections\ndef KbLVP():\n    def N():\n        return int(input())\n    def L():\n        return list(map(int,input().split()))\n    def NL(n):\n        return [list(map(int,input().split())) for i in range(n)]\n    mod = pow(10,9)+7\n    #import numpy as np\n    n =N()\n    a = L()\n    s = set()\n    for i in range(n):\n        if a[i] in s:\n            print(\"NO\")\n            return\n        s.add(a[i])\n    print(\"YES\")",
        "inputs": [
            "5\n2 6 1 4 5\n",
            "6\n4 1 3 1 6 2\n",
            "2\n10000000 10000000\n"
        ],
        "outputs": [
            "YES\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef KbLVP():\n",
        "scope": [
            [
                "Function Body",
                4,
                21
            ],
            [
                "Function Body",
                5,
                6
            ],
            [
                "Function Body",
                7,
                8
            ],
            [
                "Function Body",
                9,
                10
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "For Loop Body",
                16,
                20
            ],
            [
                "If Statement Body",
                17,
                19
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef separate_liquids(glass):\n\t    \"\"\"Don't Drink the Water\n\nGiven a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n```\n======================\n|   Density Chart    |\n======================\n| Honey   | H | 1.36 |\n| Water   | W | 1.00 |\n| Alcohol | A | 0.87 |\n| Oil     | O | 0.80 |\n----------------------\n\n[                            [\n ['H', 'H', 'W', 'O'],        ['O','O','O','O']\n ['W', 'W', 'O', 'W'],  =>    ['W','W','W','W']\n ['H', 'H', 'O', 'O']         ['H','H','H','H']\n ]                           ]\n \n ```\n \n The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n    \"\"\"\n",
        "canonical_solution": "DENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\n\ndef separate_liquids(glass):\n    if not glass:\n        return []\n    column = len(glass[0])\n    liquids = sorted((b for a in glass for b in a), key=lambda c: DENSITY[c])\n    return [liquids[d:d + column] for d in range(0, len(liquids), column)]\n",
        "inputs": [
            [
                [
                    [
                        "H",
                        "H",
                        "W",
                        "O"
                    ],
                    [
                        "W",
                        "W",
                        "O",
                        "W"
                    ],
                    [
                        "H",
                        "H",
                        "O",
                        "O"
                    ]
                ]
            ],
            [
                [
                    [
                        "A",
                        "A",
                        "O",
                        "H"
                    ],
                    [
                        "A",
                        "H",
                        "W",
                        "O"
                    ],
                    [
                        "W",
                        "W",
                        "A",
                        "W"
                    ],
                    [
                        "H",
                        "H",
                        "O",
                        "O"
                    ]
                ]
            ],
            [
                [
                    [
                        "A",
                        "H",
                        "W",
                        "O"
                    ]
                ]
            ]
        ],
        "outputs": [
            [
                [
                    [
                        "O",
                        "O",
                        "O",
                        "O"
                    ],
                    [
                        "W",
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "H",
                        "H",
                        "H",
                        "H"
                    ]
                ]
            ],
            [
                [
                    [
                        "O",
                        "O",
                        "O",
                        "O"
                    ],
                    [
                        "A",
                        "A",
                        "A",
                        "A"
                    ],
                    [
                        "W",
                        "W",
                        "W",
                        "W"
                    ],
                    [
                        "H",
                        "H",
                        "H",
                        "H"
                    ]
                ]
            ],
            [
                [
                    [
                        "O",
                        "A",
                        "W",
                        "H"
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef separate_liquids(glass):\n",
        "scope": [
            [
                "Function Body",
                4,
                9
            ],
            [
                "If Statement Body",
                5,
                6
            ],
            [
                "Generator Expression",
                8,
                8
            ],
            [
                "Lambda Expression",
                8,
                8
            ],
            [
                "List Comprehension",
                9,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef omit_hashtag(message, hashtag):\n\t    \"\"\"The local transport authority is organizing an online picture contest.\nParticipants must take pictures of transport means in an original way, and then post the picture on Instagram using a specific ```hashtag```.\n\nThe local transport authority needs your help. They want you to take out the ```hashtag``` from the posted message. Your task is to implement the function\n\n```python\ndef omit_hashtag(message, hashtag):\n```\n\n## Examples \n\n```\n* (\"Sunny day! #lta #vvv\", \"#lta\") -> \"Sunny day!  #vvv\" (notice the double space)\n* (\"#lta #picture_contest\", \"#lta\") -> \" #picture_contest\"\n```\n\n## Notes\n\n* When multiple occurences of the hashtag are found, delete only the first one.\n\n* In C, you should modify the ```message```, as the function returns a void type. In Python, you should return the answer.\n\n* There can be erroneous messages where the hashtag isn't present. The message should in this case stay untouched.\n\n* The hashtag only consists of alphanumeric characters.\n    \"\"\"\n",
        "canonical_solution": "def omit_hashtag(message, hashtag):\n    return message.replace(hashtag, \"\", 1)",
        "inputs": [
            [
                "\"Sunny day! #lta #vvv\"",
                "\"#lta\""
            ],
            [
                "\"#lta #picture_contest\"",
                "\"#lta\""
            ],
            [
                "\"#lta #picture_contest #lta\"",
                "\"#lta\""
            ]
        ],
        "outputs": [
            [
                "\"Sunny day!  #vvv\""
            ],
            [
                "\" #picture_contest\""
            ],
            [
                "\" #picture_contest #lta\""
            ]
        ],
        "starter_code": "\ndef omit_hashtag(message, hashtag):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef solution(to_cur,value):\n\t    \"\"\"Given the current exchange rate between the USD and the EUR is 1.1363636 write a function that will accept the Curency type to be returned and a list of the amounts that need to be converted.\n\nDon't forget this is a currency so the result will need to be rounded to the second decimal. \n\n'USD' Return format should be `'$100,000.00'`\n\n'EUR' Return format for this kata should be `'100,000.00€'`\n\n`to_currency` is a string with values `'USD','EUR'` , `values_list` is a list of floats\n\n`solution(to_currency,values)`\n\n\n#EXAMPLES: \n\n```\nsolution('USD',[1394.0, 250.85, 721.3, 911.25, 1170.67]) \n= ['$1,584.09', '$285.06', '$819.66', '$1,035.51', '$1,330.31']\n\nsolution('EUR',[109.45, 640.31, 1310.99, 669.51, 415.54]) \n= ['96.32€', '563.47€', '1,153.67€', '589.17€', '365.68€']\n\n\n\n```\n    \"\"\"\n",
        "canonical_solution": "def solution(to,lst):\n    dolSym, eurSym, power = ('', '€', -1) if to=='EUR' else ('$','', 1)\n    return [f\"{ dolSym }{ v*1.1363636**power :,.2f}{ eurSym }\" for v in lst]",
        "inputs": [
            [
                "\"USD\"",
                [
                    1.01,
                    83.29,
                    5.0,
                    23.23,
                    724.22
                ]
            ],
            [
                "\"USD\"",
                [
                    1394.0,
                    250.85,
                    721.3,
                    911.25,
                    1170.67
                ]
            ],
            [
                "\"EUR\"",
                [
                    109.45,
                    640.31,
                    1310.99,
                    669.51,
                    415.54
                ]
            ]
        ],
        "outputs": [
            [
                [
                    "$1.15",
                    "$94.65",
                    "$5.68",
                    "$26.40",
                    "$822.98"
                ]
            ],
            [
                [
                    "$1,584.09",
                    "$285.06",
                    "$819.66",
                    "$1,035.51",
                    "$1,330.31"
                ]
            ],
            [
                [
                    "96.32€",
                    "563.47€",
                    "1,153.67€",
                    "589.17€",
                    "365.68€"
                ]
            ]
        ],
        "starter_code": "\ndef solution(to_cur,value):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "List Comprehension",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n            \"\"\"In a deck of cards, each card has an integer written on it.\nReturn true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:\n\nEach group has exactly X cards.\nAll the cards in each group have the same integer.\n\n \nExample 1:\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\n\nExample 2:\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false´\nExplanation: No possible partition.\n\nExample 3:\nInput: deck = [1]\nOutput: false\nExplanation: No possible partition.\n\nExample 4:\nInput: deck = [1,1]\nOutput: true\nExplanation: Possible partition [1,1].\n\nExample 5:\nInput: deck = [1,1,2,2,2,2]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[2,2].\n\n \nConstraints:\n\n1 <= deck.length <= 10^4\n0 <= deck[i] < 10^4\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        def findGCD(a,b):\n            if b ==0:\n                return a\n            return findGCD(b, a%b)\n            \n        hash_cards = {}\n        for card in deck:\n            if card in hash_cards:\n                hash_cards[card]+=1\n            else:\n                hash_cards[card]=1\n        value_ = list(hash_cards.values())\n        res = value_[0]\n        for x in value_[1:]:\n            res = findGCD(res,x)\n        if res <2:\n            return False\n        return True\n        \n",
        "inputs": [
            [
                [
                    1,
                    2,
                    3,
                    4,
                    4,
                    3,
                    2,
                    1
                ]
            ]
        ],
        "outputs": [
            [
                true
            ]
        ],
        "starter_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                20
            ],
            [
                "Function Body",
                2,
                20
            ],
            [
                "Function Body",
                3,
                6
            ],
            [
                "If Statement Body",
                4,
                5
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                10,
                13
            ],
            [
                "For Loop Body",
                16,
                17
            ],
            [
                "If Statement Body",
                18,
                19
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef digits(n):\n\t    \"\"\"Determine the total number of digits in the integer (`n>=0`) given as input to the function. For example, 9 is a single digit, 66 has 2 digits and 128685 has 6 digits. Be careful to avoid overflows/underflows.\n\nAll inputs will be valid.\n    \"\"\"\n",
        "canonical_solution": "def digits(n):\n    return len(str(n))",
        "inputs": [
            [
                5
            ],
            [
                12345
            ],
            [
                9876543210
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                5
            ],
            [
                10
            ]
        ],
        "starter_code": "\ndef digits(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef char_to_ascii(string):\n\t    \"\"\"Take a string and return a hash with all the ascii values of the characters in the string.\nReturns nil if the string is empty.\nThe key is the character, and the value is the ascii value of the character.\nRepeated characters are to be ignored and non-alphebetic characters as well.\n    \"\"\"\n",
        "canonical_solution": "def char_to_ascii(string):\n    return {c: ord(c) for c in set(string) if c.isalpha()} if len(string) else None",
        "inputs": [
            [
                "\"\""
            ],
            [
                "\"a\""
            ],
            [
                "\"aaa\""
            ]
        ],
        "outputs": [
            [
                null
            ],
            [
                {
                    "a": 97
                }
            ],
            [
                {
                    "a": 97
                }
            ]
        ],
        "starter_code": "\ndef char_to_ascii(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Dict Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef format_poem(poem):\n\t    \"\"\"You have a collection of lovely poems. Unfortuantely they aren't formatted very well. They're all on one line, like this:\n\n```\nBeautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated.\n```\nWhat you want is to present each sentence on a new line, so that it looks like this:\n```\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\n```\nWrite a function, `format_poem()` that takes a string like the one line example as an argument and returns a new string that is formatted across multiple lines with each new sentence starting on a new line when you print it out.\n\nTry to solve this challenge with the [str.split()](https://docs.python.org/3/library/stdtypes.html#str.split) and the [str.join()](https://docs.python.org/3/library/stdtypes.html#str.join) string methods.\n\nEvery sentence will end with a period, and every new sentence will have one space before the previous period. Be careful about trailing whitespace in your solution.\n    \"\"\"\n",
        "canonical_solution": "def format_poem(poem):\n  return \".\\n\".join(poem.split(\". \"))",
        "inputs": [
            [
                "\"Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated.\""
            ],
            [
                "\"Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules.\""
            ],
            [
                "\"Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess.\""
            ]
        ],
        "outputs": [
            [
                "\"Beautiful is better than ugly.\\nExplicit is better than implicit.\\nSimple is better than complex.\\nComplex is better than complicated.\""
            ],
            [
                "\"Flat is better than nested.\\nSparse is better than dense.\\nReadability counts.\\nSpecial cases aren't special enough to break the rules.\""
            ],
            [
                "\"Although practicality beats purity.\\nErrors should never pass silently.\\nUnless explicitly silenced.\\nIn the face of ambiguity, refuse the temptation to guess.\""
            ]
        ],
        "starter_code": "\ndef format_poem(poem):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef meters(x):\n\t    \"\"\"Scientists working internationally use metric units almost exclusively. Unless that is, they wish to crash multimillion dollars worth of equipment on Mars.\n\nYour task is to write a simple function that takes a number of meters, and outputs it using metric prefixes.\n\nIn practice, meters are only measured in \"mm\" (thousandths of a meter), \"cm\" (hundredths of a meter), \"m\" (meters) and \"km\" (kilometers, or clicks for the US military).\n\nFor this exercise we just want units bigger than a meter, from meters up to yottameters, excluding decameters and hectometers.\n\nAll values passed in will be positive integers.\ne.g.\n\n```python\nmeters(5);\n// returns \"5m\"\n\nmeters(51500);\n// returns \"51.5km\"\n\nmeters(5000000);\n// returns \"5Mm\"\n```\n\nSee http://en.wikipedia.org/wiki/SI_prefix for a full list of prefixes\n    \"\"\"\n",
        "canonical_solution": "def meters(x):\n    #your code here\n    arr = ['','k','M','G','T','P','E','Z','Y']\n    count=0\n    while x>=1000 :\n        x /=1000.00 \n        count+=1\n    if int(x)==x:\n        x=int(x) \n    return str(x)+arr[count]+'m'\n",
        "inputs": [
            [
                1
            ],
            [
                999
            ],
            [
                123456
            ]
        ],
        "outputs": [
            [
                "\"1m\""
            ],
            [
                "\"999m\""
            ],
            [
                "\"123.456km\""
            ]
        ],
        "starter_code": "\ndef meters(x):\n",
        "scope": [
            [
                "Function Body",
                1,
                10
            ],
            [
                "While Loop Body",
                5,
                7
            ],
            [
                "If Statement Body",
                8,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef WEtFf():\n    \"\"\"Given are an integer X and an integer sequence of length N: p_1, \\ldots, p_N.\nAmong the integers not contained in the sequence p_1, \\ldots, p_N (not necessarily positive), find the integer nearest to X, that is, find the integer whose absolute difference with X is the minimum. If there are multiple such integers, report the smallest such integer.\n\n-----Constraints-----\n - 1 \\leq X \\leq 100\n - 0 \\leq N \\leq 100\n - 1 \\leq p_i \\leq 100\n - p_1, \\ldots, p_N are all distinct.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nX N\np_1 ... p_N\n\n-----Output-----\nPrint the answer.\n\n-----Sample Input-----\n6 5\n4 7 10 6 5\n\n-----Sample Output-----\n8\n\nAmong the integers not contained in the sequence 4, 7, 10, 6, 5, the one nearest to 6 is 8.\n    \"\"\"\n",
        "canonical_solution": "\ndef WEtFf():\n    x,n=map(int,input().split())\n    p=list(map(int,input().split()))\n    a=101\n    m=101-x\n    for i in range(102):\n      i=100-i\n      if i in p:\n        continue\n      M=abs(i-x)\n      if M<=m:\n        m=M\n        a=i\n    print(a)",
        "inputs": [
            "6 5\n4 7 10 6 5\n",
            "10 5\n4 7 10 6 5\n",
            "100 0\n\n"
        ],
        "outputs": [
            "8\n",
            "9\n",
            "100\n"
        ],
        "starter_code": "\ndef WEtFf():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                7,
                14
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "If Statement Body",
                12,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef CgnOD():\n    \"\"\"A ball will bounce along a number line, making N + 1 bounces. It will make the first bounce at coordinate D_1 = 0, and the i-th bounce (2 \\leq i \\leq N+1) at coordinate D_i = D_{i-1} + L_{i-1}.\nHow many times will the ball make a bounce where the coordinate is at most X?\n\n-----Constraints-----\n - 1 \\leq N \\leq 100\n - 1 \\leq L_i \\leq 100\n - 1 \\leq X \\leq 10000\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN X\nL_1 L_2 ... L_{N-1} L_N\n\n-----Output-----\nPrint the number of times the ball will make a bounce where the coordinate is at most X.\n\n-----Sample Input-----\n3 6\n3 4 5\n\n-----Sample Output-----\n2\n\nThe ball will make a bounce at the coordinates 0, 3, 7 and 12, among which two are less than or equal to 6.\n    \"\"\"\n",
        "canonical_solution": "import itertools\nimport bisect\ndef CgnOD():\n    n, x = map(int, input().split())\n    l = list(map(int, input().split()))\n    a = list(itertools.accumulate(l, initial=0))\n    print(bisect.bisect_right(a, x))",
        "inputs": [
            "3 6\n3 4 5\n",
            "4 9\n3 3 3 3\n",
            "90 2575\n69 34 43 51 96 65 22 57 26 27 85 62 92 99 90 52 43 63 17 97 93 35 1 53 95 34 98 9 62 37 39 97 49 71 100 78 22 45 87 61 44 18 64 10 48 34 87 57 39 32 46 83 29 16 27 54 42 32 6 64 11 5 25 76 69 93 15 32 59 79 94 76 32 32 26 9 37 28 92 12 65 86 14 36 44 78 47 77 81 23\n"
        ],
        "outputs": [
            "2\n",
            "4\n",
            "47\n"
        ],
        "starter_code": "\ndef CgnOD():\n",
        "scope": [
            [
                "Function Body",
                3,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n            \"\"\"Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n\nIf the last word does not exist, return 0.\n\nNote: A word is defined as a character sequence consists of non-space characters only.\n\nExample:\n\nInput: \"Hello World\"\nOutput: 5\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def lengthOfLastWord(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         x = s.split()\n         return len(x[-1]) if len(x) > 0 else 0",
        "inputs": [
            [
                "\"Hello World\""
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                8
            ],
            [
                "Function Body",
                2,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef changer(string):\n\t    \"\"\"Create a function that takes a string as a parameter and does the following, in this order:\n\n1. replaces every letter with the letter following it in the alphabet (see note below)\n2. makes any vowels capital\n3. makes any consonants lower case\n\n**Note:** the alphabet should wrap around, so `Z` becomes `A`\n\nSo, for example the string `\"Cat30\"` would return `\"dbU30\"` (`Cat30 --> Dbu30 --> dbU30`)\n    \"\"\"\n",
        "canonical_solution": "def changer(s):\n    return s.lower().translate(str.maketrans('abcdefghijklmnopqrstuvwxyz', 'bcdEfghIjklmnOpqrstUvwxyzA'))",
        "inputs": [
            [
                "\"Cat30\""
            ],
            [
                "\"Alice\""
            ],
            [
                "\"sponge1\""
            ]
        ],
        "outputs": [
            [
                "\"dbU30\""
            ],
            [
                "\"bmjdf\""
            ],
            [
                "\"tqpOhf1\""
            ]
        ],
        "starter_code": "\ndef changer(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef find_lowest_int(k):\n\t    \"\"\"We have two consecutive integers k1 and k2, k2 = k1 + 1\n\nWe need to calculate the lowest integer `n`, such that:\nthe values nk1 and nk2 have the same digits but in different order.\n\nE.g.# 1:\n```\nk1 = 100\nk2 = 101\nn = 8919\n#Because 8919 * 100 = 891900 \nand      8919 * 101 = 900819\n```\n\nE.g.# 2:\n```\nk1 = 325\nk2 = 326\nn = 477\n#Because 477 * 325 = 155025\nand      477 * 326 = 155502\n```\n\nYour task is to prepare a function that will receive the value of `k` and outputs the value of `n`.\n\nThe examples given above will be:\n```python\nfind_lowest_int(100) === 8919\nfind_lowest_int(325) ===  477\n```\nFeatures of the random tests\n```\n10 < k < 10.000.000.000.000.000 (For Python, Ruby and Haskell)\n10 < k < 1.000.000.000  (For Javascript 1e9)\n```\nEnjoy it!!\n\nRuby and Javascript versions will be released soon.\n    \"\"\"\n",
        "canonical_solution": "def find_lowest_int(k1):\n    k2, n = k1 + 1, 1\n\n    def digits(n):\n        return sorted(str(n))\n    \n    while digits(n*k1) != digits(n*k2):\n        n += 1\n    \n    return n",
        "inputs": [
            [
                325
            ],
            [
                599
            ],
            [
                855
            ]
        ],
        "outputs": [
            [
                477
            ],
            [
                2394
            ],
            [
                999
            ]
        ],
        "starter_code": "\ndef find_lowest_int(k):\n",
        "scope": [
            [
                "Function Body",
                1,
                10
            ],
            [
                "Function Body",
                4,
                5
            ],
            [
                "While Loop Body",
                7,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef string_clean(s):\n\t    \"\"\"Your boss decided to save money by purchasing some cut-rate optical character recognition software for scanning in the text of old novels to your database. At first it seems to capture words okay, but you quickly notice that it throws in a lot of numbers at random places in the text. For example:\n\n```python\nstring_clean('! !') == '! !'\nstring_clean('123456789') == ''\nstring_clean('This looks5 grea8t!') == 'This looks great!'\n\n```\n\nYour harried co-workers are looking to you for a solution to take this garbled text and remove all of the numbers. Your program will take in a string and clean out all numeric characters, and return a string with spacing and special characters `~#$%^&!@*():;\"'.,?` all intact.\n    \"\"\"\n",
        "canonical_solution": "def string_clean(s):\n    return ''.join(x for x in s if not x.isdigit())",
        "inputs": [
            [
                "\"\""
            ],
            [
                "\"! !\""
            ],
            [
                "\"123456789\""
            ]
        ],
        "outputs": [
            [
                "\"\""
            ],
            [
                "\"! !\""
            ],
            [
                "\"\""
            ]
        ],
        "starter_code": "\ndef string_clean(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef check_dates(records):\n\t    \"\"\"## Story\n\nYour company migrated the last 20 years of it's *very important data* to a new platform, in multiple phases. However, something went wrong: some of the essential time-stamps were messed up! It looks like that some servers were set to use the `dd/mm/yyyy` date format, while others were using the `mm/dd/yyyy` format during the migration. Unfortunately, the original database got corrupted in the process and there are no backups available... Now it's up to you to assess the damage.\n\n## Task\n\nYou will receive a list of records as strings in the form of `[start_date, end_date]` given in the ISO `yyyy-mm-dd` format, and your task is to count how many of these records are: \n* **correct**: there can be nothing wrong with the dates, the month/day cannot be mixed up, or it would not make a valid timestamp in any other way; e.g. `[\"2015-04-04\", \"2015-05-13\"]`\n* **recoverable**: invalid in its current form, but the original timestamp can be recovered, because there is only one valid combination possible; e.g. `[\"2011-10-08\", \"2011-08-14\"]`\n* **uncertain**: one or both dates are ambiguous, and they may generate multiple valid timestamps, so the original cannot be retrieved; e.g. `[\"2002-02-07\", \"2002-12-10\"]`\n\n**Note:** the original records always defined a *non-negative* duration\n\nReturn your findings in an array: `[ correct_count, recoverable_count, uncertain_count ]`\n\n## Examples\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n    \"\"\"\n",
        "canonical_solution": "def candidates(ymd):\n    y, m, d = ymd.split('-')\n    return {ymd, f'{y}-{d}-{m}'}\n\ndef check_dates(records):\n    result = [0, 0, 0]\n    for start, end in records:\n        xs = [(dt1, dt2) for dt1 in candidates(start) for dt2 in candidates(end)\n              if dt1 <= dt2 and dt1[5:7] <= '12' >= dt2[5:7]]\n        i = 2 if len(xs) > 1 else xs[0] != (start, end)\n        result[i] += 1  # 2: uncertain, 1(True): recoverable, 0(False): correct\n    return result",
        "inputs": [
            [
                []
            ]
        ],
        "outputs": [
            [
                [
                    0,
                    0,
                    0
                ]
            ]
        ],
        "starter_code": "\ndef check_dates(records):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "Function Body",
                5,
                12
            ],
            [
                "For Loop Body",
                7,
                11
            ],
            [
                "List Comprehension",
                8,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef play_pass(s, n):\n\t    \"\"\"Everyone knows passphrases. One can choose passphrases from poems, songs, movies names and so on but frequently\nthey can be guessed due to common cultural references.\nYou  can get your passphrases stronger by different means. One is the following:\n\nchoose a text in capital letters including or not digits and non alphabetic characters,\n \n1. shift each letter by a given number but the transformed letter must be a letter (circular shift), \n2. replace each digit by its complement to 9, \n3. keep such as non alphabetic and non digit characters, \n4. downcase each letter in odd position, upcase each letter in even position (the first character is in position 0), \n5. reverse the whole result.\n\n#Example:\n\nyour text: \"BORN IN 2015!\", shift 1\n\n1 + 2 + 3 -> \"CPSO JO 7984!\"\n\n4 \"CpSo jO 7984!\"\n\n5 \"!4897 Oj oSpC\"\n\nWith longer passphrases it's better to have a small and easy program.\nWould you write it?\n\nhttps://en.wikipedia.org/wiki/Passphrase\n    \"\"\"\n",
        "canonical_solution": "def play_pass(s, n):\n\n    # Step 1, 2, 3\n    shiftText = \"\"\n    for char in s:\n        if char.isdigit():\n            shiftText += str(9 - int(char))\n        elif char.isalpha():\n            shifted = ord(char.lower()) + n\n            shiftText += chr(shifted) if shifted <= ord('z') else chr(shifted - 26)\n        else:\n            shiftText += char\n\n    # Step 4\n    caseText = \"\"\n    for i in range(len(shiftText)):\n        caseText += shiftText[i].upper() if i % 2 == 0 else shiftText[i].lower()\n\n    # Step 5\n    return caseText[::-1]\n\n",
        "inputs": [
            [
                "\"I LOVE YOU!!!\"",
                1
            ],
            [
                "\"I LOVE YOU!!!\"",
                0
            ],
            [
                "\"AAABBCCY\"",
                1
            ]
        ],
        "outputs": [
            [
                "\"!!!vPz fWpM J\""
            ],
            [
                "\"!!!uOy eVoL I\""
            ],
            [
                "\"zDdCcBbB\""
            ]
        ],
        "starter_code": "\ndef play_pass(s, n):\n",
        "scope": [
            [
                "Function Body",
                1,
                20
            ],
            [
                "For Loop Body",
                5,
                12
            ],
            [
                "If Statement Body",
                6,
                12
            ],
            [
                "If Statement Body",
                8,
                12
            ],
            [
                "For Loop Body",
                16,
                17
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef hHmKP():\n    \"\"\"This problem is actually a subproblem of problem G from the same contest.\n\nThere are $n$ candies in a candy box. The type of the $i$-th candy is $a_i$ ($1 \\le a_i \\le n$).\n\nYou have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $1$ and two candies of type $2$ is bad). \n\nIt is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.\n\nYour task is to find out the maximum possible size of the single gift you can prepare using the candies you have.\n\nYou have to answer $q$ independent queries.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries. Each query is represented by two lines.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of candies.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), where $a_i$ is the type of the $i$-th candy in the box.\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each query print one integer — the maximum possible size of the single gift you can compose using candies you got in this query with the restriction described in the problem statement.\n\n\n-----Example-----\nInput\n3\n8\n1 4 8 4 5 6 3 8\n16\n2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1\n9\n2 2 4 4 4 7 7 7 7\n\nOutput\n3\n10\n9\n\n\n\n-----Note-----\n\nIn the first query, you can prepare a gift with two candies of type $8$ and one candy of type $5$, totalling to $3$ candies.\n\nNote that this is not the only possible solution — taking two candies of type $4$ and one candy of type $6$ is also valid.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef hHmKP():\n    input = sys.stdin.readline\n    Q = int(input())\n    for _ in range(Q):\n        N = int(input())\n        A = [int(a) for a in input().split()]\n        X = {}\n        for a in A:\n            if a in X:\n                X[a] += 1\n            else:\n                X[a] = 1\n        Y = []\n        for x in X:\n            Y.append(X[x])\n        Y = sorted(Y)[::-1]\n        prev = Y[0] + 1\n        su = 0\n        for i in range(len(Y)):\n            ne = min(prev-1, Y[i])\n            if ne <= 0:\n                break\n            su += ne\n            prev = ne\n        print(su)",
        "inputs": [
            "3\n8\n1 4 8 4 5 6 3 8\n16\n2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1\n9\n2 2 4 4 4 7 7 7 7\n"
        ],
        "outputs": [
            "3\n10\n9\n"
        ],
        "starter_code": "\ndef hHmKP():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "For Loop Body",
                5,
                26
            ],
            [
                "List Comprehension",
                7,
                7
            ],
            [
                "For Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                10,
                13
            ],
            [
                "For Loop Body",
                15,
                16
            ],
            [
                "For Loop Body",
                20,
                25
            ],
            [
                "If Statement Body",
                22,
                23
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef pattern(n):\n\t    \"\"\"## Task \n\nUsing `n` as a parameter in the function `pattern`, where `n>0`, complete the codes to get the pattern (take the help of examples):\n\n**Note:** There is no newline in the end (after the pattern ends)\n\n\n### Examples\n\n`pattern(3)` should return `\"1\\n1*2\\n1**3\"`, e.g. the following:\n```\n1\n1*2\n1**3\n```\n`pattern(10):` should return the following:\n```\n1\n1*2\n1**3\n1***4\n1****5\n1*****6\n1******7\n1*******8\n1********9\n1*********10\n```\n    \"\"\"\n",
        "canonical_solution": "def pattern(n):\n    return '\\n'.join(['1'] + ['1' + '*' * (i-1) + str(i) for i in range(2, n+1)])\n",
        "inputs": [
            [
                3
            ],
            [
                7
            ],
            [
                20
            ]
        ],
        "outputs": [
            [
                "\"1\\n1*2\\n1**3\""
            ],
            [
                "\"1\\n1*2\\n1**3\\n1***4\\n1****5\\n1*****6\\n1******7\""
            ],
            [
                "\"1\\n1*2\\n1**3\\n1***4\\n1****5\\n1*****6\\n1******7\\n1*******8\\n1********9\\n1*********10\\n1**********11\\n1***********12\\n1************13\\n1*************14\\n1**************15\\n1***************16\\n1****************17\\n1*****************18\\n1******************19\\n1*******************20\""
            ]
        ],
        "starter_code": "\ndef pattern(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef Gfuev():\n    \"\"\"Given is an integer x that is greater than or equal to 0, and less than or equal to 1.\nOutput 1 if x is equal to 0, or 0 if x is equal to 1.\n\n-----Constraints-----\n - 0 \\leq x \\leq 1\n - x is an integer\n\n-----Input-----\nInput is given from Standard Input in the following format:\nx\n\n-----Output-----\nPrint 1 if x is equal to 0, or 0 if x is equal to 1.\n\n-----Sample Input-----\n1\n\n-----Sample Output-----\n0\n\n    \"\"\"\n",
        "canonical_solution": "\ndef Gfuev():\n    X=int(input())\n    print(1-X)",
        "inputs": [
            "1\n",
            "0\n"
        ],
        "outputs": [
            "0\n",
            "1\n"
        ],
        "starter_code": "\ndef Gfuev():\n",
        "scope": [
            [
                "Function Body",
                2,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef outcome(n, s, k):\n\t    \"\"\"You have n dices each one having s sides numbered from 1 to s.\nHow many outcomes add up to a specified number k?\n\nFor example if we roll four normal six-sided dices we\nhave four outcomes that add up to 5. \n\n(1, 1, 1, 2)\n(1, 1, 2, 1)\n(1, 2, 1, 1)\n(2, 1, 1, 1)\n    \"\"\"\n",
        "canonical_solution": "def outcome(n, s, k):    \n    if n == 1: return 1 if 0 < k <= s else 0\n    return sum(outcome(n - 1, s, k - j - 1) for j in range(s)) if k > 0 else 0",
        "inputs": [
            [
                1,
                6,
                0
            ],
            [
                1,
                0,
                1
            ],
            [
                0,
                6,
                1
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                0
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef outcome(n, s, k):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "If Statement Body",
                2,
                2
            ],
            [
                "Generator Expression",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef no_repeat(string):\n\t    \"\"\"**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #16\n\nCreate a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string.\n\n``` haskell\nnoRepeat \"aabbccdde\" `shouldBe` 'e'\nnoRepeat \"wxyz\"      `shouldBe` 'w'\nnoRepeat \"testing\"   `shouldBe` 'e'\n```\n\nNote:\nONLY letters from the english alphabet will be used as input\nThere will ALWAYS be at least one non-repeating letter in the input string\n    \"\"\"\n",
        "canonical_solution": "def no_repeat(s):\n    return next(c for c in s if s.count(c) == 1)",
        "inputs": [
            [
                "\"aabbccdde\""
            ],
            [
                "\"wxyz\""
            ],
            [
                "\"testing\""
            ]
        ],
        "outputs": [
            [
                "\"e\""
            ],
            [
                "\"w\""
            ],
            [
                "\"e\""
            ]
        ],
        "starter_code": "\ndef no_repeat(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef even_fib(m):\n\t    \"\"\"Give the summation of all even numbers in a Fibonacci sequence up to, but not including, the maximum value.\n\nThe Fibonacci sequence is a series of numbers where the next value is the addition of the previous two values. The series starts with 0 and 1:\n\n0 1 1 2 3 5 8 13 21...\n\nFor example:\n```python\neve_fib(0)==0\neve_fib(33)==10\neve_fib(25997544)==19544084\n```\n    \"\"\"\n",
        "canonical_solution": "def even_fib(m):\n    x,y = 0, 1\n    counter = 0\n    while y < m:\n        if y % 2 == 0:\n            counter += y\n        x,y = y, x+ y\n    return counter",
        "inputs": [
            [
                0
            ],
            [
                10
            ],
            [
                5
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                10
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef even_fib(m):\n",
        "scope": [
            [
                "Function Body",
                1,
                8
            ],
            [
                "While Loop Body",
                4,
                7
            ],
            [
                "If Statement Body",
                5,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef GTmAs():\n    \"\"\"Given is a positive integer L.\nFind the maximum possible volume of a rectangular cuboid whose sum of the dimensions (not necessarily integers) is L.\n\n-----Constraints-----\n - 1 ≤ L ≤ 1000\n - L is an integer.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nL\n\n-----Output-----\nPrint the maximum possible volume of a rectangular cuboid whose sum of the dimensions (not necessarily integers) is L.\nYour output is considered correct if its absolute or relative error from our answer is at most 10^{-6}.\n\n-----Sample Input-----\n3\n\n-----Sample Output-----\n1.000000000000\n\nFor example, a rectangular cuboid whose dimensions are 0.8, 1, and 1.2 has a volume of 0.96.\nOn the other hand, if the dimensions are 1, 1, and 1, the volume of the rectangular cuboid is 1, which is greater.\n    \"\"\"\n",
        "canonical_solution": "\ndef GTmAs():\n    L = int(input())\n    \n    ans = (L / 3) ** 3\n    \n    print(ans)",
        "inputs": [
            "3\n",
            "999\n",
            "430\n"
        ],
        "outputs": [
            "1.0\n",
            "36926037.0\n",
            "2944703.7037037043\n"
        ],
        "starter_code": "\ndef GTmAs():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef number_increasing(n):\n\t    \"\"\"# Task\n Initially a number `1` is written on a board. It is possible to do the following operations with it:\n```\nmultiply the number by 3;\nincrease the number by 5.```\nYour task is to determine that using this two operations step by step, is it possible to obtain number `n`?\n\n# Example\n\n For `n = 1`, the result should be `true`.\n \n `1 = 1`\n \n For `n = 2`, the result should be `false`.\n \n For `n = 3`, the result should be `true`.\n \n `1 x 3 = 3`\n \n For `n = 4`, the result should be `false`.\n \n For `n = 5`, the result should be `false`.\n \n For `n = 6`, the result should be `true`.\n \n `1 + 5 = 6`\n \n For `n = 18`, the result should be `true`.\n \n `1 + 5 = 6  --> 6 x 3 = 18`\n \n For `n = 32`, the result should be `true`.\n \n `1 x 3 x 3 x 3 = 27  --> 27 + 5 = 32`\n \n For `n = 100`, the result should be `false`.\n \n For `n = 101`, the result should be `true`.\n \n `1 + 5 + 5 + 5 ... +5 = 101`\n \n# Input / Output\n\n\n - `[input]` integer n\n\n  positive integer, n ≤ 100000\n\n\n - `[output]` a boolean value\n\n  `true` if N can be obtained using given operations, `false` otherwise.\n    \"\"\"\n",
        "canonical_solution": "def number_increasing(n):\n    return n not in {2, 4, 7, 12, 17, 22} and n % 5 != 0\n",
        "inputs": [
            [
                1
            ],
            [
                2
            ],
            [
                3
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                true
            ]
        ],
        "starter_code": "\ndef number_increasing(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef highest_age(group1,group2):\n\t    \"\"\"Algorithmic predicament - Bug Fixing #9\n\nOh no! Timmy's algorithim has gone wrong! help Timmy fix his algorithim! \n\nTask\nYour task is to fix timmy's algorithim so it returns the group name with the highest total age. \n\nYou will receive two groups of `people` objects, with two properties `name` and `age`. The name property is a string and the age property is a number.  \nYour goal is to make the total the age of all people having the same name through both groups and return the name of the one with the highest age. If two names have the same total age return the first alphabetical name.\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter\nfrom itertools import chain\n\n\ndef highest_age(persons1, persons2):\n    c = Counter()\n\n    for p in chain(persons1, persons2):\n        c[p['name']] += p['age']\n\n    return min(iter(c.items()), key=lambda n_a: (-n_a[1], n_a[0]))[0] if c else None\n",
        "inputs": [
            [
                [
                    {
                        "name": "kay",
                        "age": 1
                    },
                    {
                        "name": "john",
                        "age": 13
                    },
                    {
                        "name": "kay",
                        "age": 76
                    }
                ],
                [
                    {
                        "name": "john",
                        "age": 1
                    },
                    {
                        "name": "alice",
                        "age": 77
                    }
                ]
            ],
            [
                [
                    {
                        "name": "kay",
                        "age": 1
                    },
                    {
                        "name": "john",
                        "age": 13
                    },
                    {
                        "name": "kay",
                        "age": 76
                    }
                ],
                [
                    {
                        "name": "john",
                        "age": 1
                    },
                    {
                        "name": "alice",
                        "age": 76
                    }
                ]
            ],
            [
                [
                    {
                        "name": "kay",
                        "age": 1
                    },
                    {
                        "name": "john",
                        "age": 130
                    },
                    {
                        "name": "kay",
                        "age": 76
                    }
                ],
                [
                    {
                        "name": "john",
                        "age": 1
                    },
                    {
                        "name": "alice",
                        "age": 76
                    }
                ]
            ]
        ],
        "outputs": [
            [
                "\"alice\""
            ],
            [
                "\"kay\""
            ],
            [
                "\"john\""
            ]
        ],
        "starter_code": "\ndef highest_age(group1,group2):\n",
        "scope": [
            [
                "Function Body",
                5,
                11
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "Lambda Expression",
                11,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef next_numb(val):\n\t    \"\"\"Make a function that receives a value, ```val``` and outputs the smallest higher number than the given value, and this number belong to a set of positive integers that have the following properties:\n\n- their digits occur only once\n\n- they are odd\n\n- they are multiple of three\n\n```python\nnext_numb(12) == 15\n\nnext_numb(13) == 15\n\nnext_numb(99) == 105\n\nnext_numb(999999) == 1023459\n\nnext_number(9999999999) == \"There is no possible number that\nfulfills those requirements\"\n```\n\nEnjoy the kata!!\n    \"\"\"\n",
        "canonical_solution": "def unique_digits(n):\n    return len(set(str(n))) == len(str(n))\n\ndef next_numb(val):\n    val += 1\n    while val % 3: val += 1\n    if val % 2 == 0: val += 3\n    \n    while not unique_digits(val):\n        val += 6\n        if val > 9876543210: break\n    else:\n        return val\n    \n    return \"There is no possible number that fulfills those requirements\"\n",
        "inputs": [
            [
                12
            ],
            [
                13
            ],
            [
                99
            ]
        ],
        "outputs": [
            [
                15
            ],
            [
                15
            ],
            [
                105
            ]
        ],
        "starter_code": "\ndef next_numb(val):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Function Body",
                4,
                15
            ],
            [
                "While Loop Body",
                6,
                6
            ],
            [
                "If Statement Body",
                7,
                7
            ],
            [
                "While Loop Body",
                9,
                13
            ],
            [
                "If Statement Body",
                11,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef is_substitution_cipher(s1, s2):\n\t    \"\"\"# Task\n A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n\n Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.\n\n# Example\n\n For `string1 = \"aacb\" and string2 = \"aabc\"`, the output should be `true`\n\n Any ciphertext alphabet that starts with acb... would make this transformation possible.\n\n For `string1 = \"aa\" and string2 = \"bc\"`, the output should be `false`\n\n# Input/Output\n\n\n - `[input]` string `string1`\n\n    A string consisting of lowercase characters.\n\n    Constraints: `1 ≤ string1.length ≤ 10`.\n\n\n - `[input]` string `string2`\n\n    A string consisting of lowercase characters of the same length as string1.\n\n    Constraints: `string2.length = string1.length`.\n\n\n - `[output]` a boolean value\n    \"\"\"\n",
        "canonical_solution": "def is_substitution_cipher(s1, s2):\n    return len(set(s1)) == len(set(s2)) == len(set(zip(s1, s2)))",
        "inputs": [
            [
                "\"aacb\"",
                "\"aabc\""
            ],
            [
                "\"aa\"",
                "\"bc\""
            ],
            [
                "\"aaxxaaz\"",
                "\"aazzaay\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                true
            ]
        ],
        "starter_code": "\ndef is_substitution_cipher(s1, s2):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef not_so_random(b,w):\n\t    \"\"\"# Task\n You are a magician. You're going to perform a trick.\n\n You have `b` black marbles and `w` white marbles in your magic hat, and an infinite supply of black and white marbles that you can pull out of nowhere. \n \n You ask your audience to repeatedly remove a pair of marbles from your hat and, for each pair removed, you add one marble to the hat according to the following rule until there is only 1 marble left. \n\n If the marbles of the pair that is removed are of the same color, you add a white marble to the hat. Otherwise, if one is black and one is white, you add a black marble.\n \n Given the initial number of black and white marbles in your hat, your trick is to predict the color of the last marble.\n \n Note: A magician may confuse your eyes, but not your mind ;-)\n\n# Input/Output\n\n\n - `[input]` integer `b`\n\n  Initial number of black marbles in the hat. \n  \n  `1 <= b <= 10^9`\n\n\n - `[input]` integer `w`\n\n  Initial number of white marbles in the hat. \n  \n  `1 <= w <= 10^9`\n\n\n - `[output]` a string\n\n  `\"Black\"` or `\"White\"` if you can safely predict the color of the last marble. If not, return `\"Unsure\"`.\n    \"\"\"\n",
        "canonical_solution": "def not_so_random(b,w):\n  return ['White', 'Black'][b % 2]",
        "inputs": [
            [
                1,
                1
            ],
            [
                2,
                1
            ],
            [
                1,
                2
            ]
        ],
        "outputs": [
            [
                "\"Black\""
            ],
            [
                "\"White\""
            ],
            [
                "\"Black\""
            ]
        ],
        "starter_code": "\ndef not_so_random(b,w):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef expanded_form(num):\n\t    \"\"\"# Write Number in Expanded Form - Part 2\n\nThis is version 2 of my ['Write Number in Exanded Form' Kata](https://www.codewars.com/kata/write-number-in-expanded-form).\n\nYou will be given a number and you will need to return it as a string in [Expanded Form](https://www.mathplacementreview.com/arithmetic/decimals.php#writing-a-decimal-in-expanded-form). For example:\n\n```python\nexpanded_form(1.24) # Should return '1 + 2/10 + 4/100'\nexpanded_form(7.304) # Should return '7 + 3/10 + 4/1000'\nexpanded_form(0.04) # Should return '4/100'\n```\n    \"\"\"\n",
        "canonical_solution": "def expanded_form(num):\n    integer_part, fractional_part = str(num).split('.')\n\n    result = [str(int(num) * (10 ** i)) for i, num in enumerate(integer_part[::-1]) if num != '0'][::-1]\n    result += [str(num) + '/' + str(10 ** (i + 1)) for i, num in enumerate(fractional_part) if num != '0']\n\n    return ' + '.join(result)\n",
        "inputs": [
            [
                1.24
            ],
            [
                7.304
            ],
            [
                0.04
            ]
        ],
        "outputs": [
            [
                "\"1 + 2/10 + 4/100\""
            ],
            [
                "\"7 + 3/10 + 4/1000\""
            ],
            [
                "\"4/100\""
            ]
        ],
        "starter_code": "\ndef expanded_form(num):\n",
        "scope": [
            [
                "Function Body",
                1,
                7
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "List Comprehension",
                5,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef pseudo_sort(st):\n\t    \"\"\"Given a standard english sentence passed in as a string, write a method that will return a sentence made up of the same words, but sorted by their first letter. However, the method of sorting has a twist to it:\n* All words that begin with a lower case letter should be at the beginning of the sorted sentence, and sorted in ascending order.\n* All words that begin with an upper case letter should come after that, and should be sorted in descending order.\n\nIf a word appears multiple times in the sentence, it should be returned multiple times in the sorted sentence. Any punctuation must be discarded.\n\n## Example\n\nFor example, given the input string `\"Land of the Old Thirteen! Massachusetts land! land of Vermont and Connecticut!\"`, your method should return `\"and land land of of the Vermont Thirteen Old Massachusetts Land Connecticut\"`. Lower case letters are sorted `a -> l -> l -> o -> o -> t` and upper case letters are sorted `V -> T -> O -> M -> L -> C`.\n    \"\"\"\n",
        "canonical_solution": "from string import punctuation\n\nt = str.maketrans(\"\", \"\", punctuation)\n\ndef pseudo_sort(s):\n    a = s.translate(t).split()\n    b = sorted(x for x in a if x[0].islower())\n    c = sorted((x for x in a if x[0].isupper()), reverse=True)\n    return \" \".join(b + c)",
        "inputs": [
            [
                "\"I, habitan of the Alleghanies, treating of him as he is in himself in his own rights\""
            ],
            [
                "\"take up the task eternal, and the burden and the lesson\""
            ],
            [
                "\"Land of the eastern Chesapeake\""
            ]
        ],
        "outputs": [
            [
                "\"as habitan he him himself his in in is of of own rights the treating I Alleghanies\""
            ],
            [
                "\"and and burden eternal lesson take task the the the up\""
            ],
            [
                "\"eastern of the Land Chesapeake\""
            ]
        ],
        "starter_code": "\ndef pseudo_sort(st):\n",
        "scope": [
            [
                "Function Body",
                5,
                9
            ],
            [
                "Generator Expression",
                7,
                7
            ],
            [
                "Generator Expression",
                8,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef fizz_buzz_cuckoo_clock(time):\n\t    \"\"\"## Your story\nYou've always loved both Fizz Buzz katas and cuckoo clocks, and when you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum, and a \"Beyond-Ultimate Raspberry Pi Starter Kit\" filled with all sorts of sensors and motors and other components, it's like you were suddenly hit by a beam of light and knew that it was your mission to combine the two to create a computerized Fizz Buzz cuckoo clock!\n\nYou took them home and set up shop on the kitchen table, getting more and more excited as you got everything working together just perfectly. Soon the only task remaining was to write a function to select from the sounds you had recorded depending on what time it was:\n\n## Your plan\n* When a minute is evenly divisible by three, the clock will say the word \"Fizz\".\n* When a minute is evenly divisible by five, the clock will say the word \"Buzz\".\n* When a minute is evenly divisible by both, the clock will say \"Fizz Buzz\", with two exceptions:\n  1. On the hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo bird will come out and \"Cuckoo\" between one and twelve times depending on the hour.\n  2. On the half hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo will come out and \"Cuckoo\" just once. \n* With minutes that are not evenly divisible by either three or five, at first you had intended to have the clock just say the numbers ala Fizz Buzz, but then you decided at least for version 1.0 to just have the clock make a quiet, subtle \"tick\" sound for a little more clock nature and a little less noise.\n\nYour input will be a string containing hour and minute values in 24-hour time, separated by a colon, and with leading zeros. For example, 1:34 pm would be `\"13:34\"`.\n\nYour return value will be a string containing the combination of Fizz, Buzz, Cuckoo, and/or tick sounds that the clock needs to make at that time, separated by spaces. Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time. \n\n## Some examples\n```\n\"13:34\"       \"tick\"\n\"21:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n\"11:15\"       \"Fizz Buzz\"\n\"03:03\"       \"Fizz\"\n\"14:30\"       \"Cuckoo\"\n\"08:55\"       \"Buzz\"\n\"00:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n\"12:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n```\nHave fun!\n    \"\"\"\n",
        "canonical_solution": "def fizz_buzz_cuckoo_clock(t):\n    h, m = list(map(int, t.split(':')))\n    h = h-12 if h > 12 else h+12 if h == 0 else h\n    \n    if m == 0:\n        return ' '.join('Cuckoo' for i in range(h))\n    if m == 30:\n        return 'Cuckoo'\n    if m%3 == 0 and m%5 == 0:\n        return 'Fizz Buzz'\n    if m%3 == 0:\n        return 'Fizz'\n    if m%5 == 0:\n        return 'Buzz'\n    return 'tick'\n    \n",
        "inputs": [
            [
                "\"13:34\""
            ],
            [
                "\"21:00\""
            ],
            [
                "\"11:15\""
            ]
        ],
        "outputs": [
            [
                "\"tick\""
            ],
            [
                "\"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\""
            ],
            [
                "\"Fizz Buzz\""
            ]
        ],
        "starter_code": "\ndef fizz_buzz_cuckoo_clock(time):\n",
        "scope": [
            [
                "Function Body",
                1,
                15
            ],
            [
                "If Statement Body",
                5,
                6
            ],
            [
                "Generator Expression",
                6,
                6
            ],
            [
                "If Statement Body",
                7,
                8
            ],
            [
                "If Statement Body",
                9,
                10
            ],
            [
                "If Statement Body",
                11,
                12
            ],
            [
                "If Statement Body",
                13,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef p_num(n):\n\t    \"\"\"## Task\n\nYou have to write three functions namely - `PNum, GPNum and SPNum` (JS, Coffee), `p_num, g_p_num and s_p_num` (Python and Ruby), `pNum, gpNum and spNum` (Java, C#), `p-num, gp-num and sp-num` (Clojure) - to check whether a given argument `n` is a Pentagonal, Generalized Pentagonal, or Square Pentagonal Number, and return `true` if it is and `false` otherwise.\n\n### Description\n\n\n\n\n`Pentagonal Numbers` - The nth pentagonal number Pn is the number of distinct dots in a pattern of dots consisting of the outlines of regular pentagons with sides up to n dots (means the side contains n number of dots), when the pentagons are overlaid so that they share one corner vertex.\n\n\n> First few Pentagonal Numbers are: 1, 5, 12, 22...\n\n`Generalized Pentagonal Numbers` - All the Pentagonal Numbers along with the number of dots inside the outlines of all the pentagons of a pattern forming a pentagonal number pentagon are called Generalized Pentagonal Numbers.\n\n> First few Generalized Pentagonal Numbers are: 0, 1, 2, 5, 7, 12, 15, 22...\n\n`Square Pentagonal Numbers` - The numbers which are Pentagonal Numbers and are also a perfect square are called Square Pentagonal Numbers. \n\n> First few are: 1, 9801, 94109401...\n \n### Examples\n\n#### Note: \n* Pn = Nth Pentagonal Number\n* Gpn = Nth Generalized Pentagonal Number\n\n\n\n    \n     ^        ^          ^             ^                 ^\n    P1=1     P2=5      P3=12         P4=22             P5=35   //Total number of distinct dots used in the Pattern\n    Gp2=1    Gp4=5     Gp6=12        Gp8=22                    //All the Pentagonal Numbers are Generalised\n             Gp1=0     Gp3=2         Gp5=7             Gp7=15  //Total Number of dots inside the outermost Pentagon\n    \"\"\"\n",
        "canonical_solution": "def p_num(n):\n    r = (1 + (24*n+1)**.5) / 6\n    return r.is_integer() and (3*(r**2) - r) / 2 == n \n    \ndef g_p_num(n):\n    r = ((1 + 24 * n) ** .5) % 6\n    return r != 0 and r.is_integer()\n\ns_p_num=lambda n:(n**.5).is_integer() and p_num(n) and g_p_num(n)",
        "inputs": [
            [
                0
            ],
            [
                1
            ],
            [
                2
            ]
        ],
        "outputs": [
            [
                false
            ],
            [
                true
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef p_num(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ],
            [
                "Function Body",
                5,
                7
            ],
            [
                "Lambda Expression",
                9,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef box_capacity(length, width, height):\n\t    \"\"\"Your company, [Congo Pizza](http://interesting-africa-facts.com/Africa-Landforms/Congo-Rainforest-Facts.html), is the second-largest online frozen pizza retailer. You own a number of international warehouses that you use to store your frozen pizzas, and you need to figure out how many crates of pizzas you can store at each location.\n\nCongo recently standardized its storage containers: all pizzas fit inside a *cubic crate, 16-inchs on a side*. The crates are super tough so you can stack them as high as you want.\n\nWrite a function `box_capacity()` that figures out how many crates you can store in a given warehouse. The function should take three arguments: the length, width, and height of your warehouse (in feet) and should return an integer representing the number of boxes you can store in that space.\n\nFor example: a warehouse 32 feet long, 64 feet wide, and 16 feet high can hold 13,824 boxes because you can fit 24 boxes across, 48 boxes deep, and 12 boxes high, so `box_capacity(32, 64, 16)` should return `13824`.\n    \"\"\"\n",
        "canonical_solution": "def box_capacity(length, width, height):\n    return (length * 12 // 16) * (width * 12 // 16) * (height * 12 // 16)\n",
        "inputs": [
            [
                32,
                64,
                16
            ],
            [
                20,
                20,
                20
            ],
            [
                80,
                40,
                20
            ]
        ],
        "outputs": [
            [
                13824
            ],
            [
                3375
            ],
            [
                27000
            ]
        ],
        "starter_code": "\ndef box_capacity(length, width, height):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def minOperations(self, logs: List[str]) -> int:\n            \"\"\"The Leetcode file system keeps a log each time some user performs a change folder operation.\nThe operations are described below:\n\n\"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).\n\"./\" : Remain in the same folder.\n\"x/\" : Move to the child folder named x (This folder is guaranteed to always exist).\n\nYou are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.\nThe file system starts in the main folder, then the operations in logs are performed.\nReturn the minimum number of operations needed to go back to the main folder after the change folder operations.\n \nExample 1:\n\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Use this change folder operation \"../\" 2 times and go back to the main folder.\n\nExample 2:\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nExample 3:\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0\n\n \nConstraints:\n\n1 <= logs.length <= 103\n2 <= logs[i].length <= 10\nlogs[i] contains lowercase English letters, digits, '.', and '/'.\nlogs[i] follows the format described in the statement.\nFolder names consist of lowercase English letters and digits.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        \n        t=0\n        for i in logs:\n            if i=='../':\n                t=t-1\n            elif i=='./':\n                t=t\n            else:\n                t=t+1\n            if t<0:\n                t=0\n        return t",
        "inputs": [
            [
                [
                    "\"d1/\"",
                    "\"d2/\"",
                    "\"../\"",
                    "\"d21/\"",
                    "\"./\""
                ]
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def minOperations(self, logs: List[str]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                14
            ],
            [
                "Function Body",
                2,
                14
            ],
            [
                "For Loop Body",
                5,
                13
            ],
            [
                "If Statement Body",
                6,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ],
            [
                "If Statement Body",
                12,
                13
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef bear_fur(bears):\n\t    \"\"\"A population of bears consists of black bears, brown bears, and white bears.\n\nThe input is an array of two elements. \n\nDetermine whether the offspring of the two bears will return `'black'`, `'brown'`, `'white'`, `'dark brown'`, `'grey'`, `'light brown'`, or `'unknown'`.\n\nElements in the the array will always be a string.\n\n\n\n## Examples:\n\n    bear_fur(['black', 'black'])  returns 'black'\n\n    bear_fur(['brown', 'brown'])  returns 'brown'\n\n    bear_fur(['white', 'white'])  returns 'white'\n\n    bear_fur(['black', 'brown'])  returns 'dark brown'\n\n    bear_fur(['black', 'white'])  returns 'grey'\n\n    bear_fur(['brown', 'white'])  returns 'light brown'\n\n    bear_fur(['yellow', 'magenta'])  returns 'unknown'\n    \"\"\"\n",
        "canonical_solution": "DEFAULT = 'unknown'\nCOLORS  = {'black'+'brown': 'dark brown',\n           'black'+'white': 'grey',\n           'brown'+'white': 'light brown'}\n\ndef bear_fur(bears):\n    b1,b2 = sorted(bears)\n    return b1 if b1==b2 else COLORS.get(b1+b2, DEFAULT)\n",
        "inputs": [
            [
                [
                    "black",
                    "black"
                ]
            ],
            [
                [
                    "white",
                    "white"
                ]
            ],
            [
                [
                    "brown",
                    "brown"
                ]
            ]
        ],
        "outputs": [
            [
                "\"black\""
            ],
            [
                "\"white\""
            ],
            [
                "\"brown\""
            ]
        ],
        "starter_code": "\ndef bear_fur(bears):\n",
        "scope": [
            [
                "Function Body",
                6,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef chessboard(s):\n\t    \"\"\"Write a program that prints a chessboard with N rows and M columns with the following rules:\nThe top left cell must be an asterisk (*)\nAny cell touching (left, right, up or down) a cell with an asterisk must be a dot (.)\nAny cell touching (left, right, up or down) a cell with a dot must be an asterisk.\n\nA chessboard of 8 rows and 8 columns printed using these rules would be:\n```\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n```\nInput\n\nA single line with two integers N and M separated by space. The number N will represent the number of rows and M the number of columns.\n\nOutput\n\nReturn N lines each containing M characters with the chessboard pattern.\nEmpty string if N, M or both are 0.\n\n\nFrom: 2016 AIPO National Finals\nhttp://aipo.computing.dcu.ie/2016-aipo-national-finals-problems\n    \"\"\"\n",
        "canonical_solution": "def chessboard(s):\n    N, M = map(int, s.split())\n    row = \".*\" * M\n    return \"\\n\".join( [row[:M] if i&1 else row[1:M+1] for i in range(N)] )",
        "inputs": [
            [
                "\"0 0\""
            ],
            [
                "\"1 0\""
            ],
            [
                "\"0 1\""
            ]
        ],
        "outputs": [
            [
                "\"\""
            ],
            [
                "\"\""
            ],
            [
                "\"\""
            ]
        ],
        "starter_code": "\ndef chessboard(s):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "List Comprehension",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef AElZb():\n    \"\"\"You are given an undirected graph consisting of $n$ vertices. A number is written on each vertex; the number on vertex $i$ is $a_i$. Initially there are no edges in the graph.\n\nYou may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $x$ and $y$ is $a_x + a_y$ coins. There are also $m$ special offers, each of them is denoted by three numbers $x$, $y$ and $w$, and means that you can add an edge connecting vertices $x$ and $y$ and pay $w$ coins for it. You don't have to use special offers: if there is a pair of vertices $x$ and $y$ that has a special offer associated with it, you still may connect these two vertices paying $a_x + a_y$ coins for it.\n\nWhat is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it's possible to get from any vertex to any other vertex using only the edges belonging to this graph.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) — the number of vertices in the graph and the number of special offers, respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^{12}$) — the numbers written on the vertices.\n\nThen $m$ lines follow, each containing three integers $x$, $y$ and $w$ ($1 \\le x, y \\le n$, $1 \\le w \\le 10^{12}$, $x \\ne y$) denoting a special offer: you may add an edge connecting vertex $x$ and vertex $y$, and this edge will cost $w$ coins.\n\n\n-----Output-----\n\nPrint one integer — the minimum number of coins you have to pay to make the graph connected.\n\n\n-----Examples-----\nInput\n3 2\n1 3 3\n2 3 5\n2 1 1\n\nOutput\n5\n\nInput\n4 0\n1 3 3 7\n\nOutput\n16\n\nInput\n5 4\n1 2 3 4 5\n1 2 8\n1 3 10\n1 4 7\n1 5 15\n\nOutput\n18\n\n\n\n-----Note-----\n\nIn the first example it is possible to connect $1$ to $2$ using special offer $2$, and then $1$ to $3$ without using any offers.\n\nIn next two examples the optimal answer may be achieved without using special offers.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef AElZb():\n    input = sys.stdin.readline\n    n,m=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    SP=[list(map(int,input().split())) for i in range(m)]\n    MIN=min(A)\n    x=A.index(MIN)\n    EDGE_x=[[x+1,i+1,A[x]+A[i]] for i in range(n) if x!=i]\n    EDGE=EDGE_x+SP\n    EDGE.sort(key=lambda x:x[2])\n    #UnionFind\n    Group=[i for i in range(n+1)]\n    def find(x):\n        while Group[x] != x:\n            x=Group[x]\n        return x\n    def Union(x,y):\n        if find(x) != find(y):\n            Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n    ANS=0\n    for i,j,x in EDGE:\n        if find(i)!=find(j):\n            ANS+=x\n            Union(i,j)\n    print(ANS)",
        "inputs": [
            "3 2\n1 3 3\n2 3 5\n2 1 1\n",
            "4 0\n1 3 3 7\n",
            "5 4\n1 2 3 4 5\n1 2 8\n1 3 10\n1 4 7\n1 5 15\n"
        ],
        "outputs": [
            "5\n",
            "16\n",
            "18\n"
        ],
        "starter_code": "\ndef AElZb():\n",
        "scope": [
            [
                "Function Body",
                2,
                26
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "List Comprehension",
                9,
                9
            ],
            [
                "Lambda Expression",
                11,
                11
            ],
            [
                "List Comprehension",
                13,
                13
            ],
            [
                "Function Body",
                14,
                17
            ],
            [
                "While Loop Body",
                15,
                16
            ],
            [
                "Function Body",
                18,
                20
            ],
            [
                "If Statement Body",
                19,
                20
            ],
            [
                "For Loop Body",
                22,
                25
            ],
            [
                "If Statement Body",
                23,
                25
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef reduce_pyramid(base):\n\t    \"\"\"## Number pyramid\n\nNumber pyramid is a recursive structure where each next row is constructed by adding adjacent values of the current row. For example:\n\n```\nRow 1     [1     2     3     4]\nRow 2        [3     5     7]\nRow 3           [8    12]\nRow 4             [20]\n```\n\n___\n\n## Task\n\nGiven the first row of the number pyramid, find the value stored in its last row.\n\n___\n\n## Examples\n\n```python\nreduce_pyramid([1])        ==  1\nreduce_pyramid([3, 5])     ==  8\nreduce_pyramid([3, 9, 4])  ==  25\n```\n\n___\n\n## Performance tests\n\n```python\nNumber of tests: 10\nList size: 10,000\n```\n    \"\"\"\n",
        "canonical_solution": "from operator import mul\n\ndef reduce_pyramid(base):\n    return sum(map(mul, base, comb_n(len(base) - 1)))\n\ndef comb_n(n):\n    c = 1\n    for k in range(0, n + 1):\n        yield c\n        c = c * (n - k) // (k + 1)\n",
        "inputs": [
            [
                [
                    1
                ]
            ],
            [
                [
                    3,
                    5
                ]
            ],
            [
                [
                    3,
                    9,
                    4
                ]
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                8
            ],
            [
                25
            ]
        ],
        "starter_code": "\ndef reduce_pyramid(base):\n",
        "scope": [
            [
                "Function Body",
                3,
                4
            ],
            [
                "Function Body",
                6,
                10
            ],
            [
                "For Loop Body",
                8,
                10
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef jXbHK():\n    \"\"\"You are given two strings $s$ and $t$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $1$. You can't choose a string if it is empty.\n\nFor example:  by applying a move to the string \"where\", the result is the string \"here\",  by applying a move to the string \"a\", the result is an empty string \"\". \n\nYou are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.\n\nWrite a program that finds the minimum number of moves to make two given strings $s$ and $t$ equal.\n\n\n-----Input-----\n\nThe first line of the input contains $s$. In the second line of the input contains $t$. Both strings consist only of lowercase Latin letters. The number of letters in each string is between 1 and $2\\cdot10^5$, inclusive.\n\n\n-----Output-----\n\nOutput the fewest number of moves required. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the given strings.\n\n\n-----Examples-----\nInput\ntest\nwest\n\nOutput\n2\n\nInput\ncodeforces\nyes\n\nOutput\n9\n\nInput\ntest\nyes\n\nOutput\n7\n\nInput\nb\nab\n\nOutput\n1\n\n\n\n-----Note-----\n\nIn the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to \"est\".\n\nIn the second example, the move should be applied to the string \"codeforces\" $8$ times. As a result, the string becomes \"codeforces\" $\\to$ \"es\". The move should be applied to the string \"yes\" once. The result is the same string \"yes\" $\\to$ \"es\".\n\nIn the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty.\n\nIn the fourth example, the first character of the second string should be deleted.\n    \"\"\"\n",
        "canonical_solution": "\ndef jXbHK():\n    s = input()[::-1]\n    t = input()[::-1]\n    i = 0\n    while i < min(len(s),len(t)) and s[i] == t[i]:\n        i += 1\n    print(len(s) - i + len(t) - i)\n    ",
        "inputs": [
            "test\nwest\n",
            "codeforces\nyes\n",
            "test\nyes\n"
        ],
        "outputs": [
            "2\n",
            "9\n",
            "7\n"
        ],
        "starter_code": "\ndef jXbHK():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ],
            [
                "While Loop Body",
                6,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef look_and_say_and_sum(n):\n\t    \"\"\"# Task\nGet the digits sum of `n`th number from the [Look-and-Say sequence](http://en.wikipedia.org/wiki/Look-and-say_sequence)(1-based).\n\n`1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...`\n\n# Input/Output\n\n`[input]` integer `n`\n\n`n`th number in the sequence to get where `1 <= n <= 55`  and `n=1 is \"1\"`.\n\n[output] an integer\n\nThe sum of digits in `n`th number from the `Look-and-Say` sequence.\n\n# Example\n\nFor `n = 2`, the output shoule be 2.\n\n`\"11\" --> 1 + 1 --> 2`\n\nFor `n = 3`, the output shoule be 3.\n\n`\"21\" --> 2 + 1 --> 3`\n\nFor `n = 4`, the output shoule be 5.\n\n`\"1211\" --> 1 + 2 + 1 + 1 --> 5`\n    \"\"\"\n",
        "canonical_solution": "def look_and_say_and_sum(N):\n    l=[1]\n    for n in range(N-1):\n        result = [1,l[0]]\n        for i in range(1,len(l)):\n            if l[i]==result[-1]:\n                result[-2] += 1\n            else:\n                result += [1,l[i]] \n        l=result\n    return sum(l)\n",
        "inputs": [
            [
                1
            ],
            [
                2
            ],
            [
                3
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                2
            ],
            [
                3
            ]
        ],
        "starter_code": "\ndef look_and_say_and_sum(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                11
            ],
            [
                "For Loop Body",
                3,
                10
            ],
            [
                "For Loop Body",
                5,
                9
            ],
            [
                "If Statement Body",
                6,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef winner(deck_steve, deck_josh):\n\t    \"\"\"Steve and Josh are bored and want to play something. They don't want to think too much, so they come up with a really simple game. Write a function called winner and figure out who is going to win.\n\nThey are dealt the same number of cards. They both flip the card on the top of their deck. Whoever has a card with higher value wins the round and gets one point (if the cards are of the same value, neither of them gets a point). After this, the two cards are discarded and they flip another card from the top of their deck. They do this until they have no cards left.\n\n`deckSteve` and `deckJosh` are arrays representing their decks. They are filled with *cards*, represented by a single character. The card rank is as follows (from lowest to highest):\n```\n'2','3','4','5','6','7','8','9','T','J','Q','K','A'\n```\n\nEvery card may appear in the deck more than once. Figure out who is going to win and return who wins and with what score:\n* `\"Steve wins x to y\"` if Steve wins; where `x` is Steve's score, `y` is Josh's score;\n* `\"Josh wins x to y\"` if Josh wins; where `x` is Josh's score, `y` is Steve's score;\n* `\"Tie\"` if the score is tied at the end of the game.\n\n\n## Example\n\n* Steve is dealt: `['A','7','8']`\n* Josh is dealt: `['K','5','9']`\n\n1. In the first round, ace beats king and Steve gets one point.\n2. In the second round, 7 beats 5 and Steve gets his second point.\n3. In the third round, 9 beats 8 and Josh gets one point.\n\nSo you should return: `\"Steve wins 2 to 1\"`\n    \"\"\"\n",
        "canonical_solution": "def winner(deck_Steve, deck_Josh):\n    deck = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']\n    Steve = 0\n    Josh = 0\n    for i in range(len(deck_Steve)):\n        if deck.index(deck_Steve[i]) > deck.index(deck_Josh[i]):\n            Steve += 1\n        elif deck.index(deck_Steve[i]) < deck.index(deck_Josh[i]):\n            Josh += 1\n        else:\n            continue\n    if Steve > Josh:\n        return \"Steve wins \" + str(Steve) + \" to \" + str(Josh)\n    elif Josh > Steve:\n        return \"Josh wins \" + str(Josh) + \" to \" + str(Steve)\n    else:\n        return \"Tie\"\n",
        "inputs": [
            [
                [
                    "A",
                    "7",
                    "8"
                ],
                [
                    "K",
                    "5",
                    "9"
                ]
            ],
            [
                [
                    "T"
                ],
                [
                    "T"
                ]
            ],
            [
                [
                    "T",
                    "9"
                ],
                [
                    "T",
                    "8"
                ]
            ]
        ],
        "outputs": [
            [
                "\"Steve wins 2 to 1\""
            ],
            [
                "\"Tie\""
            ],
            [
                "\"Steve wins 1 to 0\""
            ]
        ],
        "starter_code": "\ndef winner(deck_steve, deck_josh):\n",
        "scope": [
            [
                "Function Body",
                1,
                17
            ],
            [
                "For Loop Body",
                5,
                11
            ],
            [
                "If Statement Body",
                6,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ],
            [
                "If Statement Body",
                12,
                17
            ],
            [
                "If Statement Body",
                14,
                17
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef min_value(digits):\n\t    \"\"\"# Task\n\n**_Given_** a **_list of digits_**, *return the **_smallest number_** that could be formed from these digits, using the digits only once (ignore duplicates).* \n___\n\n# Notes:\n\n* Only **_positive integers_** *will be passed to the function (> 0 ), no negatives or zeros.*\n___\n# Input >> Output Examples \n\n```\nminValue ({1, 3, 1})  ==> return (13)\n```\n## Explanation:\n**_(13)_** *is the minimum number could be formed from* **_{1, 3, 1}_** , *Without duplications*  \n___\n```\nminValue({5, 7, 5, 9, 7})  ==> return (579)\n```\n## Explanation:\n**_(579)_** *is the minimum number could be formed from* **_{5, 7, 5, 9, 7}_** , *Without duplications* \n___\n\n```\nminValue({1, 9, 3, 1, 7, 4, 6, 6, 7}) return  ==> (134679)\n```\n## Explanation:\n**_(134679)_** *is the minimum number could be formed from* **_{1, 9, 3, 1, 7, 4, 6, 6, 7}_** , *Without duplications* \n___\n___\n\n## [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [Bizarre Sorting-katas](https://www.codewars.com/collections/bizarre-sorting-katas)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n    \"\"\"\n",
        "canonical_solution": "def min_value(digits):\n     return int(\"\".join(map(str,sorted(set(digits)))))\n",
        "inputs": [
            [
                [
                    1,
                    3,
                    1
                ]
            ],
            [
                [
                    4,
                    7,
                    5,
                    7
                ]
            ],
            [
                [
                    4,
                    8,
                    1,
                    4
                ]
            ]
        ],
        "outputs": [
            [
                13
            ],
            [
                457
            ],
            [
                148
            ]
        ],
        "starter_code": "\ndef min_value(digits):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef michael_pays(costs):\n\t    \"\"\"Kate and Michael want to buy a pizza and share it. Depending on the price of the pizza, they are going to divide the costs:\n\n* If the pizza is less than €5,- Michael invites Kate, so Michael pays the full price.\n* Otherwise Kate will contribute 1/3 of the price, but no more than €10 (she's broke :-) and Michael pays the rest.\n\nHow much is Michael going to pay? Calculate the amount with two decimals, if necessary.\n    \"\"\"\n",
        "canonical_solution": "def michael_pays(cost):\n    return round(cost if cost < 5 else max(cost*2/3, cost-10), 2)",
        "inputs": [
            [
                15
            ],
            [
                4
            ],
            [
                4.99
            ]
        ],
        "outputs": [
            [
                10
            ],
            [
                4
            ],
            [
                4.99
            ]
        ],
        "starter_code": "\ndef michael_pays(costs):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef LDTA(n):\n\t    \"\"\"Looking at consecutive powers of `2`, starting with `2^1`:\n\n`2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, ...`\n\nNote that out of all the digits `0-9`, the last one ever to appear is `7`. It only shows up for the first time in the number `32768 (= 2^15)`.\n\nSo let us define LAST DIGIT TO APPEAR as the last digit to be written down when writing down all the powers of `n`, starting with `n^1`.\n\n\n## Your task\n\nYou'll be given a positive integer ```1 =< n <= 10000```, and must return the last digit to appear, as an integer.\n\nIf for any reason there are digits which never appear in the sequence of powers, return `None`/`nil`.\n\nPlease note: The Last digit to appear can be in the same number as the penultimate one. For example for `n = 8`, the last digit to appear is `7`, although `3` appears slightly before it, in the same number:\n`8, 64, 512, 4096, 32768, ...`\n    \"\"\"\n",
        "canonical_solution": "digits = lambda x: set(str(x))\n\ndef LDTA(n):\n    if digits(n) == digits(n*n):\n        return None\n    \n    seen = []\n    x = n\n    \n    while len(seen) < 10:\n        for d in str(x):\n            if d not in seen:\n                seen.append(d)\n        x *= n\n        \n    return int(seen[-1])",
        "inputs": [
            [
                100
            ],
            [
                2
            ],
            [
                3
            ]
        ],
        "outputs": [
            [
                null
            ],
            [
                7
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef LDTA(n):\n",
        "scope": [
            [
                "Lambda Expression",
                1,
                1
            ],
            [
                "Function Body",
                3,
                16
            ],
            [
                "If Statement Body",
                4,
                5
            ],
            [
                "While Loop Body",
                10,
                14
            ],
            [
                "For Loop Body",
                11,
                13
            ],
            [
                "If Statement Body",
                12,
                13
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef UKZxy():\n    \"\"\"There are three positive integers A, B and C written on a blackboard. E869120 performs the following operation K times:\n - Choose one integer written on the blackboard and let the chosen integer be n. Replace the chosen integer with 2n.\nWhat is the largest possible sum of the integers written on the blackboard after K operations?\n\n-----Constraints-----\n - A, B and C are integers between 1 and 50 (inclusive).\n - K is an integer between 1 and 10 (inclusive).\n\n-----Input-----\nInput is given from Standard Input in the following format:\nA B C\nK\n\n-----Output-----\nPrint the largest possible sum of the integers written on the blackboard after K operations by E869220.\n\n-----Sample Input-----\n5 3 11\n1\n\n-----Sample Output-----\n30\n\nIn this sample, 5, 3, 11 are initially written on the blackboard, and E869120 can perform the operation once.\n\nThere are three choices:  \n - Double 5: The integers written on the board after the operation are 10, 3, 11.\n - Double 3: The integers written on the board after the operation are 5, 6, 11.\n - Double 11: The integers written on the board after the operation are 5, 3, 22.\nIf he chooses 3., the sum of the integers written on the board afterwards is 5 + 3 + 22 = 30, which is the largest among 1. through 3.\n    \"\"\"\n",
        "canonical_solution": "\ndef UKZxy():\n    a,b,c=list(map(int,input().split()))\n    k=int(input())\n    \n    x=max(a,b,c)\n    \n    print(((a+b+c)-x+x*(2**k)))\n    ",
        "inputs": [
            "5 3 11\n1\n",
            "3 3 4\n2\n"
        ],
        "outputs": [
            "30\n",
            "22\n"
        ],
        "starter_code": "\ndef UKZxy():\n",
        "scope": [
            [
                "Function Body",
                2,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef calc_tip(p, r):\n\t    \"\"\"Dee is lazy but she's kind and she likes to eat out at all the nice restaurants and gastropubs in town. To make paying quick and easy she uses a simple mental algorithm she's called The Fair %20 Rule. She's gotten so good she can do this in a few seconds and it always impresses her dates but she's perplexingly still single. Like you probably. \n\nThis is how she does it:\n\n - She rounds the price `P` at the tens place e.g:\n   - 25 becomes 30\n   - 24 becomes 20\n   - 5 becomes 10\n   - 4 becomes 0\n - She figures out the base tip `T` by dropping the singles place digit e.g:\n   - when `P = 24` she rounds to 20 drops 0 `T = 2`\n   - `P = 115` rounds to 120 drops 0 `T = 12`\n   - `P = 25` rounds to 30 drops 0 `T = 3`\n   - `P = 5` rounds to 10 drops 0 `T = 1`\n   - `P = 4` rounds to 0 `T = 0`\n - She then applies a 3 point satisfaction rating `R` to `T` i.e:\n   - When she's satisfied: `R = 1` and she'll add 1 to `T`\n   - Unsatisfied: `R = 0` and she'll subtract 1 from `T`\n   - Appalled: `R = -1` she'll divide `T` by 2, **rounds down** and subtracts 1\n \n## Your Task\n\nImplement a method `calc_tip` that takes two integer arguments for price `p` \n\nwhere `1 <= p <= 1000` and a rating `r` which is one of `-1, 0, 1`.\n\nThe return value `T` should be a non negative integer.\n\n*Note: each step should be done in the order listed.*\n\nDee always politely smiles and says \"Thank you\" on her way out. Dee is nice. Be like Dee.\n    \"\"\"\n",
        "canonical_solution": "def calc_tip(p, r):\n    if p % 10 < 5:\n        p //= 10\n    else:\n        p = p // 10 + 1\n    if r == 1:\n        tip = p + 1\n    elif r == 0:\n        tip = p - 1\n    else:\n        tip = int(p/2) - 1\n    return tip if tip >= 0 else 0",
        "inputs": [
            [
                4,
                1
            ],
            [
                4,
                0
            ],
            [
                4,
                -1
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                0
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef calc_tip(p, r):\n",
        "scope": [
            [
                "Function Body",
                1,
                12
            ],
            [
                "If Statement Body",
                2,
                5
            ],
            [
                "If Statement Body",
                6,
                11
            ],
            [
                "If Statement Body",
                8,
                11
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef valid_mersenne(n):\n\t    \"\"\"A [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) is a prime number that can be represented as:\nMn = 2^(n) - 1. Therefore, every Mersenne prime is one less than a power of two. \n\nWrite a function that will return whether the given integer `n` will produce a Mersenne prime or not.\n\nThe tests will check random integers up to 2000.\n    \"\"\"\n",
        "canonical_solution": "def valid_mersenne(n):\n    return n in {2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279}",
        "inputs": [
            [
                2
            ],
            [
                3
            ],
            [
                5
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                true
            ],
            [
                true
            ]
        ],
        "starter_code": "\ndef valid_mersenne(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef tv_remote(words):\n\t    \"\"\"# Background\n\n\nMy TV remote control has arrow buttons and an `OK` button.\n\nI can use these to move a \"cursor\" on a logical screen keyboard to type words...\n\n# Keyboard\n\nThe screen \"keyboard\" layout looks like this\n\n\n  #tvkb {\n    width : 400px;\n    border: 5px solid gray; border-collapse: collapse;\n  }\n  #tvkb td {\n    color : orange;\n    background-color : black;\n    text-align : center;\n    border: 3px solid gray; border-collapse: collapse;\n  }\n\n\nabcde123\nfghij456\nklmno789\npqrst.@0\nuvwxyz_/\naASP\n\n\n\n* `aA` is the SHIFT key. Pressing this key toggles alpha characters between UPPERCASE and lowercase\n* `SP` is the space character\n* The other blank keys in the bottom row have no function\n\n# Kata task\n\nHow many button presses on my remote are required to type the given `words`?\n\n## Hint\n\nThis Kata is an extension of the earlier ones in this series. You should complete those first.\n\n## Notes\n\n* The cursor always starts on the letter `a` (top left)\n* The alpha characters are initially lowercase (as shown above)\n* Remember to also press `OK` to \"accept\" each letter\n* Take the shortest route from one letter to the next\n* The cursor wraps, so as it moves off one edge it will reappear on the opposite edge\n* Although the blank keys have no function, you may navigate through them if you want to\n* Spaces may occur anywhere in the `words` string\n* Do not press the SHIFT key until you need to. For example, with the word `e.Z`, the SHIFT change happens **after** the `.` is pressed (not before)\n \n# Example\n\nwords = `Code Wars`\n\n* C => `a`-`aA`-OK-`A`-`B`-`C`-OK = 6\n* o => `C`-`B`-`A`-`aA`-OK-`u`-`v`-`w`-`x`-`y`-`t`-`o`-OK = 12\n* d => `o`-`j`-`e`-`d`-OK = 4\n* e => `d`-`e`-OK = 2\n* space => `e`-`d`-`c`-`b`-`SP`-OK = 5\n* W => `SP`-`aA`-OK-`SP`-`V`-`W`-OK = 6\n* a => `W`-`V`-`U`-`aA`-OK-`a`-OK = 6\n* r => `a`-`f`-`k`-`p`-`q`-`r`-OK = 6\n* s => `r`-`s`-OK = 2\n\nAnswer = 6 + 12 + 4 + 2 + 5 + 6 + 6 + 6 + 2 = 49\n\n\n\n*Good Luck!\nDM.*\n\n\n\nSeries\n* TV Remote\n* TV Remote (shift and space)\n* TV Remote (wrap)\n* TV Remote (symbols)\n    \"\"\"\n",
        "canonical_solution": "import re\n\nH, W     = 6, 8\nKEYBOARD = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/* \"\nMAP      = {c: (i//W, i%W) for i,c in enumerate(KEYBOARD)}\n\n\ndef manhattan(*pts):\n    dxy = [abs(z2-z1) for z1,z2 in zip(*pts)]\n    return 1 + sum( min(dz, Z-dz) for dz,Z in zip(dxy, (H,W)) )\n\ndef toggle(m):\n    ups, end = m.groups()\n    return f'*{ups.lower()}*{end}'                    # Toggle Shift ON if uppercase presents, and then OFF if lowercase after (or end of the string)\n\n\ndef tv_remote(words):\n    reWords = re.sub(r'([A-Z][^a-z]*)([a-z]?)', toggle, words).rstrip('*')                # Strip any useless toggle OFF at the end\n    return sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+reWords, reWords))\n",
        "inputs": [
            [
                "\"Code Wars\""
            ],
            [
                "\"does\""
            ],
            [
                "\"your\""
            ]
        ],
        "outputs": [
            [
                49
            ],
            [
                16
            ],
            [
                21
            ]
        ],
        "starter_code": "\ndef tv_remote(words):\n",
        "scope": [
            [
                "Dict Comprehension",
                5,
                5
            ],
            [
                "Function Body",
                8,
                10
            ],
            [
                "List Comprehension",
                9,
                9
            ],
            [
                "Generator Expression",
                10,
                10
            ],
            [
                "Function Body",
                12,
                14
            ],
            [
                "Function Body",
                17,
                19
            ],
            [
                "Generator Expression",
                19,
                19
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef sort_by_name(arr):\n\t    \"\"\"# Hey You !\n\nSort these integers for me ...\n\nBy name ...\n\nDo it now !\n\n\n---\n\n## Input\n\n* Range is ```0```-```999```\n\n* There may be duplicates\n\n* The array may be empty\n\n## Example\n\n* Input: 1, 2, 3, 4\n* Equivalent names: \"one\", \"two\", \"three\", \"four\"\n* Sorted by name: \"four\", \"one\", \"three\", \"two\"\n* Output: 4, 1, 3, 2\n\n## Notes\n* Don't pack words together:\n * e.g. 99 may be \"ninety nine\" or \"ninety-nine\"; but not \"ninetynine\"\n * e.g 101 may be \"one hundred one\" or \"one hundred and one\"; but not \"onehundredone\"\n* Don't fret about formatting rules, because if rules are consistently applied it has no effect anyway:\n * e.g. \"one hundred one\", \"one hundred two\"; is same order as \"one hundred **and** one\", \"one hundred **and** two\"\n * e.g. \"ninety eight\", \"ninety nine\"; is same order as \"ninety-eight\", \"ninety-nine\"\n \n```if:c\n* For `C` code the input array may be NULL. The return value is freed if non-NULL.\n```\n    \"\"\"\n",
        "canonical_solution": "def int_to_word(num):\n    d = { 0 : 'zero', 1 : 'one', 2 : 'two', 3 : 'three', 4 : 'four', 5 : 'five',\n          6 : 'six', 7 : 'seven', 8 : 'eight', 9 : 'nine', 10 : 'ten',\n          11 : 'eleven', 12 : 'twelve', 13 : 'thirteen', 14 : 'fourteen',\n          15 : 'fifteen', 16 : 'sixteen', 17 : 'seventeen', 18 : 'eighteen',\n          19 : 'nineteen', 20 : 'twenty',\n          30 : 'thirty', 40 : 'forty', 50 : 'fifty', 60 : 'sixty',\n          70 : 'seventy', 80 : 'eighty', 90 : 'ninety' }\n\n\n    assert(0 <= num)\n\n    if (num < 20):\n        return d[num]\n\n    if (num < 100):\n        if num % 10 == 0: return d[num]\n        else: return d[num // 10 * 10] + '-' + d[num % 10]\n\n    if (num < 1000):\n        if num % 100 == 0: return d[num // 100] + ' hundred'\n        else: return d[num // 100] + ' hundred and ' + int_to_word(num % 100)\n\ndef sort_by_name(arr):\n    return sorted(arr, key=int_to_word)\n",
        "inputs": [
            [
                [
                    0,
                    1,
                    2,
                    3
                ]
            ],
            [
                []
            ],
            [
                [
                    8,
                    8,
                    9,
                    9,
                    10,
                    10
                ]
            ]
        ],
        "outputs": [
            [
                [
                    1,
                    3,
                    2,
                    0
                ]
            ],
            [
                []
            ],
            [
                [
                    8,
                    8,
                    9,
                    9,
                    10,
                    10
                ]
            ]
        ],
        "starter_code": "\ndef sort_by_name(arr):\n",
        "scope": [
            [
                "Function Body",
                1,
                22
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                16,
                18
            ],
            [
                "If Statement Body",
                17,
                18
            ],
            [
                "If Statement Body",
                20,
                22
            ],
            [
                "If Statement Body",
                21,
                22
            ],
            [
                "Function Body",
                24,
                25
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef knHNy():\n    \"\"\"The heat during the last few days has been really intense. Scientists from all over the Berland study how the temperatures and weather change, and they claim that this summer is abnormally hot. But any scientific claim sounds a lot more reasonable if there are some numbers involved, so they have decided to actually calculate some value which would represent how high the temperatures are.\n\nMathematicians of Berland State University came up with a special heat intensity value. This value is calculated as follows:\n\nSuppose we want to analyze the segment of $n$ consecutive days. We have measured the temperatures during these $n$ days; the temperature during $i$-th day equals $a_i$.\n\nWe denote the average temperature of a segment of some consecutive days as the arithmetic mean of the temperature measures during this segment of days. So, if we want to analyze the average temperature from day $x$ to day $y$, we calculate it as $\\frac{\\sum \\limits_{i = x}^{y} a_i}{y - x + 1}$ (note that division is performed without any rounding). The heat intensity value is the maximum of average temperatures over all segments of not less than $k$ consecutive days. For example, if analyzing the measures $[3, 4, 1, 2]$ and $k = 3$, we are interested in segments $[3, 4, 1]$, $[4, 1, 2]$ and $[3, 4, 1, 2]$ (we want to find the maximum value of average temperature over these segments).\n\nYou have been hired by Berland State University to write a program that would compute the heat intensity value of a given period of days. Are you up to this task?\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 5000$) — the number of days in the given period, and the minimum number of days in a segment we consider when calculating heat intensity value, respectively.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 5000$) — the temperature measures during given $n$ days.\n\n\n-----Output-----\n\nPrint one real number — the heat intensity value, i. e., the maximum of average temperatures over all segments of not less than $k$ consecutive days.\n\nYour answer will be considered correct if the following condition holds: $|res - res_0| < 10^{-6}$, where $res$ is your answer, and $res_0$ is the answer given by the jury's solution.\n\n\n-----Example-----\nInput\n4 3\n3 4 1 2\n\nOutput\n2.666666666666667\n    \"\"\"\n",
        "canonical_solution": "\ndef knHNy():\n    n,k=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    prefix=[a[0]]\n    for i in range(1,n):\n        prefix.append(prefix[-1]+a[i])\n    ans=[]\n    for i in range(n):\n        for j in range(i+k-1,n):\n            if(i==0):\n                ans.append(prefix[j]/(j-i+1))\n            else:\n                ans.append((prefix[j]-prefix[i-1])/(j-i+1))\n    print(max(ans))",
        "inputs": [
            "4 3\n3 4 1 2\n",
            "5 1\n3 10 9 10 6\n",
            "5 2\n7 3 3 1 8\n"
        ],
        "outputs": [
            "2.6666666666666665\n",
            "10.0\n",
            "5.0\n"
        ],
        "starter_code": "\ndef knHNy():\n",
        "scope": [
            [
                "Function Body",
                2,
                15
            ],
            [
                "For Loop Body",
                6,
                7
            ],
            [
                "For Loop Body",
                9,
                14
            ],
            [
                "For Loop Body",
                10,
                14
            ],
            [
                "If Statement Body",
                11,
                14
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef factors(n):\n\t    \"\"\"#### Task:\n\nYour job here is to implement a function `factors`, which takes a number `n`, and outputs an array of arrays comprised of two\nparts, `sq` and `cb`. The part `sq` will contain all the numbers that, when squared, yield a number which is a factor of `n`,\nwhile the `cb` part will contain all the numbers that, when cubed, yield a number which is a factor of `n`.  Discard all `1`s\nfrom both arrays.\n\nBoth `sq` and `cb` should be sorted in ascending order.\n\n#### What it looks like:\n\n```python\nfactors(int) #=> [\n  sq (all the numbers that can be squared to give a factor of n) : list,\n  cb (all the numbers that can be cubed   to give a factor of n) : list\n]\n```\n\n#### Some examples:\n\nAlso check out my other creations — [Keep the Order](https://www.codewars.com/kata/keep-the-order), [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\nIf you notice any issues or have any suggestions/comments whatsoever, please don't hesitate to mark an issue or just comment. Thanks!\n    \"\"\"\n",
        "canonical_solution": "def factors(n):\n    sq = [a for a in range(2, n+1) if not n % (a**2)]\n    cb = [b for b in range(2, n+1) if not n % (b**3)]\n    return [sq, cb]",
        "inputs": [
            [
                1
            ],
            [
                4
            ],
            [
                16
            ]
        ],
        "outputs": [
            [
                [
                    [],
                    []
                ]
            ],
            [
                [
                    [
                        2
                    ],
                    []
                ]
            ],
            [
                [
                    [
                        2,
                        4
                    ],
                    [
                        2
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef factors(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "List Comprehension",
                2,
                2
            ],
            [
                "List Comprehension",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef calc_ms(n):\n\t    \"\"\"The Menger Sponge is a three-dimensional fractal, first described by Karl Menger in 1926.\n\n![Mengers Sponge (Level 0-3)](http://i.imgur.com/V6Rb4Za.jpg)\n###### _An illustration of the iterative construction of a Menger sponge_\n\nA method of constructing a Menger Sponge can be visualized as follows:\n1. Start from a cube (first part of image).\n2. Scale down the cube so that side length is 1/3 of its original, and make 20 copies of it.\n3. Place the copies so that they measure the same size as the original cube but without its central parts (next part of image)\n4. Repeat the process from step 2 for the new smaller cubes from the previous step.\n5. In each iteration (e.g. repeating the last three steps), the effect will be that parts of the cube will be removed, they'll never be added. Menger sponge will always consist of parts will never be removed, regardless of how many iterations you do.\n\n___\n\nAn alternative explanation:\n1. Start from a cube (first part of image).\n2. Devide each cube into 27 equal sized cubes.\n3. Remove the middle-cube and the six cubes on each side of the group of 27 cubes (second part of image).\n4. Repeat the process from step 2 for the smaller cubes (third and fourth part of image).\n\n## Task\nIn this kata you will create a function that takes non negative integers (from 0 to n) and return the amount of cubes that the Menger Sponge would have in that specific iteration.\n\n\n## Example\n```\ncalc_ms(0) == 1\ncalc_ms(1) == 20\ncalc_ms(2) == 400\ncalc_ms(3) == 8000\ncalc_ms(4) == 160000\ncalc_ms(5) == 3200000\ncalc_ms(6) == 64000000\n```\n\nHappy coding!\n    \"\"\"\n",
        "canonical_solution": "def calc_ms(n):\n  return 20 ** n",
        "inputs": [
            [
                0
            ],
            [
                1
            ],
            [
                2
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                20
            ],
            [
                400
            ]
        ],
        "starter_code": "\ndef calc_ms(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef last_digit(n1, n2):\n\t    \"\"\"Define a function that takes in two non-negative integers `$a$` and `$b$` and returns the last decimal digit of `$a^b$`. Note that `$a$` and `$b$` may be very large!\n\nFor example, the last decimal digit of `$9^7$` is `$9$`, since `$9^7 = 4782969$`.  The last decimal digit of `$({2^{200}})^{2^{300}}$`, which has over `$10^{92}$` decimal digits, is `$6$`.  Also, please take `$0^0$` to be `$1$`.\n\nYou may assume that the input will always be valid.\n\n## Examples\n\n```python\nlast_digit(4, 1)                # returns 4\nlast_digit(4, 2)                # returns 6\nlast_digit(9, 7)                # returns 9\nlast_digit(10, 10 ** 10)        # returns 0\nlast_digit(2 ** 200, 2 ** 300)  # returns 6\n```\n\n___\n\n## Remarks\n\n### JavaScript, C++, R, PureScript\n\nSince these languages don't have native arbitrarily large integers, your arguments are going to be strings representing non-negative integers instead.\n    \"\"\"\n",
        "canonical_solution": "def last_digit(n1, n2):\n    return pow( n1, n2, 10 )",
        "inputs": [
            [
                4,
                1
            ],
            [
                4,
                2
            ],
            [
                9,
                7
            ]
        ],
        "outputs": [
            [
                4
            ],
            [
                6
            ],
            [
                9
            ]
        ],
        "starter_code": "\ndef last_digit(n1, n2):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef Yabsq():\n    \"\"\"This problem is a version of problem D from the same contest with some additional constraints and tasks.\n\nThere are $n$ candies in a candy box. The type of the $i$-th candy is $a_i$ ($1 \\le a_i \\le n$). \n\nYou have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $1$ and two candies of type $2$ is bad).\n\nIt is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.\n\nYou really like some of the candies and don't want to include them into the gift, but you want to eat them yourself instead. For each candy, a number $f_i$ is given, which is equal to $0$ if you really want to keep $i$-th candy for yourself, or $1$ if you don't mind including it into your gift. It is possible that two candies of the same type have different values of $f_i$.\n\nYou want your gift to be as large as possible, but you don't want to include too many of the candies you want to eat into the gift. So, you want to calculate the maximum possible number of candies that can be included into a gift, and among all ways to choose maximum number of candies, you want to maximize the number of candies having $f_i = 1$ in your gift.\n\nYou have to answer $q$ independent queries.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of candies.\n\nThen $n$ lines follow, each containing two integers $a_i$ and $f_i$ ($1 \\le a_i \\le n$, $0 \\le f_i \\le 1$), where $a_i$ is the type of the $i$-th candy, and $f_i$ denotes whether you want to keep the $i$-th candy for yourself ($0$ if you want to keep it, $1$ if you don't mind giving it away).\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nFor each query print two integers:\n\n  the maximum number of candies in a gift you can compose, according to the constraints in the statement;  the maximum number of candies having $f_i = 1$ in a gift you can compose that contains the maximum possible number of candies.  \n\n\n-----Example-----\nInput\n3\n8\n1 0\n4 1\n2 0\n4 1\n5 1\n6 1\n3 0\n2 0\n4\n1 1\n1 1\n2 1\n2 1\n9\n2 0\n2 0\n4 1\n4 1\n4 1\n7 0\n7 1\n7 0\n7 1\n\nOutput\n3 3\n3 3\n9 5\n\n\n\n-----Note-----\n\nIn the first query, you can include two candies of type $4$ and one candy of type $5$. All of them have $f_i = 1$ and you don't mind giving them away as part of the gift.\n    \"\"\"\n",
        "canonical_solution": "import sys\ndef Yabsq():\n    # @author \n    class GCandyBoxHardVersion:\n        def solve(self):\n            q = int(input())\n            for _ in range(q):\n                n = int(input())\n                a = [0] * n\n                f = [0] * n\n                for i in range(n):\n                    a[i], f[i] = [int(_) for _ in input().split()]\n                d = {key: [0, 0] for key in a}\n                for i in range(n):\n                    d[a[i]][f[i]] += 1\n                rev_d = {sum(key): [] for key in list(d.values())}\n                for x in d:\n                    rev_d[d[x][0] + d[x][1]] += [d[x]]\n                for x in rev_d:\n                    rev_d[x].sort(key=lambda item:item[1])\n                # print(rev_d)\n                cur = max(rev_d)\n                cnt = max(rev_d)\n                nb_candies = 0\n                given_away = 0\n                while 1:\n                    if cnt == 0 or cur == 0:\n                        break\n                    if cur > cnt:\n                        cur -= 1\n                        continue\n                    if cnt not in rev_d or not rev_d[cnt]:\n                        cnt -= 1\n                        continue\n                    mx_f = -1\n                    v = -1\n                    for max_cnt in range(cur, cnt + 1):\n                        if max_cnt in rev_d and rev_d[max_cnt] and rev_d[max_cnt][-1][1] > mx_f:\n                            v = max_cnt\n                            mx_f = rev_d[max_cnt][-1][1]\n                    to_take = rev_d[v].pop()\n                    # rev_d[cnt] -= 1\n                    nb_candies += cur\n                    given_away += min(to_take[1], cur)\n                    cur -= 1\n                    # rev_d[cnt - cur] += 1\n                print(nb_candies, given_away)\n    solver = GCandyBoxHardVersion()\n    input = sys.stdin.readline\n    solver.solve()",
        "inputs": [
            "3\n8\n1 0\n4 1\n2 0\n4 1\n5 1\n6 1\n3 0\n2 0\n4\n1 1\n1 1\n2 1\n2 1\n9\n2 0\n2 0\n4 1\n4 1\n4 1\n7 0\n7 1\n7 0\n7 1\n"
        ],
        "outputs": [
            "3 3\n3 3\n9 5\n"
        ],
        "starter_code": "\ndef Yabsq():\n",
        "scope": [
            [
                "Function Body",
                2,
                50
            ],
            [
                "Class Body",
                4,
                47
            ],
            [
                "Function Body",
                5,
                47
            ],
            [
                "For Loop Body",
                7,
                47
            ],
            [
                "For Loop Body",
                11,
                12
            ],
            [
                "List Comprehension",
                12,
                12
            ],
            [
                "Dict Comprehension",
                13,
                13
            ],
            [
                "For Loop Body",
                14,
                15
            ],
            [
                "Dict Comprehension",
                16,
                16
            ],
            [
                "For Loop Body",
                17,
                18
            ],
            [
                "For Loop Body",
                19,
                20
            ],
            [
                "Lambda Expression",
                20,
                20
            ],
            [
                "While Loop Body",
                26,
                45
            ],
            [
                "If Statement Body",
                27,
                28
            ],
            [
                "If Statement Body",
                29,
                31
            ],
            [
                "If Statement Body",
                32,
                34
            ],
            [
                "For Loop Body",
                37,
                40
            ],
            [
                "If Statement Body",
                38,
                40
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef date_checker(date):\n\t    \"\"\"Create a function that will return ```true``` if the input is in the following date time format ```01-09-2016 01:20``` and ```false``` if it is not.\n\nThis Kata has been inspired by the Regular Expressions chapter from the book Eloquent JavaScript.\n    \"\"\"\n",
        "canonical_solution": "from re import match\n\n\ndef date_checker(date):\n    return bool(match(r'\\d{2}-\\d{2}-\\d{4}\\s\\d{2}:\\d{2}', date))\n",
        "inputs": [
            [
                "\"01-09-2016 01:20\""
            ],
            [
                "\"01-09-2016 01;20\""
            ],
            [
                "\"01_09_2016 01:20\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef date_checker(date):\n",
        "scope": [
            [
                "Function Body",
                4,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def countOdds(self, low: int, high: int) -> int:\n            \"\"\"Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).\n \nExample 1:\nInput: low = 3, high = 7\nOutput: 3\nExplanation: The odd numbers between 3 and 7 are [3,5,7].\nExample 2:\nInput: low = 8, high = 10\nOutput: 1\nExplanation: The odd numbers between 8 and 10 are [9].\n \nConstraints:\n\n0 <= low <= high <= 10^9\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n    def countOdds(self, low: int, high: int) -> int:\n        if low %2 != 0:\n            low -=1\n        if high %2 != 0:\n            high +=1 \n            \n        return (high-low) // 2",
        "inputs": [
            [
                3,
                7
            ]
        ],
        "outputs": [
            [
                3
            ]
        ],
        "starter_code": "\nclass Solution:\n    def countOdds(self, low: int, high: int) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                8
            ],
            [
                "Function Body",
                2,
                8
            ],
            [
                "If Statement Body",
                3,
                4
            ],
            [
                "If Statement Body",
                5,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n            \"\"\"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n\nNote:\nYou may assume the greed factor is always positive. \nYou cannot assign more than one cookie to one child.\n\n\nExample 1:\n\nInput: [1,2,3], [1,1]\n\nOutput: 1\n\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n\n\nExample 2:\n\nInput: [1,2], [1,2,3]\n\nOutput: 2\n\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def findContentChildren(self, g, s):\n         \"\"\"\n         :type g: List[int]\n         :type s: List[int]\n         :rtype: int\n         \"\"\"\n         res = 0\n         heapq.heapify(g)\n         s.sort()\n         for num in s:\n             if not g:\n                 break\n             elif g[0] <= num:\n                 res += 1\n                 heapq.heappop(g)\n         return res",
        "inputs": [
            [
                [
                    2,
                    3
                ],
                [
                    1,
                    1
                ]
            ],
            [
                [
                    1,
                    2,
                    3
                ],
                [
                    1,
                    1
                ]
            ],
            [
                [
                    1,
                    2
                ],
                [
                    1,
                    2,
                    3
                ]
            ]
        ],
        "outputs": [
            [
                0
            ],
            [
                1
            ],
            [
                2
            ]
        ],
        "starter_code": "\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                17
            ],
            [
                "Function Body",
                2,
                17
            ],
            [
                "For Loop Body",
                11,
                16
            ],
            [
                "If Statement Body",
                12,
                16
            ],
            [
                "If Statement Body",
                14,
                16
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef invite_more_women(arr):\n\t    \"\"\"### Task\n King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.\n\n To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers. \n \n Arthur needs you to return true if he needs to invite more women or false if he is all set.\n\n### Input/Output\n\n\n - `[input]` integer array `L` (`$a` in PHP)\n\n  An array (guaranteed non-associative in PHP) representing the genders of the attendees, where `-1` represents `women` and `1` represents `men`.\n  \n  `2 <= L.length <= 50`\n  \n\n- `[output]` a boolean value\n\n  `true` if Arthur need to invite more women, `false` otherwise.\n    \"\"\"\n",
        "canonical_solution": "def invite_more_women(arr):\n    return sum(arr) > 0",
        "inputs": [
            [
                [
                    1,
                    -1,
                    1
                ]
            ],
            [
                [
                    -1,
                    -1,
                    -1
                ]
            ],
            [
                [
                    1,
                    -1
                ]
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef invite_more_women(arr):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef lIuaU():\n    \"\"\"There is a white sheet of paper lying on a rectangle table. The sheet is a rectangle with its sides parallel to the sides of the table. If you will take a look from above and assume that the bottom left corner of the table has coordinates $(0, 0)$, and coordinate axes are left and bottom sides of the table, then the bottom left corner of the white sheet has coordinates $(x_1, y_1)$, and the top right — $(x_2, y_2)$.\n\nAfter that two black sheets of paper are placed on the table. Sides of both black sheets are also parallel to the sides of the table. Coordinates of the bottom left corner of the first black sheet are $(x_3, y_3)$, and the top right — $(x_4, y_4)$. Coordinates of the bottom left corner of the second black sheet are $(x_5, y_5)$, and the top right — $(x_6, y_6)$.  [Image] Example of three rectangles. \n\nDetermine if some part of the white sheet can be seen from the above after the two black sheets are placed. The part of the white sheet can be seen if there is at least one point lying not strictly inside the white sheet and strictly outside of both black sheets.\n\n\n-----Input-----\n\nThe first line of the input contains four integers $x_1, y_1, x_2, y_2$ $(0 \\le x_1 < x_2 \\le 10^{6}, 0 \\le y_1 < y_2 \\le 10^{6})$ — coordinates of the bottom left and the top right corners of the white sheet.\n\nThe second line of the input contains four integers $x_3, y_3, x_4, y_4$ $(0 \\le x_3 < x_4 \\le 10^{6}, 0 \\le y_3 < y_4 \\le 10^{6})$ — coordinates of the bottom left and the top right corners of the first black sheet.\n\nThe third line of the input contains four integers $x_5, y_5, x_6, y_6$ $(0 \\le x_5 < x_6 \\le 10^{6}, 0 \\le y_5 < y_6 \\le 10^{6})$ — coordinates of the bottom left and the top right corners of the second black sheet.\n\nThe sides of each sheet of paper are parallel (perpendicular) to the coordinate axes.\n\n\n-----Output-----\n\nIf some part of the white sheet can be seen from the above after the two black sheets are placed, print \"YES\" (without quotes). Otherwise print \"NO\".\n\n\n-----Examples-----\nInput\n2 2 4 4\n1 1 3 5\n3 1 5 5\n\nOutput\nNO\n\nInput\n3 3 7 5\n0 0 4 6\n0 0 7 4\n\nOutput\nYES\n\nInput\n5 2 10 5\n3 1 7 6\n8 1 11 7\n\nOutput\nYES\n\nInput\n0 0 1000000 1000000\n0 0 499999 1000000\n500000 0 1000000 1000000\n\nOutput\nYES\n\n\n\n-----Note-----\n\nIn the first example the white sheet is fully covered by black sheets.\n\nIn the second example the part of the white sheet can be seen after two black sheets are placed. For example, the point $(6.5, 4.5)$ lies not strictly inside the white sheet and lies strictly outside of both black sheets.\n    \"\"\"\n",
        "canonical_solution": "\ndef lIuaU():\n    x1, y1, x2, y2 = list(map( int, input().split() ))\n    x3, y3, x4, y4 = list(map( int, input().split() ))\n    x5, y5, x6, y6 = list(map( int, input().split() ))\n    \n    covered = False\n    if x3 <= x1 and y3 <= y1 and x4 >= x2 and y4 >= y2:\n        covered = True\n    elif x5 <= x1 and y5 <= y1 and x6 >= x2 and y6 >= y2:\n        covered = True\n    elif x1 >= x3 and x1 >= x5 and x2 <= x4 and x2 <= x6:\n        if min( y4, y6 ) >= max( y3, y5 ) and min( y3, y5 ) <= y1 and max( y4, y6 ) >= y2:\n            covered = True\n    elif y1 >= y3 and y1 >= y5 and y2 <= y4 and y2 <= y6:\n        if min( x4, x6 ) >= max( x3, x5 ) and min( x3, x5 ) <= x1 and max( x4, x6 ) >= x2:\n            covered = True\n    \n    print( \"NO\" if covered else \"YES\" )\n    ",
        "inputs": [
            "2 2 4 4\n1 1 3 5\n3 1 5 5\n",
            "3 3 7 5\n0 0 4 6\n0 0 7 4\n",
            "5 2 10 5\n3 1 7 6\n8 1 11 7\n"
        ],
        "outputs": [
            "NO\n",
            "YES\n",
            "YES\n"
        ],
        "starter_code": "\ndef lIuaU():\n",
        "scope": [
            [
                "Function Body",
                2,
                19
            ],
            [
                "If Statement Body",
                8,
                17
            ],
            [
                "If Statement Body",
                10,
                17
            ],
            [
                "If Statement Body",
                12,
                17
            ],
            [
                "If Statement Body",
                13,
                14
            ],
            [
                "If Statement Body",
                15,
                17
            ],
            [
                "If Statement Body",
                16,
                17
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef digitize(n):\n\t    \"\"\"# Convert number to reversed array of digits\n\nGiven a random non-negative number, you have to return the digits of this number within an array in reverse order.\n\n## Example:\n\n```\n348597 => [7,9,5,8,4,3]\n```\n    \"\"\"\n",
        "canonical_solution": "def digitize(n):\n    return [int(x) for x in str(n)[::-1]]",
        "inputs": [
            [
                35231
            ],
            [
                23582357
            ],
            [
                984764738
            ]
        ],
        "outputs": [
            [
                [
                    1,
                    3,
                    2,
                    5,
                    3
                ]
            ],
            [
                [
                    7,
                    5,
                    3,
                    2,
                    8,
                    5,
                    3,
                    2
                ]
            ],
            [
                [
                    8,
                    3,
                    7,
                    4,
                    6,
                    7,
                    4,
                    8,
                    9
                ]
            ]
        ],
        "starter_code": "\ndef digitize(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef alt_or(lst):\n\t    \"\"\"Create an OR function, without use of the 'or' keyword, that takes an list of boolean values and runs OR against all of them.\n\nAssume there will be between 1 and 6 variables, and return None for an empty list.\n    \"\"\"\n",
        "canonical_solution": "def alt_or(lst):\n    return any(lst) if lst else None",
        "inputs": [
            [
                []
            ],
            [
                [
                    false,
                    false,
                    false,
                    false,
                    false,
                    false
                ]
            ],
            [
                [
                    false,
                    false,
                    false,
                    false,
                    false,
                    true
                ]
            ]
        ],
        "outputs": [
            [
                null
            ],
            [
                false
            ],
            [
                true
            ]
        ],
        "starter_code": "\ndef alt_or(lst):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef greet(name):\n\t    \"\"\"Write a method that takes one argument as name and then greets that name, capitalized and ends with an exclamation point.\n\nExample:\n\n```\n\"riley\" --> \"Hello Riley!\"\n\"JACK\"  --> \"Hello Jack!\"\n```\n    \"\"\"\n",
        "canonical_solution": "def greet(name): \n    return f'Hello {name.title()}!'",
        "inputs": [
            [
                "\"riley\""
            ],
            [
                "\"molly\""
            ],
            [
                "\"BILLY\""
            ]
        ],
        "outputs": [
            [
                "\"Hello Riley!\""
            ],
            [
                "\"Hello Molly!\""
            ],
            [
                "\"Hello Billy!\""
            ]
        ],
        "starter_code": "\ndef greet(name):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def countSegments(self, s: str) -> int:\n            \"\"\"Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\n\nPlease note that the string does not contain any non-printable characters.\n\nExample:\n\nInput: \"Hello, my name is John\"\nOutput: 5\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def countSegments(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: int\n         \"\"\"\n         return len(s.split())",
        "inputs": [
            [
                "\"Hello, my name is John\""
            ]
        ],
        "outputs": [
            [
                5
            ]
        ],
        "starter_code": "\nclass Solution:\n    def countSegments(self, s: str) -> int:\n",
        "scope": [
            [
                "Class Body",
                1,
                7
            ],
            [
                "Function Body",
                2,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef findSquares(x,y):\n\t    \"\"\"A rectangle can be split up into a grid of 1x1 squares, the amount of which being equal to the product of the two dimensions of the rectangle. Depending on the size of the rectangle, that grid of 1x1 squares can also be split up into larger squares, for example a 3x2 rectangle has a total of 8 squares, as there are 6 distinct 1x1 squares, and two possible 2x2 squares. A 4x3 rectangle contains 20 squares.\nYour task is to write a function `findSquares` that returns the total number of squares for any given rectangle, the dimensions of which being given as two integers with the first always being equal to or greater than the second.\n    \"\"\"\n",
        "canonical_solution": "def findSquares(x,y):\n    return sum( (x-i) * (y-i) for i in range(y) )",
        "inputs": [
            [
                3,
                2
            ],
            [
                4,
                3
            ],
            [
                11,
                4
            ]
        ],
        "outputs": [
            [
                8
            ],
            [
                20
            ],
            [
                100
            ]
        ],
        "starter_code": "\ndef findSquares(x,y):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef trotter(n):\n\t    \"\"\"Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number N. Then she starts naming N, 2 × N, 3 × N, and so on.\nWhenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.\nBleatrix must start with N and must always name (i + 1) × N directly after i × N.\nFor example, suppose that Bleatrix picks N = 1692. She would count as follows:\n\nN = 1692. Now she has seen the digits 1, 2, 6, and 9.\n2N = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9.\n3N = 5076. Now she has seen all ten digits, and falls asleep.\n\nThe purpose of this kata is to return the last number Bleatrix Trotter sees before falling asleep.\nInput\nWill always be positive integer or zero\n\nOutput\nThe last number Bleatrix Trotter sees or \"INSOMNIA\" (-1 in Rust and C++) if she will count forever\n\nPlease note, this challenge is not my idea. It's from Google Code Jam 2016\n    \"\"\"\n",
        "canonical_solution": "def trotter(n):\n    i, numStr, numList =0,'',['0','1','2','3','4','5','6','7','8','9']\n    if n==0:\n        return('INSOMNIA')\n    while all([i in numStr for i in numList])!=True:\n        i+=1\n        numStr = numStr+str(n*i)\n    return(i*n)",
        "inputs": [
            [
                1692
            ],
            [
                2
            ],
            [
                7
            ]
        ],
        "outputs": [
            [
                5076
            ],
            [
                90
            ],
            [
                70
            ]
        ],
        "starter_code": "\ndef trotter(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                8
            ],
            [
                "If Statement Body",
                3,
                4
            ],
            [
                "While Loop Body",
                5,
                7
            ],
            [
                "List Comprehension",
                5,
                5
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef part(arr):\n\t    \"\"\"To celebrate today's launch of my Hero's new book: Alan Partridge: Nomad, We have a new series of kata arranged around the great man himself.\n\nGiven an array of terms, if any of those terms relate to Alan Partridge, return Mine's a Pint!\n\nThe number of ! after the t should be determined by the number of Alan related terms you find in the provided array (x). The related terms are:\n\nPartridge\nPearTree\nChat\nDan\nToblerone\nLynn\nAlphaPapa\nNomad\n\nIf you don't find any related terms, return 'Lynn, I've pierced my foot on a spike!!'\n\nAll Hail King Partridge\n\nOther katas in this series:\nAlan Partridge II - Apple Turnover\nAlan Partridge III - London\n    \"\"\"\n",
        "canonical_solution": "def part(arr):\n    l = [\"Partridge\", \"PearTree\", \"Chat\", \"Dan\", \"Toblerone\", \"Lynn\", \"AlphaPapa\", \"Nomad\"]\n    s = len([i for i in arr if i in l])\n    return \"Mine's a Pint\"+\"!\"*s if s>0 else 'Lynn, I\\'ve pierced my foot on a spike!!'",
        "inputs": [
            [
                [
                    "Grouse",
                    "Partridge",
                    "Pheasant"
                ]
            ],
            [
                [
                    "Pheasant",
                    "Goose",
                    "Starling",
                    "Robin"
                ]
            ],
            [
                [
                    "Grouse",
                    "Partridge",
                    "Partridge",
                    "Partridge",
                    "Pheasant"
                ]
            ]
        ],
        "outputs": [
            [
                "\"Mine's a Pint!\""
            ],
            [
                "\"Lynn, I've pierced my foot on a spike!!\""
            ],
            [
                "\"Mine's a Pint!!!\""
            ]
        ],
        "starter_code": "\ndef part(arr):\n",
        "scope": [
            [
                "Function Body",
                1,
                4
            ],
            [
                "List Comprehension",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef powers(n):\n\t    \"\"\"# Description\n\nGiven a number `n`, you should find a set of numbers for which the sum equals `n`. This set must consist exclusively of values that are a power of `2` (eg: `2^0 => 1, 2^1 => 2, 2^2 => 4, ...`).\n\nThe function `powers` takes a single parameter, the number `n`, and should return an array of unique numbers.\n\n## Criteria\n\nThe function will always receive a valid input: any positive integer between `1` and the max integer value for your language (eg: for JavaScript this would be `9007199254740991` otherwise known as `Number.MAX_SAFE_INTEGER`).\n\nThe function should return an array of numbers that are a **power of 2** (`2^x = y`).\n\nEach member of the returned array should be **unique**. (eg: the valid answer for `powers(2)` is `[2]`, not `[1, 1]`)\n\nMembers should be sorted in **ascending order** (small -> large). (eg: the valid answer for `powers(6)` is `[2, 4]`, not `[4, 2]`)\n    \"\"\"\n",
        "canonical_solution": "def powers(n):\n    return [1<<i for i, x in enumerate(reversed(bin(n))) if x == \"1\"]",
        "inputs": [
            [
                1
            ],
            [
                2
            ],
            [
                4
            ]
        ],
        "outputs": [
            [
                [
                    1
                ]
            ],
            [
                [
                    2
                ]
            ],
            [
                [
                    4
                ]
            ]
        ],
        "starter_code": "\ndef powers(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef tankvol(h, d, vt):\n\t    \"\"\"To introduce the problem think to my neighbor who drives a tanker truck. \nThe level indicator is down and he is worried\nbecause he does not know if he will be able to make deliveries. \nWe put the truck on a horizontal ground and measured the height of the liquid in the tank.\n\nFortunately the tank is a perfect cylinder and the vertical walls on each end are flat.\nThe height of the remaining liquid is `h`, the diameter of the cylinder is `d`,\nthe total volume is `vt` (h, d, vt are positive or null integers). \nYou can assume that `h` <= `d`.\n\nCould you calculate the remaining volume of the liquid?\nYour function `tankvol(h, d, vt)` returns an integer which is the truncated result (e.g floor)\nof your float calculation.\n\nExamples:\n\n```\ntankvol(40,120,3500) should return 1021 (calculation gives about: 1021.26992027)\n\ntankvol(60,120,3500) should return 1750\n\ntankvol(80,120,3500) should return 2478 (calculation gives about: 2478.73007973)\n```\n\nTank vertical section:\n\n![alternative text](http://i.imgur.com/wmt0U43.png)\n    \"\"\"\n",
        "canonical_solution": "import math\ndef tankvol(h, d, vt):\n    r = d/2.0\n    if h == r: return vt/2     # is the tank half full?\n    half = h>r                 # is it more than half full\n    h = d-h if half else h     # adjust h accordingly\n    a = r-h                    # perpendicular intercept of the chord\n    b = math.sqrt(r**2-a**2)   # half the chord\n    t = 2*math.asin(b/r)       # the angle the chord sweeps out\n    A = r**2*t/2 - b*a         # the area of the segment\n    v = vt*A/(math.pi*r**2)    # the volume of the segment\n    return int(vt-v) if half else int(v)\n    \n",
        "inputs": [
            [
                5,
                7,
                3848
            ],
            [
                2,
                7,
                3848
            ],
            [
                2,
                8,
                5026
            ]
        ],
        "outputs": [
            [
                2940
            ],
            [
                907
            ],
            [
                982
            ]
        ],
        "starter_code": "\ndef tankvol(h, d, vt):\n",
        "scope": [
            [
                "Function Body",
                2,
                12
            ],
            [
                "If Statement Body",
                4,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef wnUKR():\n    \"\"\"You are given a string S of length N consisting of lowercase English letters.\nWe will cut this string at one position into two strings X and Y.\nHere, we would like to maximize the number of different letters contained in both X and Y.\nFind the largest possible number of different letters contained in both X and Y when we cut the string at the optimal position.\n\n-----Constraints-----\n - 2 \\leq N \\leq 100\n - |S| = N\n - S consists of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nS\n\n-----Output-----\nPrint the largest possible number of different letters contained in both X and Y.\n\n-----Sample Input-----\n6\naabbca\n\n-----Sample Output-----\n2\n\nIf we cut the string between the third and fourth letters into X = aab and Y = bca, the letters contained in both X and Y are a and b.\nThere will never be three or more different letters contained in both X and Y, so the answer is 2.\n    \"\"\"\n",
        "canonical_solution": "import sys\nfrom io import StringIO\nimport unittest\nfrom collections import Counter\ndef wnUKR():\n    #\n    # abc096 b\n    #\n    class TestClass(unittest.TestCase):\n        def assertIO(self, input, output):\n            stdout, stdin = sys.stdout, sys.stdin\n            sys.stdout, sys.stdin = StringIO(), StringIO(input)\n            resolve()\n            sys.stdout.seek(0)\n            out = sys.stdout.read()[:-1]\n            sys.stdout, sys.stdin = stdout, stdin\n            self.assertEqual(out, output)\n        def test_入力例_1(self):\n            input = \"\"\"6\n    aabbca\"\"\"\n            output = \"\"\"2\"\"\"\n            self.assertIO(input, output)\n        def test_入力例_2(self):\n            input = \"\"\"10\n    aaaaaaaaaa\"\"\"\n            output = \"\"\"1\"\"\"\n            self.assertIO(input, output)\n        def test_入力例_3(self):\n            input = \"\"\"45\n    tgxgdqkyjzhyputjjtllptdfxocrylqfqjynmfbfucbir\"\"\"\n            output = \"\"\"9\"\"\"\n            self.assertIO(input, output)\n    def resolve():\n        N = int(input())\n        S = input()\n        ans = 0\n        for i in range(1, N-1):\n            x = Counter(S[0:i])\n            y = S[i:]\n            tmp = 0\n            for j in list(x.keys()):\n                if j in y:\n                    tmp += 1\n            ans = max(ans, tmp)\n        print(ans)\n    def __starting_point():\n        # unittest.main()\n        resolve()\n    __starting_point()",
        "inputs": [
            "6\naabbca\n",
            "10\naaaaaaaaaa\n",
            "45\ntgxgdqkyjzhyputjjtllptdfxocrylqfqjynmfbfucbir\n"
        ],
        "outputs": [
            "2\n",
            "1\n",
            "9\n"
        ],
        "starter_code": "\ndef wnUKR():\n",
        "scope": [
            [
                "Function Body",
                5,
                49
            ],
            [
                "Class Body",
                9,
                32
            ],
            [
                "Function Body",
                10,
                17
            ],
            [
                "Function Body",
                18,
                22
            ],
            [
                "Function Body",
                23,
                27
            ],
            [
                "Function Body",
                28,
                32
            ],
            [
                "Function Body",
                33,
                45
            ],
            [
                "For Loop Body",
                37,
                44
            ],
            [
                "For Loop Body",
                41,
                43
            ],
            [
                "If Statement Body",
                42,
                43
            ],
            [
                "Function Body",
                46,
                48
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef reverse_alternate(string):\n\t    \"\"\"Reverse every other word in a given string, then return the string. Throw away any leading or trailing whitespace, while ensuring there is exactly one space between each word. Punctuation marks should be treated as if they are a part of the word in this kata.\n    \"\"\"\n",
        "canonical_solution": "def reverse_alternate(string):\n    return \" \".join(y[::-1] if x%2 else y for x,y in enumerate(string.split()))",
        "inputs": [
            [
                "\"Did it work?\""
            ],
            [
                "\"I really hope it works this time...\""
            ],
            [
                "\"Reverse this string, please!\""
            ]
        ],
        "outputs": [
            [
                "\"Did ti work?\""
            ],
            [
                "\"I yllaer hope ti works siht time...\""
            ],
            [
                "\"Reverse siht string, !esaelp\""
            ]
        ],
        "starter_code": "\ndef reverse_alternate(string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef ChwKk():\n    \"\"\"New Year is coming and you are excited to know how many minutes remain before the New Year. You know that currently the clock shows $h$ hours and $m$ minutes, where $0 \\le hh < 24$ and $0 \\le mm < 60$. We use 24-hour time format!\n\nYour task is to find the number of minutes before the New Year. You know that New Year comes when the clock shows $0$ hours and $0$ minutes.\n\nYou have to answer $t$ independent test cases.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1439$) — the number of test cases.\n\nThe following $t$ lines describe test cases. The $i$-th line contains the time as two integers $h$ and $m$ ($0 \\le h < 24$, $0 \\le m < 60$). It is guaranteed that this time is not a midnight, i.e. the following two conditions can't be met at the same time: $h=0$ and $m=0$. It is guaranteed that both $h$ and $m$ are given without leading zeros.\n\n\n-----Output-----\n\nFor each test case, print the answer on it — the number of minutes before the New Year.\n\n\n-----Example-----\nInput\n5\n23 55\n23 0\n0 1\n4 20\n23 59\n\nOutput\n5\n60\n1439\n1180\n1\n    \"\"\"\n",
        "canonical_solution": "\ndef ChwKk():\n    a = int(input())\n    for i in range(a):\n        x, y = map(int, input().split())\n        t = x * 60 + y\n        print(24*60 - t)",
        "inputs": [
            "5\n23 55\n23 0\n0 1\n4 20\n23 59\n",
            "5\n23 55\n22 30\n21 10\n20 21\n19 59\n",
            "1\n1 2\n"
        ],
        "outputs": [
            "5\n60\n1439\n1180\n1\n",
            "5\n90\n170\n219\n241\n",
            "1378\n"
        ],
        "starter_code": "\ndef ChwKk():\n",
        "scope": [
            [
                "Function Body",
                2,
                7
            ],
            [
                "For Loop Body",
                4,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef how_many_bees(hive):\n\t    \"\"\"How many bees are in the beehive?\n\n* bees can be facing UP, DOWN, LEFT, or RIGHT \n* bees can share parts of other bees\n\nExamples\n\nEx1\n```\nbee.bee     \n.e..e..\n.b..eeb\n```\n*Answer: 5*\n\n\nEx2\n```\nbee.bee     \ne.e.e.e\neeb.eeb\n```\n*Answer: 8*\n\n# Notes\n\n* The hive may be empty or null/None/nil/...\n* Python: the hive is passed as a list of lists (not a list of strings)\n    \"\"\"\n",
        "canonical_solution": "from itertools import chain\ndef how_many_bees(hive):\n        return bool(hive) and sum(s.count('bee') + s.count('eeb') for s in map(''.join, chain(hive, zip(*hive))))",
        "inputs": [
            [
                null
            ]
        ],
        "outputs": [
            [
                0
            ]
        ],
        "starter_code": "\ndef how_many_bees(hive):\n",
        "scope": [
            [
                "Function Body",
                2,
                3
            ],
            [
                "Generator Expression",
                3,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef shortest_steps_to_num(num):\n\t    \"\"\"# Summary:\nGiven a number, `num`, return the shortest amount of `steps` it would take from 1, to land exactly on that number.\n\n# Description:\nA `step` is defined as either:\n- Adding 1 to the number: `num += 1`\n- Doubling the number: `num *= 2`\n\nYou will always start from the number `1` and you will have to return the shortest count of steps it would take to land exactly on that number.\n\n`1 <= num <= 10000`\n\nExamples:\n\n`num == 3` would return `2` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- +1 --> 3:        2 steps\n\n2 steps\n```\n\n`num == 12` would return `4` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- +1 --> 3:        2 steps\n3 -- x2 --> 6:        3 steps\n6 -- x2 --> 12:       4 steps\n\n4 steps\n```\n\n`num == 16` would return `4` steps:\n\n```\n1 -- +1 --> 2:        1 step\n2 -- x2 --> 4:        2 steps\n4 -- x2 --> 8:        3 steps\n8 -- x2 --> 16:       4 steps\n\n4 steps\n```\n    \"\"\"\n",
        "canonical_solution": "def shortest_steps_to_num(num):\n    steps = 0\n    \n    while num != 1:\n        if num % 2:\n            num -= 1\n        else:\n            num //= 2\n        \n        steps += 1\n    \n    return steps",
        "inputs": [
            [
                2
            ],
            [
                3
            ],
            [
                4
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                2
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef shortest_steps_to_num(num):\n",
        "scope": [
            [
                "Function Body",
                1,
                12
            ],
            [
                "While Loop Body",
                4,
                10
            ],
            [
                "If Statement Body",
                5,
                8
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef greatest(x, y, n):\n\t    \"\"\"Given an `x` and `y` find the smallest and greatest numbers **above** and **below** a given `n` that are divisible by both `x` and `y`.\n\n### Examples\n```python\ngreatest(2, 3, 20) => 18   # 18 is the greatest number under 20 that is divisible by both 2 and 3\nsmallest(2, 3, 20) => 24   # 24 is the smallest number above 20 that is divisible by both 2 and 3\n\ngreatest(5, 15, 100) => 90\nsmallest(5, 15, 100) => 105\n\ngreatest(123, 456, 789) => 0   # there are no numbers under 789 that are divisible by both 123 and 456\nsmallest(123, 456, 789) => 18696\n```\n\n**Notes:** \n\n1. you should never return `n` even if it is divisible by `x` and `y` always the number above or below it\n2. `greatest` should return 0 if there are no numbers under `n` that are divisible by both `x` and `y`\n3. and all arguments will be valid (integers greater than 0).\n\n### Note for Haskell users\n\n>Please take a look at [bkaes comment](http://www.codewars.com/kata/when-greatest-is-less-than-smallest/discuss#56418f0fbf1f44834d000050) and give us your opinion\n    \"\"\"\n",
        "canonical_solution": "from math import gcd\n\n\ndef greatest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n - 1) // z * z\n    \ndef smallest(x, y, n):\n    z = x * y // gcd(x, y)\n    return (n + z) // z * z\n",
        "inputs": [
            [
                2,
                3,
                20
            ],
            [
                13,
                17,
                100
            ],
            [
                10,
                100,
                100
            ]
        ],
        "outputs": [
            [
                18
            ],
            [
                0
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef greatest(x, y, n):\n",
        "scope": [
            [
                "Function Body",
                4,
                6
            ],
            [
                "Function Body",
                8,
                10
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef hbiSN():\n    \"\"\"In BerSoft $n$ programmers work, the programmer $i$ is characterized by a skill $r_i$.\n\nA programmer $a$ can be a mentor of a programmer $b$ if and only if the skill of the programmer $a$ is strictly greater than the skill of the programmer $b$ $(r_a > r_b)$ and programmers $a$ and $b$ are not in a quarrel.\n\nYou are given the skills of each programmers and a list of $k$ pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer $i$, find the number of programmers, for which the programmer $i$ can be a mentor.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ $(2 \\le n \\le 2 \\cdot 10^5$, $0 \\le k \\le \\min(2 \\cdot 10^5, \\frac{n \\cdot (n - 1)}{2}))$ — total number of programmers and number of pairs of programmers which are in a quarrel.\n\nThe second line contains a sequence of integers $r_1, r_2, \\dots, r_n$ $(1 \\le r_i \\le 10^{9})$, where $r_i$ equals to the skill of the $i$-th programmer.\n\nEach of the following $k$ lines contains two distinct integers $x$, $y$ $(1 \\le x, y \\le n$, $x \\ne y)$ — pair of programmers in a quarrel. The pairs are unordered, it means that if $x$ is in a quarrel with $y$ then $y$ is in a quarrel with $x$. Guaranteed, that for each pair $(x, y)$ there are no other pairs $(x, y)$ and $(y, x)$ in the input.\n\n\n-----Output-----\n\nPrint $n$ integers, the $i$-th number should be equal to the number of programmers, for which the $i$-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input.\n\n\n-----Examples-----\nInput\n4 2\n10 4 10 15\n1 2\n4 3\n\nOutput\n0 0 1 2 \n\nInput\n10 4\n5 4 1 5 4 3 7 1 2 5\n4 6\n2 1\n10 8\n3 5\n\nOutput\n5 4 0 5 3 3 9 0 2 5 \n\n\n\n-----Note-----\n\nIn the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel.\n    \"\"\"\n",
        "canonical_solution": "\ndef hbiSN():\n    def ke(i):\n        return a[i]\n    n,m=map(int,input().split())\n    a=list(map(int,input().split()))\n    b=[]\n    for i in range(n):\n        b.append(i)\n    b.sort(key=ke)\n    ans=[0]*n\n    k=0\n    for i in range(1,n):\n        if a[b[i]]==a[b[i-1]]:\n            k+=1\n            ans[b[i]]=i-k\n        else:\n            k=0\n            ans[b[i]]=i\n    for i in range(m):\n        r1,r2=map(int,input().split())\n        if (a[r1-1]>a[r2-1]):\n            ans[r1-1]-=1\n        elif a[r1-1]<a[r2-1]:\n            ans[r2-1]-=1\n    for i in ans:\n        print(i, end=' ')",
        "inputs": [
            "4 2\n10 4 10 15\n1 2\n4 3\n",
            "10 4\n5 4 1 5 4 3 7 1 2 5\n4 6\n2 1\n10 8\n3 5\n",
            "2 0\n3 1\n"
        ],
        "outputs": [
            "0 0 1 2 \n",
            "5 4 0 5 3 3 9 0 2 5 \n",
            "1 0 \n"
        ],
        "starter_code": "\ndef hbiSN():\n",
        "scope": [
            [
                "Function Body",
                2,
                27
            ],
            [
                "Function Body",
                3,
                4
            ],
            [
                "For Loop Body",
                8,
                9
            ],
            [
                "For Loop Body",
                13,
                19
            ],
            [
                "If Statement Body",
                14,
                19
            ],
            [
                "For Loop Body",
                20,
                25
            ],
            [
                "If Statement Body",
                22,
                25
            ],
            [
                "If Statement Body",
                24,
                25
            ],
            [
                "For Loop Body",
                26,
                27
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef modified_sum(a, n):\n\t    \"\"\"You are provided with array of positive non-zero ints and int n representing n-th power (n >= 2).\n\nFor the given array, calculate the sum of each value to the n-th power. Then subtract the sum of the original array.\n\nExample 1: Input: {1, 2, 3}, 3 --> (1 ^ 3 + 2 ^ 3 + 3 ^ 3 ) - (1 + 2 + 3) --> 36 - 6 --> Output: 30\n\nExample 2: Input: {1, 2}, 5  --> (1 ^ 5 + 2 ^ 5) - (1 + 2) --> 33 - 3 --> Output: 30\n    \"\"\"\n",
        "canonical_solution": "def modified_sum(lst, p):\n    return sum(n**p - n for n in lst)",
        "inputs": [
            [
                [
                    1,
                    2,
                    3
                ],
                3
            ],
            [
                [
                    1,
                    2
                ],
                5
            ],
            [
                [
                    3,
                    5,
                    7
                ],
                2
            ]
        ],
        "outputs": [
            [
                30
            ],
            [
                30
            ],
            [
                68
            ]
        ],
        "starter_code": "\ndef modified_sum(a, n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Generator Expression",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef product_array(numbers):\n\t    \"\"\"# Introduction and Warm-up (Highly recommended)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n___\n\n# Task\n\n**_Given_** an *array/list [] of integers* , **_Construct_** a *product array **_Of same size_** Such That prod[i] is equal to The Product of all the elements of Arr[] except Arr[i]*. \n___\n\n# Notes \n\n\n* **_Array/list_** size is *at least 2* .\n\n* **_Array/list's numbers_**  Will be **_only Positives_** \n\n* **_Repetition_** of numbers in *the array/list could occur*.\n___\n\n# Input >> Output Examples \n\n```\nproductArray ({12,20}) ==>  return {20,12}\n```\n## **_Explanation_**:\n\n* **_The first element_**  *in prod [] array* **_12_**  *is the product of all array's elements except the first element*\n\n* **_The second element_** **_20_**  *is the product of all array's elements except the second element* .\n___\n\n```\nproductArray ({1,5,2}) ==> return {10,2,5}\n```\n\n## **_Explanation_**: \n\n\n* **_The first element_**  **_10_** *is the product of all array's elements* **_except_** *the first element **_1_***\n\n* **_The second element_** **_2_** *is the product of all array's elements* **_except_** *the second element* **_5_** \n\n* **_The Third element_** **_5_** *is the product of all array's elements* **_except_** *the Third element* **_2_**.\n\n___\n\n```\nproductArray ({10,3,5,6,2}) return ==> {180,600,360,300,900}\n```\n\n## **_Explanation_**: \n\n\n* **_The first element_** **_180_**  *is the product of all array's elements* **_except_** *the first element*  **_10_** \n\n* **_The second element_** **_600_** *is the product of all array's elements*  **_except_**  *the second element*  **_3_** \n\n* **_The Third element_** **_360_** *is the product of all array's elements* **_except_** *the third element* **_5_**\n\n* **_The Fourth element_** **_300_** *is the product of all array's elements* **_except_** *the fourth element* **_6_** \n\n* *Finally* ,**_The Fifth element_** **_900_** *is the product of all array's elements* **_except_** *the fifth element* **_2_** \n\n___\n# [A more challenging version of this kata by Firefly2002](https://www.codewars.com/kata/array-product-sans-n)\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n    \"\"\"\n",
        "canonical_solution": "from operator import mul\nfrom functools import reduce\n\ndef product_array(numbers):\n    tot = reduce(mul,numbers)\n    return [tot//n for n in numbers]",
        "inputs": [
            [
                [
                    12,
                    20
                ]
            ],
            [
                [
                    3,
                    27,
                    4,
                    2
                ]
            ],
            [
                [
                    13,
                    10,
                    5,
                    2,
                    9
                ]
            ]
        ],
        "outputs": [
            [
                [
                    20,
                    12
                ]
            ],
            [
                [
                    216,
                    24,
                    162,
                    324
                ]
            ],
            [
                [
                    900,
                    1170,
                    2340,
                    5850,
                    1300
                ]
            ]
        ],
        "starter_code": "\ndef product_array(numbers):\n",
        "scope": [
            [
                "Function Body",
                4,
                6
            ],
            [
                "List Comprehension",
                6,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n            \"\"\"Given two strings s and t which consist of only lowercase letters.\n\nString t is generated by random shuffling string s and then add one more letter at a random position.\n\nFind the letter that was added in t.\n\nExample:\n\nInput:\ns = \"abcd\"\nt = \"abcde\"\n\nOutput:\ne\n\nExplanation:\n'e' is the letter that was added.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def findTheDifference(self, s, t):\n         \"\"\"\n         :type s: str\n         :type t: str\n         :rtype: str\n         \"\"\"\n         sums=sum([ord(i) for i in s]), sum([ord(i) for i in t])\n         return chr(sum([ord(i) for i in t])-sum([ord(i) for i in s])) ",
        "inputs": [
            [
                "\"abcd\"",
                "\"abcde\""
            ]
        ],
        "outputs": [
            [
                "\"e\""
            ]
        ],
        "starter_code": "\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n",
        "scope": [
            [
                "Class Body",
                1,
                9
            ],
            [
                "Function Body",
                2,
                9
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "List Comprehension",
                8,
                8
            ],
            [
                "List Comprehension",
                9,
                9
            ],
            [
                "List Comprehension",
                9,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef strange_coach(players):\n\t    \"\"\"# Task\n Mirko has been moving up in the world of basketball. He started as a mere spectator, but has already reached the coveted position of the national team coach!\n\n Mirco is now facing a difficult task: selecting five primary players for the upcoming match against Tajikistan. Since Mirko is incredibly lazy, he doesn't bother remembering players' names, let alone their actual skills. That's why he has settled on selecting five players who share the same first letter of their surnames, so that he can remember them easier. If there are no five players sharing the first letter of their surnames, Mirko will simply forfeit the game!\n\n Your task is to find the first letters Mirko's players' surnames can begin with(In alphabetical order), or return `\"forfeit\"` if Mirko can't gather a team.\n\n# Input/Output\n\n\n - `[input]` string array `players`\n\n  Array of players' surnames, consisting only of lowercase English letters.\n\n \n - `[output]` a string\n\n  A **sorted** string of possible first letters, or \"forfeit\" if it's impossible to gather a team.\n\n\n# Example\n\nFor `players = [\"michael\",\"jordan\",\"lebron\",\"james\",\"kobe\",\"bryant\"]`, the output should be `\"forfeit\"`.\n\n For\n ```\n players = [\"babic\",\"keksic\",\"boric\",\"bukic\",\n              \"sarmic\",\"balic\",\"kruzic\",\"hrenovkic\",\n              \"beslic\",\"boksic\",\"krafnic\",\"pecivic\",\n              \"klavirkovic\",\"kukumaric\",\"sunkic\",\"kolacic\",\n              \"kovacic\",\"prijestolonasljednikovic\"]\n```\nthe output should be \"bk\".\n    \"\"\"\n",
        "canonical_solution": "from collections import Counter\n\ndef strange_coach(players):\n    return ''.join(\n                  sorted(i for i,j in\n                          Counter(map(lambda x: x[0], players)).most_common()\n                              if j >= 5)) or 'forfeit'",
        "inputs": [
            [
                [
                    "michael",
                    "jordan",
                    "lebron",
                    "james",
                    "kobe",
                    "bryant"
                ]
            ],
            [
                [
                    "babic",
                    "keksic",
                    "boric",
                    "bukic",
                    "sarmic",
                    "balic",
                    "kruzic",
                    "hrenovkic",
                    "beslic",
                    "boksic",
                    "krafnic",
                    "pecivic",
                    "klavirkovic",
                    "kukumaric",
                    "sunkic",
                    "kolacic",
                    "kovacic",
                    "prijestolonasljednikovic"
                ]
            ],
            [
                [
                    "jgztazpytubijfsmjz",
                    "bokvgratzzdibku",
                    "qineboilzoqdqivc",
                    "bfctyltibtkbxq",
                    "vioxcuhqhikxeqwekqkjo",
                    "nrvsdhttr",
                    "eiaoajuwxpwmyliqikzcchid",
                    "bxrwawgor",
                    "gbsqaxotzmblxttj",
                    "kwchrcaconuwaivhvnyf",
                    "neiemapiica",
                    "bppao",
                    "bxujiwivsjfbqrzygpdgkyz",
                    "jnzrhhmcgcpffflpzwmqib",
                    "jhozlevckrrwimdmyzc",
                    "bomojotkqqditelsk",
                    "ywmbheywzfyqjjs",
                    "snwrclyjkbspysjftcmyak",
                    "eelrsgkuhu",
                    "dnyzsvqjjuqoc"
                ]
            ]
        ],
        "outputs": [
            [
                "\"forfeit\""
            ],
            [
                "\"bk\""
            ],
            [
                "\"b\""
            ]
        ],
        "starter_code": "\ndef strange_coach(players):\n",
        "scope": [
            [
                "Function Body",
                3,
                7
            ],
            [
                "Generator Expression",
                5,
                7
            ],
            [
                "Lambda Expression",
                6,
                6
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef hex_string_to_RGB(hex_string):\n\t    \"\"\"When working with color values it can sometimes be useful to extract the individual red, green, and blue (RGB) component values for a color. Implement a function that meets these requirements:\n\n+ Accepts a case-insensitive hexadecimal color string as its parameter (ex. `\"#FF9933\"` or `\"#ff9933\"`)\n+ Returns an object with the structure `{r: 255, g: 153, b: 51}` where *r*, *g*, and *b* range from 0 through 255\n\n**Note:** your implementation does not need to support the shorthand form of hexadecimal notation (ie `\"#FFF\"`)\n\n\n## Example\n\n```\n\"#FF9933\" --> {r: 255, g: 153, b: 51}\n```\n    \"\"\"\n",
        "canonical_solution": "def hex_string_to_RGB(s): \n    return {i:int(s[j:j+2],16) for i,j in zip('rgb',[1,3,5])}",
        "inputs": [
            [
                "\"#FF9933\""
            ],
            [
                "\"#beaded\""
            ],
            [
                "\"#000000\""
            ]
        ],
        "outputs": [
            [
                {
                    "r": 255,
                    "g": 153,
                    "b": 51
                }
            ],
            [
                {
                    "r": 190,
                    "g": 173,
                    "b": 237
                }
            ],
            [
                {
                    "r": 0,
                    "g": 0,
                    "b": 0
                }
            ]
        ],
        "starter_code": "\ndef hex_string_to_RGB(hex_string):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "Dict Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef generate_diagonal(n, l):\n\t    \"\"\"Create a function that returns an array containing the first `l` digits from the `n`th diagonal of [Pascal's triangle](https://en.wikipedia.org/wiki/Pascal's_triangle).\n\n`n = 0` should generate the first diagonal of the triangle (the 'ones'). The first number in each diagonal should be 1.\n\nIf `l = 0`, return an empty array. Assume that both `n` and `l` will be non-negative integers in all test cases.\n    \"\"\"\n",
        "canonical_solution": "def generate_diagonal(d, l):\n    result = [1] if l else []\n    for k in range(1, l):\n        result.append(result[-1] * (d+k) // k)\n    return result",
        "inputs": [
            [
                0,
                10
            ],
            [
                1,
                10
            ],
            [
                2,
                10
            ]
        ],
        "outputs": [
            [
                [
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1
                ]
            ],
            [
                [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10
                ]
            ],
            [
                [
                    1,
                    3,
                    6,
                    10,
                    15,
                    21,
                    28,
                    36,
                    45,
                    55
                ]
            ]
        ],
        "starter_code": "\ndef generate_diagonal(n, l):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "For Loop Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef how_many_pizzas(n):\n\t    \"\"\"How much bigger is a 16-inch pizza compared to an 8-inch pizza? A more pragmatic question is: How many 8-inch pizzas \"fit\" in a 16-incher?\n\nThe answer, as it turns out, is exactly four 8-inch pizzas. For sizes that don't correspond to a round number of 8-inchers, you must round the number of slices (one 8-inch pizza = 8 slices), e.g.:\n\n```python\nhow_many_pizzas(16) -> \"pizzas: 4, slices: 0\"\nhow_many_pizzas(12) -> \"pizzas: 2, slices: 2\"\nhow_many_pizzas(8) -> \"pizzas: 1, slices: 0\"\nhow_many_pizzas(6) -> \"pizzas: 0, slices: 4\"\nhow_many_pizzas(0) -> \"pizzas: 0, slices: 0\"\n```\nGet coding quick, so you can choose the ideal size for your next meal!\n    \"\"\"\n",
        "canonical_solution": "def how_many_pizzas(n):\n    return 'pizzas: {}, slices: {}'.format(*divmod(n * n // 8, 8))",
        "inputs": [
            [
                16
            ],
            [
                12
            ],
            [
                8
            ]
        ],
        "outputs": [
            [
                "\"pizzas: 4, slices: 0\""
            ],
            [
                "\"pizzas: 2, slices: 2\""
            ],
            [
                "\"pizzas: 1, slices: 0\""
            ]
        ],
        "starter_code": "\ndef how_many_pizzas(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef list_squared(m, n):\n\t    \"\"\"Divisors of 42 are : 1, 2, 3, 6, 7, 14, 21, 42.\nThese divisors squared are: 1, 4, 9, 36, 49, 196, 441, 1764.\nThe sum of the squared divisors is 2500 which is 50 * 50, a square!\n\nGiven two integers m, n (1 <= m <= n) we want to find all integers \nbetween m and n whose sum of squared divisors is itself a square.\n42 is such a number.\n\nThe result will be an array of arrays or of tuples (in C an array of Pair) or a string, each subarray having two elements,\nfirst the number whose squared divisors is a square and then the sum\nof the squared divisors.\n\n#Examples:\n```\nlist_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]\nlist_squared(42, 250) --> [[42, 2500], [246, 84100]]\n```\n\nThe form of the examples may change according to the language, see `Example Tests:` for more details.\n\n**Note**\n\nIn Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n    \"\"\"\n",
        "canonical_solution": "CACHE = {}\n\ndef squared_cache(number):\n    if number not in CACHE:\n        divisors = [x for x in range(1, number + 1) if number % x == 0]\n        CACHE[number] = sum([x * x for x in divisors])\n        return CACHE[number] \n    \n    return CACHE[number]\n\ndef list_squared(m, n):\n    ret = []\n\n    for number in range(m, n + 1):\n        divisors_sum = squared_cache(number)\n        if (divisors_sum ** 0.5).is_integer():\n            ret.append([number, divisors_sum])\n\n    return ret",
        "inputs": [
            [
                1,
                250
            ],
            [
                42,
                250
            ],
            [
                250,
                500
            ]
        ],
        "outputs": [
            [
                [
                    [
                        1,
                        1
                    ],
                    [
                        42,
                        2500
                    ],
                    [
                        246,
                        84100
                    ]
                ]
            ],
            [
                [
                    [
                        42,
                        2500
                    ],
                    [
                        246,
                        84100
                    ]
                ]
            ],
            [
                [
                    [
                        287,
                        84100
                    ]
                ]
            ]
        ],
        "starter_code": "\ndef list_squared(m, n):\n",
        "scope": [
            [
                "Function Body",
                3,
                9
            ],
            [
                "If Statement Body",
                4,
                7
            ],
            [
                "List Comprehension",
                5,
                5
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "Function Body",
                11,
                19
            ],
            [
                "For Loop Body",
                14,
                17
            ],
            [
                "If Statement Body",
                16,
                17
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef print_formatted(number):\n    # your code goes here\n\nif __name__ == '__main__':\n    n = int(input())\n    print_formatted(n)    \"\"\"=====Problem Statement=====\nGiven an integer, n, print the following values for each integer i from 1 to n:\n1. Decimal\n2. Octal\n3. Hexadecimal (capitalized)\n4. Binary\n\nThe four values must be printed on a single line in the order specified above for each i from 1 to n. Each value should be space-padded to match the width of the binary value of n.\n\n=====Input Format=====\nA single integer denoting n.\n\n=====Constraints=====\n1 ≤ n ≤ 99\n\n=====Output Format=====\nPrint n lines wehere each line i (in the range 1 ≤ i ≤ n) contains the respective decimal, octal, capitalized hexadecimal, and binary values of i. Each printed value must be formatted to the width of the binary value of n.\n    \"\"\"\n",
        "canonical_solution": "def print_formatted():\n    n = int(input().strip())\n    w = len(str(bin(n))[2:])\n    for i in range(1,n+1,1):\n        o = str(oct(i))[2:]\n        h = str(hex(i))[2:]\n        h = h.upper()\n        b = str(bin(i))[2:]\n        d = str(i)\n        print(('{:>{width}} {:>{width}} {:>{width}} {:>{width}}'.format(d,o,h,b,width=w)))\n",
        "inputs": [
            "2"
        ],
        "outputs": [
            " 1  1  1  1\n 2  2  2 10"
        ],
        "starter_code": "\ndef print_formatted():\n    # your code goes here\n\nif __name__ == '__main__':\n    n = int(input())\n    print_formatted(n)",
        "scope": [
            [
                "Function Body",
                1,
                10
            ],
            [
                "For Loop Body",
                4,
                10
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef four_piles(n,y):\n\t    \"\"\"## Problem\n\nThere are `n` apples that need to be divided into four piles. We need two mysterious number `x` and `y`. Let The number of first pile equals to `x+y`, the number of second pile equals to `x-y`, the number of third pile equals to `x*y`, the number of fourth pile equals to `x/y`. We need to calculate how many apples are there in each pile.\n\nOf course, there won't be so many unknowns. We know the total number of apples(`n`) and the second mysterious number(`y`). \n\nFor example: there are 48 apples need to divided into four piles. y=3. that is, 1st pile should be x+3, 2nd pile should be x-3, 3rd pile should be x*3, 4th pile should be x/3.\nDo you know how much `x` is? `x` should be 9, because:\n```\n(9 + 3) + (9 - 3) + (9 * 3) + (9 / 3) = 12 + 6 + 27 + 3 = 48\n```\nSo, 48 apples should be divided into `12, 6, 27, 3`.\n\n## Task\n\nComplete function `fourPiles()`/`four_piles()` that accepts two arguments `n` and `y`, return an array contains the number of for piles. Each element in the result array should be a positive integer. If can not divide, please return `[]`.\n\n## Examples\n\n```\nfourPiles 48 3 -- [12,6,27,3]  \n//The elements are arranged in sequence according to:\n//   x+y,x-y,x*y,x/y\n\nfourPiles 100 4 -- [20,12,64,4]  \n-- Verify correctness:\n-- x=16,y=4\n(16+4) + (16-4) + (16*4) + (16/4) -- 100\n\n-- Edge case:\nfourPiles 25 4  -- []  -- [8,0,16,1] is not a correct answer\n\nfourPiles 24 4  -- []  -- can not divide\n```\n    \"\"\"\n",
        "canonical_solution": "def four_piles(n,y):\n    x,r=divmod(n*y,(y+1)**2)\n    return [] if r or x==y else [x+y,x-y,x*y,x//y]\n",
        "inputs": [
            [
                48,
                3
            ],
            [
                100,
                4
            ],
            [
                25,
                4
            ]
        ],
        "outputs": [
            [
                [
                    12,
                    6,
                    27,
                    3
                ]
            ],
            [
                [
                    20,
                    12,
                    64,
                    4
                ]
            ],
            [
                []
            ]
        ],
        "starter_code": "\ndef four_piles(n,y):\n",
        "scope": [
            [
                "Function Body",
                1,
                3
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n            \"\"\"You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nExample:\n\n\nInput: 4\nOutput: false \nExplanation: If there are 4 stones in the heap, then you will never win the game;\n             No matter 1, 2, or 3 stones you remove, the last stone will always be \n             removed by your friend.\n    \"\"\"\n",
        "canonical_solution": "class Solution:\n     def canWinNim(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: bool\n         \"\"\"\n         return (n%4 != 0)",
        "inputs": [
            [
                4
            ]
        ],
        "outputs": [
            [
                false
            ]
        ],
        "starter_code": "\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n",
        "scope": [
            [
                "Class Body",
                1,
                7
            ],
            [
                "Function Body",
                2,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef get_score(arr) -> int:\n\t    \"\"\"# A History Lesson\n\nTetris is a puzzle video game originally designed and programmed by Soviet Russian software engineer Alexey Pajitnov. The first playable version was completed on June 6, 1984. Pajitnov derived its name from combining the Greek numerical prefix tetra- (the falling pieces contain 4 segments) and tennis, Pajitnov's favorite sport.\n\n# About scoring system\n\nThe scoring formula is built on the idea that more difficult line clears should be awarded more points. For example, a single line clear is worth `40` points, clearing four lines at once (known as a Tetris) is worth `1200`.\n\nA level multiplier is also used. The game starts at level `0`. The level increases every ten lines you clear. Note that after increasing the level, the total number of cleared lines is not reset.\n\nFor our task you can use this table:\n\n\n        .demo {\n    width:70%;\n                border:1px solid #C0C0C0;\n                border-collapse:collapse;\n                padding:5px;\n        }\n        .demo th {\n                border:1px solid #C0C0C0;\n                padding:5px;\n        }\n        .demo td {\n                border:1px solid #C0C0C0;\n                padding:5px;\n        }\n\n\n\nLevel\nPoints for 1 line\nPoints for 2 lines\nPoints for 3 lines\nPoints for 4 lines\n\n\n0\n40\n100\n300\n1200\n\n\n1\n80\n200\n600\n2400\n\n\n2\n120\n300\n900\n3600\n\n\n3\n160\n400\n1200\n4800\n\n\n...\n\n\n7\n320\n800\n2400\n9600\n\n\n...\nFor level n you must determine the formula by yourself using given examples from the table.\n\n\n\n# Task\n\nCalculate the final score of the game using original Nintendo scoring system\n\n# Input\n\nArray with cleaned lines.  \nExample: `[4, 2, 2, 3, 3, 4, 2]`  \nInput will always be valid: array of random length (from `0` to `5000`) with numbers from `0` to `4`.\n\n# Ouput\n\nCalculated final score.  \n`def get_score(arr) -> int: return 0`\n\n# Example\n```python\nget_score([4, 2, 2, 3, 3, 4, 2]); # returns 4900\n```\nStep 1: `+1200` points for 4 lines (current level `0`). Score: `0+1200=1200`;\\\nStep 2: `+100` for 2 lines. Score: `1200+100=1300`;\\\nStep 3: `+100`. Score: `1300+100=1400`;\\\nStep 4: `+300` for 3 lines (current level still `0`). Score: `1400+300=1700`.\\\nTotal number of cleaned lines 11 (`4 + 2 + 2 + 3`), so level goes up to `1` (level ups each 10 lines);\\\nStep 5: `+600` for 3 lines (current level `1`). Score: `1700+600=2300`;\\\nStep 6: `+2400`. Score: `2300+2400=4700`;\\\nStep 7: `+200`. Total score: `4700+200=4900` points.\n\n# Other  \n\nIf you like the idea: leave feedback, and there will be more katas in the Tetris series.\n\n* 7 kyuTetris Series #1 — Scoring System\n* 6 kyuTetris Series #2 — Primitive Gameplay\n* 6 kyuTetris Series #3 — Adding Rotation (TBA)\n* 5 kyuTetris Series #4 — New Block Types (TBA)\n* 4 kyuTetris Series #5 — Complex Block Types (TBA?)\n    \"\"\"\n",
        "canonical_solution": "points = [0, 40, 100, 300, 1200]\n\ndef get_score(arr) -> int:\n    cleared = 0\n    score = 0\n    for lines in arr:\n        level = cleared // 10\n        score += (level+1) * points[lines]\n        cleared += lines\n    return score",
        "inputs": [
            [
                [
                    0,
                    1,
                    2,
                    3,
                    4
                ]
            ],
            [
                [
                    0,
                    1,
                    1,
                    3,
                    0,
                    2,
                    1,
                    2
                ]
            ],
            [
                [
                    2,
                    0,
                    4,
                    2,
                    2,
                    3,
                    0,
                    0,
                    3,
                    3
                ]
            ]
        ],
        "outputs": [
            [
                1640
            ],
            [
                620
            ],
            [
                3300
            ]
        ],
        "starter_code": "\ndef get_score(arr) -> int:\n",
        "scope": [
            [
                "Function Body",
                3,
                10
            ],
            [
                "For Loop Body",
                6,
                9
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef not_primes(a, b):\n\t    \"\"\"You are given two positive integers `a` and `b` (`a < b <= 20000`). Complete the function which returns a list of all those numbers in the interval `[a, b)` whose digits are made up of prime numbers (`2, 3, 5, 7`) but which are not primes themselves.\n\n\nBe careful about your timing!\n\n\nGood luck :)\n    \"\"\"\n",
        "canonical_solution": "from math import sqrt\ndef is_prime(n):\n    if n < 2: return False\n    for x in range(2, int(sqrt(n)) + 1):\n        if n % x == 0: return False\n    return True\n\ndef all_dig_prime(n):\n    for d in str(n):\n        if d not in \"2357\": return False\n    return True\n\ndef not_primes(a, b):\n    res = []\n    for i in range(a,b):\n        if all_dig_prime(i) and not is_prime(i): res.append(i)\n    return res",
        "inputs": [
            [
                2,
                222
            ],
            [
                2,
                77
            ],
            [
                2700,
                3000
            ]
        ],
        "outputs": [
            [
                [
                    22,
                    25,
                    27,
                    32,
                    33,
                    35,
                    52,
                    55,
                    57,
                    72,
                    75,
                    77
                ]
            ],
            [
                [
                    22,
                    25,
                    27,
                    32,
                    33,
                    35,
                    52,
                    55,
                    57,
                    72,
                    75
                ]
            ],
            [
                [
                    2722,
                    2723,
                    2725,
                    2727,
                    2732,
                    2733,
                    2735,
                    2737,
                    2752,
                    2755,
                    2757,
                    2772,
                    2773,
                    2775
                ]
            ]
        ],
        "starter_code": "\ndef not_primes(a, b):\n",
        "scope": [
            [
                "Function Body",
                2,
                6
            ],
            [
                "If Statement Body",
                3,
                3
            ],
            [
                "For Loop Body",
                4,
                5
            ],
            [
                "If Statement Body",
                5,
                5
            ],
            [
                "Function Body",
                8,
                11
            ],
            [
                "For Loop Body",
                9,
                10
            ],
            [
                "If Statement Body",
                10,
                10
            ],
            [
                "Function Body",
                13,
                17
            ],
            [
                "For Loop Body",
                15,
                16
            ],
            [
                "If Statement Body",
                16,
                16
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef friend(x):\n\t    \"\"\"Make a program that filters a list of strings and returns a list with only your friends name in it.\n\nIf a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours! Otherwise, you can be sure he's not...\n\nEx: Input = [\"Ryan\", \"Kieran\", \"Jason\", \"Yous\"], Output = [\"Ryan\", \"Yous\"]\n\ni.e.\n\nNote: keep the original order of the names in the output.\n    \"\"\"\n",
        "canonical_solution": "def friend(x):\n    return [f for f in x if len(f) == 4]",
        "inputs": [
            [
                [
                    "Ryan",
                    "Kieran",
                    "Mark"
                ]
            ],
            [
                [
                    "Ryan",
                    "Jimmy",
                    "123",
                    "4",
                    "Cool Man"
                ]
            ],
            [
                [
                    "Jimm",
                    "Cari",
                    "aret",
                    "truehdnviegkwgvke",
                    "sixtyiscooooool"
                ]
            ]
        ],
        "outputs": [
            [
                [
                    "Ryan",
                    "Mark"
                ]
            ],
            [
                [
                    "Ryan"
                ]
            ],
            [
                [
                    "Jimm",
                    "Cari",
                    "aret"
                ]
            ]
        ],
        "starter_code": "\ndef friend(x):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef count_squares(n):\n\t    \"\"\"# Feynman's squares\nRichard Phillips Feynman was a well-known American physicist and a recipient of the Nobel Prize in Physics. He worked in theoretical physics and pioneered the field of quantum computing.\n\nRecently, an old farmer found some papers and notes that are believed to have belonged to Feynman. Among notes about mesons and electromagnetism, there was a napkin where he wrote a simple puzzle: \"how many different squares are there in a grid of NxN squares?\".\n\nFor example, when N=2, the answer is 5: the 2x2 square itself, plus the four 1x1 squares in its corners:\n\n\n\n# Task\n\nYou have to write a function\n\n```python\ndef count_squares(n):\n```\n\nthat solves Feynman's question in general. The input to your function will always be a positive integer.\n\n#Examples\n\n```python\ncount_squares(1) =  1\ncount_squares(2) =  5\ncount_squares(3) = 14\n```\n\n(Adapted from the Sphere Online Judge problem SAMER08F by Diego Satoba)\n    \"\"\"\n",
        "canonical_solution": "def count_squares(n):\n    return sum([i * i for i in range(n + 1 ) ] )",
        "inputs": [
            [
                1
            ],
            [
                2
            ],
            [
                3
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                5
            ],
            [
                14
            ]
        ],
        "starter_code": "\ndef count_squares(n):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef yNdkF():\n    \"\"\"You are given a connected undirected graph consisting of $n$ vertices and $m$ edges. There are no self-loops or multiple edges in the given graph.\n\nYou have to direct its edges in such a way that the obtained directed graph does not contain any paths of length two or greater (where the length of path is denoted as the number of traversed edges).\n\n\n-----Input-----\n\nThe first line contains two integer numbers $n$ and $m$ ($2 \\le n \\le 2 \\cdot 10^5$, $n - 1 \\le m \\le 2 \\cdot 10^5$) — the number of vertices and edges, respectively.\n\nThe following $m$ lines contain edges: edge $i$ is given as a pair of vertices $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$, $u_i \\ne v_i$). There are no multiple edges in the given graph, i. e. for each pair ($u_i, v_i$) there are no other pairs ($u_i, v_i$) and ($v_i, u_i$) in the list of edges. It is also guaranteed that the given graph is connected (there is a path between any pair of vertex in the given graph).\n\n\n-----Output-----\n\nIf it is impossible to direct edges of the given graph in such a way that the obtained directed graph does not contain paths of length at least two, print \"NO\" in the first line.\n\nOtherwise print \"YES\" in the first line, and then print any suitable orientation of edges: a binary string (the string consisting only of '0' and '1') of length $m$. The $i$-th element of this string should be '0' if the $i$-th edge of the graph should be directed from $u_i$ to $v_i$, and '1' otherwise. Edges are numbered in the order they are given in the input.\n\n\n-----Example-----\nInput\n6 5\n1 5\n2 1\n1 4\n3 1\n6 1\n\nOutput\nYES\n10100\n\n\n\n-----Note-----\n\nThe picture corresponding to the first example: [Image]\n\nAnd one of possible answers: $\\text{of}$\n    \"\"\"\n",
        "canonical_solution": "\ndef yNdkF():\n    n, m = map(int, input().split())\n    clr = [-1 for i in range(0, n)]\n    eds = []\n    \n    \n    def dfs():\n        cur = 0\n        st = [-1 for i in range(0, n + 1)]\n        st[cur] = 0\n        cur += 1\n        while cur > 0:\n            v = st[cur - 1]\n            cur -= 1\n            for x in g[v]:\n                if clr[x] != -1:\n                    if clr[x] == clr[v]:\n                        return False\n                    continue\n                clr[x] = clr[v] ^ 1\n                st[cur] = x\n                cur += 1\n        return True\n    \n    \n    g = [[] for i in range(0, n)]\n    for i in range(0, m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n        eds.append((u, v))\n    clr[0] = 0\n    if dfs():\n        print(\"YES\")\n        print(\"\".join(\"1\" if clr[u] < clr[v] else \"0\" for (u, v) in eds))\n    else:\n        print(\"NO\")",
        "inputs": [
            "6 5\n1 5\n2 1\n1 4\n3 1\n6 1\n",
            "10 10\n6 8\n9 10\n10 1\n2 10\n10 7\n3 1\n8 1\n2 1\n4 1\n5 10\n",
            "10 10\n6 3\n4 7\n7 1\n9 8\n8 10\n7 2\n5 2\n4 8\n6 7\n8 7\n"
        ],
        "outputs": [
            "YES\n10100\n",
            "NO\n",
            "NO\n"
        ],
        "starter_code": "\ndef yNdkF():\n",
        "scope": [
            [
                "Function Body",
                2,
                40
            ],
            [
                "List Comprehension",
                4,
                4
            ],
            [
                "Function Body",
                8,
                24
            ],
            [
                "List Comprehension",
                10,
                10
            ],
            [
                "While Loop Body",
                13,
                23
            ],
            [
                "For Loop Body",
                16,
                23
            ],
            [
                "If Statement Body",
                17,
                20
            ],
            [
                "If Statement Body",
                18,
                19
            ],
            [
                "List Comprehension",
                27,
                27
            ],
            [
                "For Loop Body",
                28,
                34
            ],
            [
                "If Statement Body",
                36,
                40
            ],
            [
                "Generator Expression",
                38,
                38
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef divisible_by_three(st):\n\t    \"\"\"A trick I learned in elementary school to determine whether or not a number was divisible by three is to add all of the integers in the number together and to divide the resulting sum by three. If there is no remainder from dividing the sum by three, then the original number is divisible by three as well.\n\nGiven a series of numbers as a string, determine if the number represented by the string is divisible by three.\n\nYou can expect all test case arguments to be strings representing values greater than 0. \n\nExample:\n\n```\n\"123\"      -> true\n\"8409\"     -> true\n\"100853\"   -> false\n\"33333333\" -> true\n\"7\"        -> false\n```\n    \"\"\"\n",
        "canonical_solution": "def divisible_by_three(s): \n    return int(s) % 3 == 0\n\n",
        "inputs": [
            [
                "\"123\""
            ],
            [
                "\"19254\""
            ],
            [
                "\"88\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                true
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef divisible_by_three(st):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef prime_maxlength_chain(n):\n\t    \"\"\"This kata is inspired on the problem #50 of the Project Euler. \n\nThe prime ``` 41```  is the result of the sum of many consecutive primes.\n\nIn fact, ``` 2 + 3 + 5 + 7 + 11 + 13 = 41 , (6 addens)   ``` \n\nFurthermore, the prime ``` 41```  is the prime below ``` 100 (val_max)```  that has the longest chain of consecutive prime addens.\n\nThe prime with longest chain of addens for ```val_max = 500``` is ```499``` with ```17``` addens. \n\nIn fact:\n```3+5+7+11+13+17+19+23+29+31+37+41+43+47+53+59+61= 499```\n\nFind the function ```prime_maxlength_chain()```(primeMaxlengthChain() javascript), that receives an argument ```val_max```, the upper limit, all the found primes should be less than ```val_max``` and outputs this found prime.\n\nLet's see some cases:\n```python\nprime_maxlength_chain(100) == [41]\nprime_maxlength_chain(500) == [499]\n```\nIf we have more than one prime with these features, the function should output an array with the found primes sorted.\n```python\nprime_maxlength_chain(499) == [379, 491]\n```\nRandom Tests for `val_max` (`valMax`)\n```\n100 ≤ val_max ≤ 500.000\n```\nEnjoy it!\n    \"\"\"\n",
        "canonical_solution": "# RWH primes\nLIMIT = 500000\nsieve = [True] * (LIMIT//2)\nfor n in range(3, int(LIMIT**0.5) +1, 2):\n    if sieve[n//2]: sieve[n*n//2::n] = [False] * ((LIMIT-n*n-1)//2//n +1)\nPRIMES = [2] + [2*i+1 for i in range(1, LIMIT//2) if sieve[i]]\n\n\ndef prime_maxlength_chain(val_max):\n    if val_max < 5:\n        return []\n    \n    found = []\n    \n    # the sum of the first 400 primes > LIMIT\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    \n    for size in range(max_size, 1, -1):\n        # if sequence size is even, it *must* start with 2\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n    \n        # if sequence size is odd, it *cannot* start with 2\n        else:\n            for start in range(1, max_size-size +1):\n                n = sum(PRIMES[start:start+size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            \n            if found:\n                return found",
        "inputs": [
            [
                100
            ],
            [
                200
            ],
            [
                500
            ]
        ],
        "outputs": [
            [
                [
                    41
                ]
            ],
            [
                [
                    197
                ]
            ],
            [
                [
                    499
                ]
            ]
        ],
        "starter_code": "\ndef prime_maxlength_chain(n):\n",
        "scope": [
            [
                "For Loop Body",
                4,
                5
            ],
            [
                "If Statement Body",
                5,
                5
            ],
            [
                "List Comprehension",
                6,
                6
            ],
            [
                "Function Body",
                9,
                36
            ],
            [
                "If Statement Body",
                10,
                11
            ],
            [
                "For Loop Body",
                16,
                19
            ],
            [
                "If Statement Body",
                17,
                19
            ],
            [
                "For Loop Body",
                21,
                36
            ],
            [
                "If Statement Body",
                23,
                36
            ],
            [
                "If Statement Body",
                25,
                26
            ],
            [
                "For Loop Body",
                30,
                33
            ],
            [
                "If Statement Body",
                32,
                33
            ],
            [
                "If Statement Body",
                35,
                36
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef triple_double(num1, num2):\n\t    \"\"\"Write a function \n```javascript \ntripledouble(num1,num2)\n```\n```python\ntriple_double(num1, num2)\n```\nwhich takes numbers `num1` and `num2` and returns `1` if there is a straight triple of a number at any place in `num1` and also a straight double of the **same** number in `num2`.\n\nIf this isn't the case, return `0`\n\n## Examples\n\n```python\ntriple_double(451999277, 41177722899) == 1\n# num1 has straight triple 999s and num2 has straight double 99s\n\ntriple_double(1222345, 12345) == 0\n# num1 has straight triple 2s but num2 has only a single 2\n\ntriple_double(12345, 12345) == 0\n\ntriple_double(666789, 12345667) == 1\n```\n    \"\"\"\n",
        "canonical_solution": "def triple_double(num1, num2):\n    return any([i * 3 in str(num1) and i * 2 in str(num2) for i in '0123456789'])",
        "inputs": [
            [
                451999277,
                41177722899
            ],
            [
                1222345,
                12345
            ],
            [
                12345,
                12345
            ]
        ],
        "outputs": [
            [
                1
            ],
            [
                0
            ],
            [
                0
            ]
        ],
        "starter_code": "\ndef triple_double(num1, num2):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ],
            [
                "List Comprehension",
                2,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef replace_letters(word):\n\t    \"\"\"In input string ```word```(1 word):\n* replace the vowel with the nearest left consonant.\n* replace the consonant with the nearest right vowel.\n\nP.S. To complete this task imagine the alphabet is a circle (connect the first and last element of the array in the mind). For example, 'a' replace with 'z', 'y' with 'a', etc.(see below)\n\nFor example:\n```\n'codewars' => 'enedazuu'\n'cat' => 'ezu'\n'abcdtuvwxyz' => 'zeeeutaaaaa'\n```\n\nIt is preloaded: \n\n```\nconst alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nconst consonants = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];\nconst vowels = ['a','e','i','o','u'];\n```\n\nP.S. You work with lowercase letters only.\n    \"\"\"\n",
        "canonical_solution": "def replace_letters(word):\n  return word.translate(str.maketrans('abcdefghijklmnopqrstuvwxyz','zeeediiihooooonuuuuutaaaaa')) \n",
        "inputs": [
            [
                "\"cat\""
            ],
            [
                "\"codewars\""
            ],
            [
                "\"abcdtuvwxyz\""
            ]
        ],
        "outputs": [
            [
                "\"ezu\""
            ],
            [
                "\"enedazuu\""
            ],
            [
                "\"zeeeutaaaaa\""
            ]
        ],
        "starter_code": "\ndef replace_letters(word):\n",
        "scope": [
            [
                "Function Body",
                1,
                2
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef substring_test(str1, str2):\n\t    \"\"\"Given 2 strings, your job is to find out if there is a substring that appears in both strings. You will return true if you find a substring that appears in both strings, or false if you do not. We only care about substrings that are longer than one letter long.\n\n#Examples:\n\n````\n*Example 1*\nSubstringTest(\"Something\",\"Fun\"); //Returns false\n\n*Example 2*\nSubstringTest(\"Something\",\"Home\"); //Returns true\n````\nIn the above example, example 2 returns true because both of the inputs contain the substring \"me\". (so**ME**thing and ho**ME**)  \nIn example 1, the method will return false because something and fun contain no common substrings. (We do not count the 'n' as a substring in this Kata because it is only 1 character long)\n\n#Rules:\nLowercase and uppercase letters are the same. So 'A' == 'a'.  \nWe only count substrings that are > 1 in length.  \n\n#Input:\nTwo strings with both lower and upper cases.\n#Output:\nA boolean value determining if there is a common substring between the two inputs.\n    \"\"\"\n",
        "canonical_solution": "def substring_test(first, second):\n    first = first.lower()\n    second = second.lower()\n\n    for i in range(len(first) - 2):\n        if first[i:i+2] in second:\n            return True\n    return False",
        "inputs": [
            [
                "\"Something\"",
                "\"Home\""
            ],
            [
                "\"Something\"",
                "\"Fun\""
            ],
            [
                "\"Something\"",
                "\"\""
            ]
        ],
        "outputs": [
            [
                true
            ],
            [
                false
            ],
            [
                false
            ]
        ],
        "starter_code": "\ndef substring_test(str1, str2):\n",
        "scope": [
            [
                "Function Body",
                1,
                8
            ],
            [
                "For Loop Body",
                5,
                7
            ],
            [
                "If Statement Body",
                6,
                7
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef land_perimeter(arr):\n\t    \"\"\"Task:\nGiven an array arr of strings complete the function landPerimeter by calculating the total perimeter of all the islands. Each piece of land will be marked with 'X' while the water fields are represented as 'O'. Consider each tile being a perfect 1 x 1piece of land. Some examples for better visualization:\n\n['XOOXO',\n  'XOOXO',\n  'OOOXO',\n  'XXOXO',\n  'OXOOO'] \n\nor \n\n\nshould return:\n\"Total land perimeter: 24\",\n\nwhile\n\n\n['XOOO',\n  'XOXO',\n  'XOXO',\n  'OOXX',\n  'OOOO']\n\n\n\nshould return: \"Total land perimeter: 18\"\nGood luck!\n    \"\"\"\n",
        "canonical_solution": "def land_perimeter(arr):\n   \n    I,J = len(arr),len(arr[0])\n    \n    P = 0\n    for i in range(I):\n        for j in range(J):\n            if arr[i][j] == 'X':\n                if i == 0   or arr[i-1][j] == 'O': P += 1\n                if i == I-1 or arr[i+1][j] == 'O': P += 1\n                if j == 0   or arr[i][j-1] == 'O': P += 1\n                if j == J-1 or arr[i][j+1] == 'O': P += 1\n                   \n                  \n    return 'Total land perimeter: ' + str(P)\n",
        "inputs": [
            [
                [
                    "OXOOOX",
                    "OXOXOO",
                    "XXOOOX",
                    "OXXXOO",
                    "OOXOOX",
                    "OXOOOO",
                    "OOXOOX",
                    "OOXOOO",
                    "OXOOOO",
                    "OXOOXX"
                ]
            ],
            [
                [
                    "OXOOO",
                    "OOXXX",
                    "OXXOO",
                    "XOOOO",
                    "XOOOO",
                    "XXXOO",
                    "XOXOO",
                    "OOOXO",
                    "OXOOX",
                    "XOOOO",
                    "OOOXO"
                ]
            ],
            [
                [
                    "XXXXXOOO",
                    "OOXOOOOO",
                    "OOOOOOXO",
                    "XXXOOOXO",
                    "OXOXXOOX"
                ]
            ]
        ],
        "outputs": [
            [
                "\"Total land perimeter: 60\""
            ],
            [
                "\"Total land perimeter: 52\""
            ],
            [
                "\"Total land perimeter: 40\""
            ]
        ],
        "starter_code": "\ndef land_perimeter(arr):\n",
        "scope": [
            [
                "Function Body",
                1,
                15
            ],
            [
                "For Loop Body",
                6,
                12
            ],
            [
                "For Loop Body",
                7,
                12
            ],
            [
                "If Statement Body",
                8,
                12
            ],
            [
                "If Statement Body",
                9,
                9
            ],
            [
                "If Statement Body",
                10,
                10
            ],
            [
                "If Statement Body",
                11,
                11
            ],
            [
                "If Statement Body",
                12,
                12
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef next_day_of_week(current_day, available_week_days):\n\t    \"\"\"# Task\n You have set an alarm for some of the week days.\n \n Days of the week are encoded in binary representation like this:\n```\n0000001 - Sunday\n0000010 - Monday\n0000100 - Tuesday\n0001000 - Wednesday\n0010000 - Thursday\n0100000 - Friday \n1000000 - Saturday```\nFor example, if your alarm is set only for Sunday and Friday, the representation will be `0100001`. \n\n Given the current day of the week, your task is to find the day of the week when alarm will ring next time.\n\n# Example\n\n For `currentDay = 4, availableWeekDays = 42`, the result should be `6`.\n \n ```\ncurrentDay = 4 means the current Day is Wednesday\navailableWeekDays = 42 convert to binary is \"0101010\"\nSo the next day is 6 (Friday)\n```\n\n# Input/Output\n\n\n - `[input]` integer `currentDay`\n \n The weekdays range from 1 to 7, 1 is Sunday and 7 is Saturday\n\n\n - `[input]` integer `availableWeekDays`\n \n An integer. Days of the week are encoded in its binary representation.\n\n\n - `[output]` an integer\n\n The next day available.\n    \"\"\"\n",
        "canonical_solution": "def next_day_of_week(current_day, available_week_days):\n    x = 2 ** current_day\n    while not x & available_week_days:\n        x = max(1, (x * 2) % 2 ** 7)\n    return x.bit_length()",
        "inputs": [
            [
                4,
                42
            ],
            [
                6,
                42
            ],
            [
                7,
                42
            ]
        ],
        "outputs": [
            [
                6
            ],
            [
                2
            ],
            [
                2
            ]
        ],
        "starter_code": "\ndef next_day_of_week(current_day, available_week_days):\n",
        "scope": [
            [
                "Function Body",
                1,
                5
            ],
            [
                "While Loop Body",
                3,
                4
            ]
        ],
        "difficulty": "introductory"
    },
    {
        "prompt": "\ndef scramble_words(words):\n\t    \"\"\"Background\nThere is a message that is circulating via public media that claims a reader can easily read a message where the inner letters of each words is scrambled, as long as the first and last letters remain the same and the word contains all the letters.\n\nAnother example shows that it is quite difficult to read the text where all the letters are reversed rather than scrambled.\n\nIn this kata we will make a generator that generates text in a similar pattern, but instead of scrambled or reversed, ours will be sorted alphabetically\n\nRequirement\nreturn a string where:\n1) the first and last characters remain in original place for each word\n2) characters between the first and last characters must be sorted alphabetically\n3) punctuation should remain at the same place as it started, for example: shan't -> sahn't\nAssumptions\n1) words are seperated by single spaces\n2) only spaces separate words, special characters do not,  for example: tik-tak -> tai-ktk\n3) special characters do not take the position of the non special characters, for example: -dcba  ->  -dbca\n4) for this kata puctuation is limited to 4 characters: hyphen(-), apostrophe('), comma(,) and period(.) \n5) ignore capitalisation\n\n\nfor reference: http://en.wikipedia.org/wiki/Typoglycemia\n    \"\"\"\n",
        "canonical_solution": "import re\n\ndef scramble_words(words):\n    def sort_letters(match):\n        s = match.group()\n        letters = iter(sorted(filter(str.isalpha, s[1:-1])))\n        return s[0] + \"\".join(next(letters) if c.isalpha() else c for c in s[1:-1]) + s[-1]\n    return re.sub(r'[a-z][^\\s]*[a-z]', sort_letters, words)",
        "inputs": [
            [
                "\"professionals\""
            ],
            [
                "\"i\""
            ],
            [
                "\"\""
            ]
        ],
        "outputs": [
            [
                "\"paefilnoorsss\""
            ],
            [
                "\"i\""
            ],
            [
                "\"\""
            ]
        ],
        "starter_code": "\ndef scramble_words(words):\n",
        "scope": [
            [
                "Function Body",
                3,
                8
            ],
            [
                "Function Body",
                4,
                7
            ],
            [
                "Generator Expression",
                7,
                7
            ]
        ],
        "difficulty": "introductory"
    }
]